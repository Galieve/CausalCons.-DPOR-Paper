\section{Iterative version}
\label{section:iterativeSTMC}

Finally we present an iterative version of algorithm \ref{algorithm:stmc2}. In general, for every $\iread$-event there is one $\iwrite$-event associated. Therefore, the number of swaps one execution may need to be computed is $O(n)$, where $n = |\readOp{\mathcal{E}}|$. If after every swap the number of events to be re-executed is large, the algorithm may end having $O(n^2)$ calls in the stack. As real programs tend to not be short, reducing the memory requirements is an interesting improvement. For doing so, we exploit the systematic exploration enforcing an order between all executions and traversing them according to it. In algorithm \ref{algorithm:sound-complete} the only non-deterministic instructions correspond to the for loops at lines \ref{algorithm:sound-complete:forEnd} and \ref{algorithm:sound-complete:forRead}; so for getting rid of it, we will enforce a concrete order between the events that appear in that instruction. This new version is presented as algorithm \ref{algorithm:stmc}.

On the case $a$ is a $\iread$-event, when determining the $\iwrite$-event $w$ that will be $\wro$-related with $a$, we will select in reverse chronologic order, starting from the last write-event according to the history order. The first time $a$ is executed at line \ref{algorithm:stmc:IMARead} and if $h'$ is consistent, $a$ will be maximally added. The rest of histories will be constructed at line \ref{algorithm:stmc:changeWR} and will be extended as $h'$ after breaking the inner while. On the other case, when we have finished a transaction and we have to produce a swap, we will decide which two events are meant to be swapped applying the history order. As after swapping some events may disappear from the history for being re-executed later on, we have to keep track of the decision we made.

For doing so, we will employ a global data-structure called \textit{backtrack points}. This function $B: \writeOp{\mathcal{E}} \to \mathcal{E}$ maps every $\iwrite$-event to the last $\iread$-event it has been swapped to. As it is global, its information remains even if the history gets modified and the event is no longer there. Finally, we integrate the function \textsc{prev} that given a history $h$ when the algorithm's state is $s$ returns a history $h'$ such that if the algorithm wouldn't modify the backtrack points at line \ref{algorithm:stmc:modifyBacktrackPoints}, then the algorithm would compute $h$ in its next step. In other words, it returns the history that algorithm \ref{algorithm:sound-complete} would without storing it in the stack.
% By lemma \ref{lemma:recursiveIterativeSame} and, we guarantee t
%relation of the new event addded.  

%we will mimic the recursive mechanisms into data-structures with at most linear size in the number of events. 

%In this new shape, the algorithm will have a global data-structure called \textit{backtrack points}. This function $B: \writeOp{\mathcal{E}} \to \mathcal{E}$ associates 
%By getting rid of recursion we can 

%\textcolor{red}{Explanation of backtrack points, the rest of the functions and adding some motivation.}

%\textcolor{red}{Shall we talk about the state of the program? What does it contain? Why?}

\begin{algorithm}[H]
	\caption{Optimal iterative \textsc{STMC}}
	\begin{algorithmic}[1]
		\InputAlgorithmic $h$: history.
		\While{$\btrue$}
		\label{algorithm:stmc:outer_loop}
		\If{ $\lnot \ \textsc{IsConsistent}_{\mathcal{M}}(h)$} $a \gets \bot$
		\ElsIf{$\textsc{IsComplete}(h)$}
		\State $\textsc{processHistory}(h)$; $\; a \gets \bot$
		\Else
		\State $a \gets  \textsc{next}(h)$; $\; h \gets h \bullet a$
		\label{algorithm:stmc:add_event}
		\EndIf
		\Switch{$a.type()$}
		\Comment{$\ibegin$ and $\iwrite$ processed at line \ref{algorithm:stmc:add_event}}
		\Case{$\iread$}
		\label{algorithm:stmc:IMARead}
		\State $x\in \mathcal{V}$ s.t. $\writeVar{a}{x}$; $\; h.\wro[a] \gets \max_{<_h}\{w \in h \ | \ \writeVar{w}{x}\}$
		\Break
		\EndCase
		\Case{$\iend$}
		\ForAll{$w \in \tr(a)$ s.t. $w.type() = \iwrite$}
		\State $B[w] \gets w$
		\EndFor
		\Break
		\EndCase
		\Case{$\bot$}
		\While{$\btrue$}
		\label{algorithm:stmc:inner_loop}
		\State $a \gets \last(h)$
		\If{$a.type() = \iread$, $\lnot \textsc{swapped}(a,h)$ and $\{w \in h \ | \ \textsc{canRead}(w, a, h) \} \neq \emptyset$}
		\label{algorithm:stmc:changeWR}
		\State $h.\wro[a] \gets \max_{<_h}\{w \in h \ | \ \textsc{canRead}(w, a, h) \}$
		\Break
		\ElsIf{$a.type() = \iwrite$ and $\{(w, r) \in \tr(a) \times h \ | \ \textsc{canSwap}(w,r,h)\} \neq \emptyset$}
		\State $w, r \gets \max_{<_h}\{w \in \tr(a), r \in h \ | \ \canSwap(w,r,h)\}$
		\State $D \gets \{e \ | \ r <_h e \land \lnot (\tr(e) \ [\wro \cup \so]^* \ \tr(a))\}$
		\State $h \gets h \setminus D$; $\; h.\wro[r] \gets w$; $\; B[w] \gets r$
		\label{algorithm:stmc:modifyBacktrackPoints}
		\Break
		\Else
		\State $h \gets \prev(h)$
		\EndIf
		
		\EndWhile
		\EndCase
		\EndSwitch
		\EndWhile
	\end{algorithmic}
	\label{algorithm:stmc}
\end{algorithm}

\begin{cframed}[pinegreen]
	\begin{equation}
		\textsc{canRead}(w, r, h) = \writeVar{w}{x} \land w <_h h.\wro[r]
	\end{equation}
	
	\begin{equation}
		\textsc{canSwap}(w, r, h) = \forall e \in h \text{ s.t. } e \geq_h r \land \lnot (\tr(e) \ [\wro \cup \so]^+ \ \tr(w)) \land \textsc{IMA}(e)
	\end{equation}
\end{cframed}

\begin{comment}
\begin{cframed}[pinegreen]
\begin{equation}
\begin{array}{ccc}
\textsc{canRead}(a,h) & = & \{w \in h \ | \  \writeVar{w}{x} \land w <_h h.\wro[a]\} \neq \emptyset
\end{array}
\end{equation}
\end{cframed}
\end{comment}



\begin{comment}

\subsection{Polynomial memory}

The algorithm presented in \ref{algorithm:stmc2} is sound, consistent and optimal, therefore any reasonable implementation would produce all possible histories of any program in a reasonable time. However, its memory consumption because of its recursive definition may force it to remain as a theoretical algorithm. In Figure~\ref{fig:exp_memory} we can see two histories, \ref{fig:exp_memory:a} and \ref{fig:exp_memory:b}, whose (unique) linearization produce two opposite orders for every transaction except the initial one. Supposing that $\ora$ order them from left to right, top to bottom, the number of calls to the function \textcolor{red}{name of the algorithm} is $5$. For producing a swap between the last and the other transactions 
%it is easy to see that the history in \ref{fig:exp_memory:a} is complete and all its read events are maximally added. 

\begin{figure}[H]

\centering
\begin{subfigure}[b]{.35\textwidth}
\resizebox{\textwidth}{!}{
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
semithick, transform shape]
\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \end{tabular}};

\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3, -2) {\begin{tabular}{l}
$\rd{x}{v_1} $ \\
$\wrt{x}{1}$
\end{tabular}};
\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {\begin{tabular}{l}
$\rd{x}{v_2} $ \\
$\wrt{x}{2}$
\end{tabular}};

\node[draw, rounded corners=2mm,outer sep=0] (t4) at (0, -2) {\begin{tabular}{l}
$\rd{x}{v_3} $ \\
$\wrt{x}{3}$
\end{tabular}};

\node[draw, rounded corners=2mm] (t5) at (3, -0) {\begin{tabular}{l}
$\rd{x}{v_4} $ \\
$\wrt{x}{4}$
\end{tabular}};


\path (t1) edge[left] node[yshift=0,xshift=0] {$\wro$} (t2);
\path (t2) edge[above] node[yshift=0,xshift=0] {$\wro$} (t3);
\path (t3) edge[right] node[yshift=0,xshift=0] {$\wro$} (t4);
\path (t4) edge[above] node[yshift=0,xshift=0] {$\wro$} (t5);
\end{tikzpicture}  

}
\caption{Initial history.}
\label{fig:exp_memory:a}
\end{subfigure}
\hspace{.5cm}
\centering
\begin{subfigure}[b]{.35\textwidth}
\resizebox{\textwidth}{!}{
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
semithick, transform shape]
\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \end{tabular}};

\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3, -2) {\begin{tabular}{l}
$\rd{x}{v_1} $ \\
$\wrt{x}{1}$
\end{tabular}};
\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {\begin{tabular}{l}
$\rd{x}{v_2} $ \\
$\wrt{x}{2}$
\end{tabular}};

\node[draw, rounded corners=2mm,outer sep=0] (t4) at (0, -2) {\begin{tabular}{l}
$\rd{x}{v_3} $ \\
$\wrt{x}{3}$
\end{tabular}};

\node[draw, rounded corners=2mm] (t5) at (3, -0) {\begin{tabular}{l}
$\rd{x}{v_4} $ \\
$\wrt{x}{4}$
\end{tabular}};


\path (t5) edge[above] node[yshift=0,xshift=0] {$\wro$} (t4);
\path (t4) edge[left] node[yshift=0,xshift=0] {$\wro$} (t3);
\path (t3) edge[above] node[yshift=0,xshift=0] {$\wro$} (t2);
\path (t1) edge[bend left] node[yshift=-13,xshift=0] {$\wro$} (t5);
\end{tikzpicture}  

}
\caption{Objective history.}
\label{fig:exp_memory:b}
\end{subfigure}

\caption{Two histories with opposite linearizations.}
\label{fig:exp_memory}

\end{figure}
\end{comment}

\begin{comment}
\While{true}
\If{ $\textsc{consistent}_{\mathcal{M}}(\tau)$} $a \gets \textsc{next}_P(\tau)$
\Comment{When selecting the event we also add it to the graph!}
\Else
$\ a \gets \bot$

\EndIf
\If{$a.ty = R$}
%$\tau.\wro[\tr(a)] \gets \tr(\max_{<_\pi} \writeOp_{a.var}{\pi})$
\ElsIf{$a.ty = \iend$}
\ForAll{$w \in \tr(a)$}
\State $B[w] \gets w$
\EndFor
\ElsIf {$a.ty = \bot$}
\While{true}
\Let $a \gets \max_{<_\pi}(\pi)$
\If{$a.ty = \bot$} \Return
%\ElsIf{$a.ty = R, \lnot \textsc{Swapped}(\tau, a)$ and $ \exists w \in \writeOp_{a.var}{\pi}$ s.t. $w <_\pi \tau.\wro[a]$}
%\State $\tau.\wro[a] \gets \max_{<_\pi} \{w \in \writeOp_{a.var}{\tau} \ | \ w <_\pi \tau.\wro[a] \}$
\Break
\ElsIf{$a.ty = \iend \land \ \exists w, r \in \pi$ s.t. $\textsc{SwapAndRead}(w,r,\pi,\tau)$}
\State $w \gets \max_{<_\pi} \{w \in \writeOp{\tr(a)} \ | \ \exists r \ | \  \textsc{SwapAndRead}(w,r,\pi,\tau) \}$
%\State $B[w] \gets \max_{<_\pi} \{r \in \reads_{w.var}(\pi) \ | \ \textsc{SwapAndRead}(w,r,\pi,\tau) \}$
\State $Del \gets \{e \in \pi \ | \ B[w] <_\pi e \land \lnot(\tr(e) \ [\so \cup \wro]^* \tr(w))\}$
\State $\tau.\wro(B[w]) \gets w$
%\State $S[B[a]] \gets \texttt{true}$
%\State $\tau \gets \tau\restriction_{\tau.\Dom(\tau) \setminus Del}$
\Break
\Else
\State $\langle \pi, \tau \rangle \gets \textsc{Prev}(\pi, \tau)$

\begin{comment}
\textcolor{red}{
\If{$act = \texttt{non-revisit} $} $G \gets G_p$
\Else
\State $S \gets [x \in G.E \ | \ x <_G a]$
\While{$G_p.E \setminus S \neq \emptyset$}
\State $d \gets \min_{next} G_p.E \setminus S$
\State $S \gets S \cup \{d \} \cup \{b \in G.E \cap G_p.E \setminus S \ | \ b \leq_G G_p.\wro(d)\}$
\EndWhile
\State $\langle G, G.E \rangle \gets \langle G_p, S\rangle$
\EndIf
}
\EndIf

\EndWhile
\EndIf
\EndWhile
\end{comment}





