%!TEX root = main.tex
\section{Transactional Programs}

\newcommand{\icommit}{\mathtt{commit}}

\subsection{Program Syntax}

\begin{figure}
\small
\begin{align*}
\key\in \Vars\quad \xvar\in\LVars
\end{align*}
\begin{minipage}[t]{.4\textwidth}
\begin{align*}
\mathsf{Prog} &  \eqdef  \mathsf{Sess} \ \mid\  \mathsf{Sess}\,||\,\mathsf{Prog} \\
\mathsf{Sess} & \eqdef  \mathsf{Trans} \ \mid\  \mathsf{Trans}; \mathsf{Sess} \\
\mathsf{Trans} & \eqdef  \ibegin; \mathsf{Body}; \icommit 
\end{align*}
\end{minipage}
\begin{minipage}[t]{.4\textwidth}
\begin{align*}
\mathsf{Body} & \eqdef  \mathsf{Instr} \ \mid\  \mathsf{Instr}; \mathsf{Body} \\
\mathsf{Instr} & \eqdef  \mathsf{InstrDB} \ \mid\  a := e \mid\ \iif{\phi(\vec{a})}{\mathsf{Instr}} \\
\mathsf{InstrDB} & \eqdef \xvar := \iread(\key)  \ \mid\  \iwrite(\key,\xvar) \\
%\mathsf{Local} & \eqdef  x := e
\end{align*}
\end{minipage}
%\vspace{-6mm}
\caption{Program syntax. The set of global variables is denoted by $\Vars$ while $\LVars$ denotes the set of local variables.
We use $\phi$ to denote Boolean expressions, and $e$ to denote expressions over local variables interpreted as values. We use $\vec{\cdot}$ to denote vectors of elements.}
\label{fig:syntax}
%\vspace{-4mm}
\end{figure}

Figure~\ref{fig:syntax} lists the definition of a simple programming language
that we use to represent applications running on top of a database. A program is a set of \emph{sessions} running in parallel, each
session being composed of a sequence of \emph{transactions}. Each transaction is
delimited by $\ibegin$ and $\icommit$ instructions, and its body contains instructions that access the
database and manipulate a set $\LVars$ of local variables.\footnote{For simplicity, we
assume that all the transactions in the program commit. Aborted transactions can
be ignored when reasoning about safety because their effects should be invisible
to other transactions.} We use symbols 
$a$, $b$, etc. to denote elements of $\LVars$.

For simplicity, we abstract the database state as a valuation to a set $\Vars$ of \emph{global} variables\footnote{In the context of a relational database, global variables correspond to fields/rows of a table while in the context of a key-value store, they correspond to keys.}. Therefore, the instructions accessing the database correspond to reading the value of a global variable and storing it into a local variable $a$ ($a := \iread(x)$) , writing the value of a local variable $a$ to a global variable $x$ ($\iwrite(x,a)$), or an assignment to a local variable $a$ ($a := e$). The set of values of global or local variables is denoted by $\Vals$. Assignments to local variables use expressions $e$ over local variables, which are interpreted as values and whose syntax is left unspecified. Each of these instructions can be guarded by a Boolean condition $\phi(\vec{a})$ over a set of local variables $\vec{a}$ (their syntax is not important). Our results assume bounded programs, and therefore, we omit other constructs like $\mathtt{while}$ loops.
%Other constructs like $\mathtt{while}$ loops can be defined in a similar way. 
%Let $\KVProgs$ denote the set of programs where a transaction body can contain only such instructions.

\subsection{Isolation Level Definition}

We present the axiomatic framework introduced
by \citet{DBLP:journals/pacmpl/BiswasE19} for defining isolation levels in
key-value stores.\footnote{Isolation levels are called consistency models by \citet{DBLP:journals/pacmpl/BiswasE19}.}  
Isolation levels are defined as logical constraints, called \emph{axioms}, over \emph{histories}, which are an abstract representation of the interaction between a program and the database in a concrete execution. 
% that record the sequence of reads and writes executed in each transaction, the order between transactions in each session, and a write-read relation (also called read-from) that ``justifies'' read values by associating each read to a write that wrote the value returned by the read.

%TODO SOME INTRO EXPLAINING THAT ISOLATION LEVELS ARE DEFINED AS AXIOMS OVER HISTORIES, WHICH REPRESENT THE INTERACTION BETWEEN A PROGRAM AND A STORE. 

\subsubsection{Histories}

Programs interact with a database by issuing transactions formed of $\ibegin$, $\iend$, $\textsf{read}$ and $\textsf{write}$ instructions. The effect of executing one such instruction is represented using an \emph{event} $\langle e, \mathit{type} \rangle$ where $e$ is an \textit{identifier} and $\mathit{type} $ is a \textit{type}. There are four types of events: $\ebegin$, $\eend$, $\erd{x,v}$ for reading value $v$ from global variable $x$, and $\ewrt{x,v}$ for writing value $v$ to global variable $x$. The set of events is denoted by $\Events$.
For a read or write event $e$, we use $\mathit{var}(e)$ to denote the variable $x$ and $\mathit{val}(e)$ the value $v$.

A \emph{transaction log} $\tup{t,E, \po}$ is an identifier $t$ and a finite set of events $E$ along with a strict total order $\po_t$ on $E$, called \emph{program order}.
%$T$  is a finite sequence of events ordered by a strict total order $\po_T$ called \emph{program order}. 
The minimal element of $\po_t$ is a $\ebegin$ event. A transaction log without an $\eend$ event is called \emph{pending} (if the $\eend$ event occurs, then it is maximal in $\po_t$). Otherwise, it is called \emph{complete}.

The program order $\po_t$ represents the order between instructions in the body of a transaction. We assume that each transaction log is well-formed in the sense that if a read of a global variable $x$ is preceded by a write to $x$ in $\po_t$, then it should return the value written by the last write to $x$ before the read (w.r.t. $\po_t$). This property is implicit in the definition of every isolation level that we are aware of. For simplicity, we may use the term \emph{transaction} instead of transaction log. %The  set of all transaction logs is denoted by $\mathsf{Tlogs}$.

%For every transaction $T$, we denote $\po_T$ the total order existing between the events in $T$.
%During the whole paper we will assume that every pair of transactions are disjoint and that both $\mathcal{E}$ and $\mathcal{T}$ are finite. Therefore, we denote the function $tr: \mathcal{E} \to \mathcal{T}$ that associates every event to the unique transaction it belongs to. %Moreover, we will assume there is a special transaction called \callout{initial} that contains exactly one write event for every possible variable.

The set of $\erd{x,\_}$ events in a transaction log $t$ that are \emph{not} preceded by a write to $x$ in $\po_t$, for some $x$, is denoted by $\readOp{t}$. As mentioned above, the other read events take their values from writes in the same transaction and their behavior is independent of other transactions. Also, the set of $\ewrt{x,\_}$ events in $t$ that are \emph{not} followed by other writes to $x$ in $\po_t$, for some $x$, is denoted by $\writeOp{t}$. If a transaction contains multiple writes to the same key, then only the last one (w.r.t. $\po_t$) can be visible to other transactions (w.r.t. any isolation level that we are aware of). The extension to sets of transaction logs is defined as usual. 
Also, we say that a transaction log $t$ \emph{writes} $x$, denoted by $\writeVar{t}{x}$, when $\writeOp{t}$ contains some $\ewrt{x,\_}$ event. 

A \emph{history} contains a set of transaction logs (with distinct identifiers)
ordered by a (partial) \emph{session order} $\so$ that represents the order
between transactions in the same session.\footnote{In the context of our programming language, $\so$ would be a union of total orders. This constraint is not important for defining isolation levels.} It also includes a
%ordering constraints imposed by the applications using the database. Most often, $\so$ is a union of sequences, each sequence being called a \emph{session}. 
\emph{write-read} relation (also called read-from) that ``justifies'' read values by associating each read to a transaction that wrote the value returned by the read.

\begin{definition}
 A \emph{history} $\tup{T, \so, \wro}$ is a set of transaction logs $T$ along with a strict partial \emph{session order} $\so$, and a 
\emph{write-read} relation $\wro\subseteq T\times \readOp{T}$ such that
the inverse of $\wro$ is a total function, if $(t,e)\in \wro$, where $e$ is a $\erd{x,v}$ event, then $\writeOp{t}$ contains some $\ewrt{x,v}$ event, 
and $\so\cup\wro$ is acyclic.
\end{definition}

We assume that every history includes a distinguished transaction log writing the initial values of all global variables. This transaction log precedes all the other transaction logs in $\so$. We use $\hist$, $\hist_1$, $\hist_2$, $\ldots$ to range over histories. The set of transaction logs $T$ in a history $\hist=\tup{T, \so, \wro}$ is denoted by $\tlogs{\hist}$.

For a variable $\key$, $\wro[\key]$ denotes the restriction of $\wro$ to reads of $\key$, \ie, $\wro[\key]=\wro\cap (T\times \{ e\ |\ e \mbox{ is a }\erd{\key,\_} \mbox{ event}\})$. Moreover, we extend the relations $\wro$ and $\wro[\key]$ to pairs of transactions by $\tup{t_1,t_2}\in \wro$, resp., $\tup{t_1,t_2}\in \wro[\key]$, iff there exists a $\rd{\key,\_}$ event $e$ in $t_2$ such that $\tup{t_1,e}\in \wro$, resp., $\tup{t_1,e}\in \wro[\key]$. 
We say that the transaction log $t_1$ is \emph{read} by the transaction log $t_2$ when $\tup{t_1,t_2}\in \wro$. 

\subsubsection{Axiomatic Framework}

\subsection{Program Semantics}

\begin{figure} [t]
\small
  \centering
  \begin{mathpar}
    \inferrule[spawn]{\tr \mbox{ fresh}\quad e \mbox{ fresh}\quad  \mathsf{P}(j) = \ibegin; \mathsf{Body}; \icommit; \mathsf{S} \quad \vec{\mathsf{B}}(j) = \epsilon}{
      \hist,\vec{\gamma},\vec{\mathsf{B}},\mathsf{P}
      \Rightarrow
      \hist \oplus_j \tup{\tr,\{\tup{e,\ebegin}\},\emptyset},\vec{\gamma}[j\mapsto \emptyset],\vec{\mathsf{B}}[j\mapsto \mathsf{Body}; \icommit],\mathsf{P}[j\mapsto \mathsf{S}]
    } 

    \inferrule[if-true]{\psi(\vec{x})[x\mapsto \vec{\gamma}(j)(x): x\in\vec{x}]\mbox{ true} \\
    \vec{\mathsf{B}}(j) = \iif{\psi(\vec{x})}{\mathsf{Instr}};\mathsf{B}
    }{
      \hist,\vec{\gamma},\vec{\mathsf{B}}, \mathsf{P}
      \Rightarrow
      \hist,\vec{\gamma},\vec{\mathsf{B}}[j\mapsto \mathsf{Instr};\mathsf{B}],\mathsf{P}
    } 

    \inferrule[if-false]{\psi(\vec{x})[x\mapsto \vec{\gamma}(j)(x): x\in\vec{x}]\mbox{ false} \\
    \vec{\mathsf{B}}(j) = \iif{\psi(\vec{x})}{\mathsf{Instr}};\mathsf{B}
    }{
      \hist,\vec{\gamma},\vec{\mathsf{B}}, \mathsf{P}
      \Rightarrow
      \hist,\vec{\gamma},\vec{\mathsf{B}}[j\mapsto \mathsf{B}],\mathsf{P}
    } 

    \inferrule[local]{v = \vec{\gamma}(j)(e) \\ \vec{\mathsf{B}}(j) = a := e;\mathsf{B}
    }{
      \hist,\vec{\gamma},\vec{\mathsf{B}}, \mathsf{P}
      \Rightarrow
      \hist,\vec{\gamma}[(j,\xvar)\mapsto \val],\vec{\mathsf{B}}[j\mapsto \mathsf{B}],\mathsf{P}
    } 

    \inferrule[write]{v = \vec{\gamma}(j)(x)\quad e\mbox{ fresh} \quad 
    \vec{\mathsf{B}}(j) = \iwrite(\key,\xvar);\mathsf{B}\quad \hist \oplus_j \tup{e,\ewrt{\key,\val}}\mbox{ satisfies $I$}
    }{
      \hist,\vec{\gamma},\vec{\mathsf{B}}, \mathsf{P}
      \Rightarrow
      \hist \oplus_j \tup{e,\ewrt{\key,\val}},\vec{\gamma},\vec{\mathsf{B}}[j\mapsto \mathsf{B}], \mathsf{P}
    } 

    \inferrule[read-local]{
    \writeOp{\mathit{last}(\hist,j)}\mbox{ contains a }\wrt{\key}{\val}\mbox{ event}\\
    e\mbox{ fresh } \\
    \vec{\mathsf{B}}(j) = \xvar := \iread(\key);\mathsf{B}
    }{
      \hist,\vec{\gamma},\vec{\mathsf{B}}, \mathsf{P}
      \Rightarrow
      \hist \oplus_j \tup{e,\erd{\key,\val}},\vec{\gamma}[(j,\xvar)\mapsto \val],\vec{\mathsf{B}}[j\mapsto \mathsf{B}],\mathsf{P}
    } 

    \inferrule[read-extern]{
    \writeOp{\mathit{last}(\hist,j)}\mbox{ does not contain a }\wrt{\key}{\val}\mbox{ event} \\
    e\mbox{ fresh }\\
    \vec{\mathsf{B}}(j) = \xvar := \iread(\key);\mathsf{B} \\
    \hist=(T,\so,\wro) \\
    \tr =\mathit{last}(\hist,j) \\
    \wrt{\key}{\val}\in\writeOp{\tr'}\mbox{ with $\tr'\in \transC{\hist}$ and $\tr\neq \tr'$} \\
    \hist' = (\hist \oplus_j \tup{e,\erd{\key,\val}}) \oplus \wro(\tr',e) \\
    \hist' \mbox{ satisfies }I }{
      \hist,\vec{\gamma},\vec{\mathsf{B}}, \mathsf{P}
      \Rightarrow
      \hist',\vec{\gamma}[(j,\xvar)\mapsto \val],\vec{\mathsf{B}}[j\mapsto \mathsf{B}],\mathsf{P}
    } 

    \inferrule[commit]{e\mbox{ fresh} \quad 
    \vec{\mathsf{B}}(j) = \icommit 
    }{
      \hist,\vec{\gamma},\vec{\mathsf{B}}, \mathsf{P}
      \Rightarrow
      \hist \oplus_j \tup{e,\icommit},\vec{\gamma},\vec{\mathsf{B}}[j\mapsto \epsilon], \mathsf{P}
    } 
  \end{mathpar}
% \vspace{-5mm}
  \caption{An operational semantics for transactional programs. Above, $\mathit{last}(h,j)$ denotes the last transaction log in the session order $\so(j)$ of $h$, and $\transC{\hist}$ denotes the set of transaction logs in $\hist$ that are complete.}
  \label{fig:op:sem:baseline}
\end{figure}

We define a small-step operational semantics for transactional programs, which is parametrized by an isolation level $I$. The semantics keeps a history of previously executed database accesses in order to maintain conformance to $I$. 

For readability, we define a program as a partial function $\mathsf{P}:\mathsf{SessId}\rightharpoonup \mathsf{Sess}$ that associates session identifiers in $\mathsf{SessId}$ with concrete code as defined in Figure~\ref{fig:syntax} (i.e., sequences of transactions). Similarly, the session order $\so$ in a history is defined as a partial function $\so:\mathsf{SessId}\rightharpoonup \mathsf{Tlogs}^*$ that associates session identifiers with sequences of transaction logs. Two transaction logs are ordered by $\so$ if one occurs before the other in some sequence $\so(j)$ with 
$j\in \mathsf{SessId}$.

Formally, the operational semantics is defined as a transition relation $\Rightarrow_I$ between \emph{configurations}, which are defined as tuples containing the following:
\begin{itemize}
	\item history $\hist$ storing the events generated by database accesses executed in the past, 
	\item a valuation map $\vec{\gamma}$ that records local variable values in the current transaction of each session ($\vec{\gamma}$ associates identifiers of sessions that have live transactions with valuations of local variables),
	\item a map $\vec{B}$ that stores the code of each live transaction (associating session identifiers with code), and
	\item sessions/transactions $\mathsf{P}$ that remain to be executed from the original program.
\end{itemize}



Before presenting the definition of $\Rightarrow_I$, we introduce some notation. Let $\hist$ be a history that contains a representation of $\so$ as above. We use $\hist\oplus_j \tup{\tr,E,\po}$ to denote a history where $\tup{\tr,E,\po}$ is appended to $\so(j)$. 
Also, for a event $e$, $\hist\oplus_j e$ is the history obtained from $\hist$ by adding $e$ to the last transaction log in $\so(j)$ and as a last event in the program order of this log (i.e.,  if $\so(j)=\sigma; \tup{t,E,\po}$, then the session order $\so'$ of $\hist\oplus_j e$ is defined by $\so'(k)=\so(k)$ for all $k\neq j$ and $\so(j) =\sigma; \tup{t,E\cup\{e\},\po\cup \{(e',e): e'\in E\}}$). Finally, for a history $\hist = \tup{T, \so, \wro}$, $\hist\oplus\wro(\tr,e)$ is the history obtained from $\hist$ by adding $(\tr,e)$ to the write-read relation.

Figure~\ref{fig:op:sem:baseline} lists the rules defining $\Rightarrow_I$. %(the others can be defined in a similar manner). 
\textsc{spawn} starts a new transaction in a session $j$ provided that this session has no live transaction ($\vec{\mathsf{B}}(j) = \epsilon$). It adds a transaction log with a single $\ebegin$ event to the history and schedules the body of the transaction. \textsc{if-true} and \textsc{if-false} check the truth value of a Boolean condition of an $\mathtt{if}$ conditional. \textsc{local} models the execution of an assignment to a local variable which does not impact the stored history. \textsc{read-local} and \textsc{read-extern} concern read instructions. \textsc{read-local} handles the case where the read follows a write on the variable $x$ in the same transaction: the read returns the value written by the last write on $x$ in that transaction. Otherwise, \textsc{read-extern} corresponds to reading a value written in another transaction $\tr'$. The transaction $\tr'$ is chosen non-deterministically as long as extending the current history with the write-read dependency associated to this choice leads to a history that still satisfies $I$. \textsc{read-extern} applies only when the executing transaction contains no write on the same variable.

An \emph{initial} configuration for program $\prog$ contains the program $\prog$ along with a history $\hist=\tup{\{\tr_0\},\emptyset,\emptyset}$, where $\tr_0$ is a transaction log containing only writes that write the initial values of all variables, and empty current transaction code ($\mathsf{B}=\epsilon$). 
An execution of a program $\prog$ under an isolation level $I$ is a sequence of configurations $c_0 c_1\ldots c_n$ where $c_0$ is an initial configuration for $\prog$, and $c_m\Rightarrow_I c_{m+1}$, for every $0\leq m < n$. We say that $c_n$ is \emph{$I$-reachable} from $c_0$.
The history of such an execution is the history $\hist$ in the last configuration $c_n$. 
A configuration is called \emph{final} if it contains the empty program ($\prog=\emptyset$).
Let $\histOf[I]{\prog}$ denote the set of all histories of an execution of $\prog$ under $I$ that ends in a final configuration.

