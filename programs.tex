%!TEX root = main.tex
\section{Transactional Programs}\label{sec:prelims}

\newcommand{\icommit}{\mathtt{commit}}

\subsection{Program Syntax}

\begin{figure}
\small
\begin{align*}
\key\in \Vars\quad \xvar\in\LVars
\end{align*}
\begin{minipage}[t]{.4\textwidth}
\begin{align*}
\mathsf{Prog} &  \eqdef  \mathsf{Sess} \ \mid\  \mathsf{Sess}\,||\,\mathsf{Prog} \\
\mathsf{Sess} & \eqdef  \mathsf{Trans} \ \mid\  \mathsf{Trans}; \mathsf{Sess} \\
\mathsf{Trans} & \eqdef  \ibegin; \mathsf{Body}; \icommit 
\end{align*}
\end{minipage}
\begin{minipage}[t]{.4\textwidth}
\begin{align*}
\mathsf{Body} & \eqdef  \mathsf{Instr} \ \mid\  \mathsf{Instr}; \mathsf{Body} \\
\mathsf{Instr} & \eqdef  \mathsf{InstrDB} \ \mid\  a := e \mid\ \iif{\phi(\vec{a})}{\mathsf{Instr}} \\
\mathsf{InstrDB} & \eqdef \xvar := \iread(\key)  \ \mid\  \iwrite(\key,\xvar) 
%\mathsf{Local} & \eqdef  x := e
\end{align*}
\end{minipage}
%\vspace{-6mm}
\caption{Program syntax. The set of global variables is denoted by $\Vars$ while $\LVars$ denotes the set of local variables.
We use $\phi$ to denote Boolean expressions over local variables, and $e$ to denote expressions over local variables interpreted as values. We use $\vec{\cdot}$ to denote vectors of elements.}
\label{fig:syntax}
%\vspace{-4mm}
\end{figure}

Figure~\ref{fig:syntax} lists the definition of a simple programming language
that we use to represent applications running on top of a database. A program is a set of \emph{sessions} running in parallel, each
session being composed of a sequence of \emph{transactions}. Each transaction is
delimited by $\ibegin$ and $\icommit$ instructions, and its body contains instructions that access the
database and manipulate a set $\LVars$ of local variables.\footnote{For simplicity, we
assume that all the transactions in the program commit. Aborted transactions can
be ignored when reasoning about safety because their effects should be invisible
to other transactions.} We use symbols 
$a$, $b$, etc. to denote elements of $\LVars$.

For simplicity, we abstract the database state as a valuation to a set $\Vars$ of \emph{global} variables\footnote{In the context of a relational database, global variables correspond to fields/rows of a table while in the context of a key-value store, they correspond to keys.}, ranged over using $x$, $y$, etc. The instructions accessing the database correspond to reading the value of a global variable and storing it into a local variable $a$ ($a := \iread(x)$) , writing the value of a local variable $a$ to a global variable $x$ ($\iwrite(x,a)$), or an assignment to a local variable $a$ ($a := e$). The set of values of global or local variables is denoted by $\Vals$. Assignments to local variables use expressions $e$ over local variables, which are interpreted as values and whose syntax is left unspecified. Each of these instructions can be guarded by a Boolean condition $\phi(\vec{a})$ over a set of local variables $\vec{a}$ (their syntax is not important). Our results assume bounded programs, as usual in SMC algorithms, and therefore, we omit other constructs like $\mathtt{while}$ loops.
%Other constructs like $\mathtt{while}$ loops can be defined in a similar way. 
%Let $\KVProgs$ denote the set of programs where a transaction body can contain only such instructions.

\subsection{Isolation Levels}

We present the axiomatic framework introduced
by \citet{DBLP:journals/pacmpl/BiswasE19} for defining isolation levels\footnote{Isolation levels are called consistency models by \citet{DBLP:journals/pacmpl/BiswasE19}.}.
Isolation levels are defined as logical constraints, called \emph{axioms}, over \emph{histories}, which are an abstract representation of the interaction between a program and the database in a concrete execution. 
% that record the sequence of reads and writes executed in each transaction, the order between transactions in each session, and a write-read relation (also called read-from) that ``justifies'' read values by associating each read to a write that wrote the value returned by the read.

%TODO SOME INTRO EXPLAINING THAT ISOLATION LEVELS ARE DEFINED AS AXIOMS OVER HISTORIES, WHICH REPRESENT THE INTERACTION BETWEEN A PROGRAM AND A STORE. 

\subsubsection{Histories}

Programs interact with a database by issuing transactions formed of $\ibegin$, $\iend$, $\textsf{read}$ and $\textsf{write}$ instructions. The effect of executing one such instruction is represented using an \emph{event} $\langle e, \mathit{type} \rangle$ where $e$ is an \textit{identifier} and $\mathit{type} $ is a \textit{type}. There are four types of events: $\ebegin$, $\eend$, $\erd{x}$ for reading the global variable $x$, and $\ewrt{x,v}$ for writing value $v$ to global variable $x$. The set of events is denoted by $\Events$.
For a read/write event $e$, we use $\mathit{var}(e)$ to denote the variable $x$. % and $\mathit{val}(e)$ the value $v$.

A \emph{transaction log} $\tup{t,E, \po_t}$ is an identifier $t$ and a finite set of events $E$ along with a strict total order $\po_t$ on $E$, called \emph{program order}.
%$T$  is a finite sequence of events ordered by a strict total order $\po_T$ called \emph{program order}. 
The minimal element of $\po_t$ is a $\ebegin$ event. A transaction log without a $\eend$ event is called \emph{pending}. Otherwise, it is called \emph{complete}. If the $\eend$ event occurs, then it is maximal in $\po_t$. The set $E$ of events in a transaction log $t$ is denoted by $\events{t}$.

The program order $\po_t$ represents the order between instructions in the body of a transaction. We assume that each transaction log is well-formed in the sense that if a read of a global variable $x$ is preceded by a write to $x$ in $\po_t$, then it should return the value written by the last write to $x$ before the read (w.r.t. $\po_t$). This property is implicit in the definition of every isolation level that we are aware of. For simplicity, we may use the term \emph{transaction} instead of transaction log. %The  set of all transaction logs is denoted by $\mathsf{Tlogs}$.

%For every transaction $T$, we denote $\po_T$ the total order existing between the events in $T$.
%During the whole paper we will assume that every pair of transactions are disjoint and that both $\mathcal{E}$ and $\mathcal{T}$ are finite. Therefore, we denote the function $tr: \mathcal{E} \to \mathcal{T}$ that associates every event to the unique transaction it belongs to. %Moreover, we will assume there is a special transaction called \callout{initial} that contains exactly one write event for every possible variable.

The set of $\erd{x}$ events in a transaction log $t$ that are \textit{not} preceded by a write to $x$ in $\po_t$, for some $x$, is denoted by $\readOp{t}$. As mentioned above, the other read events take their values from writes in the same transaction and their behavior is independent of other transactions. Also, the set of $\ewrt{x,\_}$ events in $t$ that are \textit{not} followed by other writes to $x$ in $\po_t$, for some $x$, is denoted by $\writeOp{t}$. If a transaction contains multiple writes to the same variable, then only the last one (w.r.t. $\po_t$) can be visible to other transactions (w.r.t. any isolation level that we are aware of). The extension to sets of transaction logs is defined as usual. 
Also, we say that a transaction log $t$ \emph{writes} $x$, denoted by $\writeVar{t}{x}$, when $\writeOp{t}$ contains some $\ewrt{x,\_}$ event. 

A \emph{history} contains a set of transaction logs (with distinct identifiers)
ordered by a (partial) \emph{session order} $\so$ that represents the order
between transactions in the same session\footnote{In the context of our programming language, $\so$ would be a union of total orders. This constraint is not important for defining isolation levels.}. It also includes a
%ordering constraints imposed by the applications using the database. Most often, $\so$ is a union of sequences, each sequence being called a \emph{session}. 
\emph{write-read} relation (also called read-from) that ``justifies'' read values by associating each read to a transaction that wrote the value returned by the read.

\begin{definition}
 A \emph{history} $\tup{T, \so, \wro}$ is a set of transaction logs $T$ along with a strict partial \emph{session order} $\so$, and a 
\emph{write-read} relation $\wro\subseteq T\times \readOp{T}$ such that
\begin{itemize}
	\item the inverse of $\wro$ is a total function, 
	\item if $(t,e)\in \wro$, where $e$ is a $\erd{x}$ event, then $\writeOp{t}$ contains some $\ewrt{x,\_}$ event, and
	\item $\so\cup\wro$ is acyclic.
\end{itemize}
\end{definition}

We assume that every history includes a distinguished transaction log writing the initial values of all global variables. This transaction log precedes all the other transaction logs in $\so$. We use $\hist$, $\hist_1$, $\hist_2$, $\ldots$ to range over histories. 

For a variable $\key$, $\wro_\key$ denotes the restriction of $\wro$ to reads of $\key$, \ie, $\wro_\key=\wro\cap (T\times \{ e\ |\ e \mbox{ is a }\erd{\key} \mbox{ event}\})$. Moreover, we extend the relations $\wro$ and $\wro_\key$ to pairs of transactions by $\tup{t_1,t_2}\in \wro$, resp., $\tup{t_1,t_2}\in \wro_\key$, iff there exists a $\rd{\key}$ event $e$ in $t_2$ such that $\tup{t_1,e}\in \wro$, resp., $\tup{t_1,e}\in \wro_\key$. 
We say that the transaction log $t_1$ is \emph{read} by the transaction log $t_2$ when $\tup{t_1,t_2}\in \wro$. 

For readability, we also extend $\so$ and $\wro$ to pairs of events by $(e_1,e_2)\in \so$ if $(\trans{h}{e_1},\trans{h}{e_2})\in\so$ and $(e_1,e_2)\in \wro$ if $e_1\in\writeOp{\trans{h}{e_1}}$, $(\trans{h}{e_1},e_2)\in\wro$, and $\mathit{var}(e_1)=\mathit{var}(e_2)$. We also define $\po=\bigcup_{t\in T} \po_t$.

The set of transaction logs $T$ in a history $\hist=\tup{T, \so, \wro}$ is denoted by $\tlogs{\hist}$, and the union of $\events{t}$ for $t\in T$ is denoted by $\events{\hist}$. Given a history $\hist$ and an event $e$ in $\hist$, $\trans{h}{e}$ is the transaction $t$ in $\hist$ that contains $e$. Also, we define $\writeOp{\hist}=\bigcup_{t\in \tlogs{h}}\writeOp{t}$ and $\readOp{\hist}=\bigcup_{t\in \tlogs{h}}\readOp{t}$.



%TODO NOT SURE THAT THE FOLLOWING DEFINITION IS NEEDED
%
%\begin{definition}
%Let $h$ be a history:
%\begin{itemize}
%\item $h$ is called \callout{complete} if every transaction is non-pending and \callout{incomplete} otherwise;
%\item $h$ is \callout{executed in isolation} if it contains at most one pending transaction;
%\item $h$ is called \callout{total} if it is complete and contains every transaction $T \in \mathcal{T}$.
%\end{itemize}
%\end{definition}
%
%\textcolor{red}{\sout{If the event $e =\nextEvent(h)$ is $\ibegin, \iwrite$ or $\iend$, we will denote by $h \bullet e$ the history $h' = \langle E', \so', \wro\rangle$ where $E' = \events{h} \cup \{e\}$ and $\so' = \so \cup \{\langle e', e \rangle \ | \ e' \in h \land \thread{e} = \thread{e'}\}$. On the other hand, if $e$ is a $\iread$ event, we will define the history $h_w' = h \bullet_w e$ for some $\iwrite$ event $w \in h$ as $\langle E', \so', \wro \cup \{\langle w, r \rangle\} \rangle$; where $E'$ and $\so'$ defined as before.}: Not well defined, just cut-pasted from below}. 
%
%\textcolor{red}{EXTENSIONS, $\mathcal{H}^<$ AND $\bullet$ OPERATOR NOT (yet) DEFINED IN THIS SECTION!!!!!!!}

\subsubsection{Axiomatic Framework}

\begin{figure}[t]
	\resizebox{\textwidth}{!}{
		\footnotesize
		\begin{tabular}{|c|c|c|}
			\hline &  & \\
			\begin{subfigure}[t]{.31\textwidth}
				\centering
				\begin{tikzpicture}[->,>=stealth,shorten >=1pt,auto,node distance=1cm,
					semithick, transform shape]
					\node[transaction state, text=black] at (0,0)       	(t_1)           {$t_1$};
					\node[transaction state, text=black, label={above:\textcolor{black}{$\writeVar{ }{x}$}}] at (-0.5,1.5) (t_2) {$t_2$};
					\node[transaction state, text=black] at (2,0)       (o_1)           {$\alpha$};
					\node[transaction state] at (1.5,1.5) (o_2) {$\beta$};
					\path (t_1) edge[color=wrColor] node {$\wro_x$} (o_1);
					% \path (t_2) edge[blue] node {$\CO$} (t_1);
					\path (t_2) edge[color=wrColor] node {$\wro$} (o_2);
					\path (o_2) edge[color=poColor] node {$\po$} (o_1);
					\path (t_2) edge[left,double,color=coColor] node {$\co$} (t_1);
				\end{tikzpicture}
				\parbox{\textwidth}{
					$\forall x,\ \forall t_1, t_2,\ \forall \alpha.\ t_1\neq t_2\ \land$
					
					\hspace{4mm}$\tup{t_1,\alpha}\in \wro_x \land \writeVar{t_2}{x}\ \land$ 
					
					\hspace{9mm}$\tup{t_2,\alpha}\in\wro\circ\po$
					
					\hspace{14mm}$\implies \tup{t_2,t_1}\in\co$
				}
				%\end{align*}
				
				\caption{$\mathsf{Read\ Committed}$}
				\label{lock_rc_def}
			\end{subfigure}
			
			&     
			
			
			\begin{subfigure}[t]{.35\textwidth}
				\centering
				\begin{tikzpicture}[->,>=stealth,shorten >=1pt,auto,node distance=1cm,
					semithick, transform shape]
					\node[transaction state, text=black] at (0,0)       (t_1)           {$t_1$};
					\node[transaction state] at (2,0)       (t_3)           {$t_3$};
					\node[transaction state, text=black,label={above:\textcolor{black}{$\writeVar{ }{\xvar}$}}] at (-.5,1.5) (t_2) {$t_2$};
					\path (t_1) edge[wrColor] node {$\wro_x$} (t_3);
					% \path (t_2) edge[blue] node {$\CO$} (t_1);
					\path (t_2) edge[bend left] node {$\so \cup \wro$} (t_3);
					\path (t_2) edge[left, double ,coColor] node {$\co$} (t_1);
				\end{tikzpicture}
				\parbox{\textwidth}{
					$\forall x,\ \forall t_1, t_2,\ \forall t_3.\ t_1\neq t_2\ \land$
					
					\hspace{4mm}$\tup{t_1,t_3}\in \wro_x \land \writeVar{t_2}{x}\ \land$ 
					
					\hspace{9mm}$\tup{t_2,t_3}\in\so \cup \wro$
					
					\hspace{14mm}$\implies \tup{t_2,t_1}\in\co$
				}
				
				\caption{$\mathsf{Read\ Atomic}$}
				\label{ra_def}
			\end{subfigure}
			
			&
			
			\begin{subfigure}[t]{.31\textwidth}
				\centering
				\begin{tikzpicture}[->,>=stealth,shorten >=1pt,auto,node distance=4cm,
					semithick, transform shape]
					\node[transaction state, text=black] at (0,0)       (t_1)           {$t_1$};
					\node[transaction state] at (2,0)       (t_3)           {$t_3$};
					\node[transaction state, text=black,label={above:\textcolor{black}{$\writeVar{ }{\key}$}}] at (-.5,1.5) (t_2) {$t_2$};
					\path (t_1) edge[wrColor] node {$\wro_x$} (t_3);
					% \path (t_2) edge[blue] node {$\CO$} (t_1);
					\path (t_2) edge[dashed, bend left] node {$(\so \cup \wro)^+$} (t_3);
					%   \path [->, decoration={snake}] (t_2) edge[decorate] node[auto] {F} (t_3);
					\path (t_2) edge[left,double equal sign distance,coColor] node {$\co$} (t_1);
				\end{tikzpicture}
				\parbox{\textwidth}{
					$\forall x,\ \forall t_1, t_2,\ \forall t_3.\ t_1\neq t_2\ \land$
					
					\hspace{4mm}$\tup{t_1,t_3}\in \wro_x \land \writeVar{t_2}{x}\ \land$ 
					
					\hspace{9mm}$\tup{t_2,t_3}\in(\so \cup \wro)^+$
					
					\hspace{14mm}$\implies \tup{t_2,t_1}\in\co$
				}
				
				\caption{$\mathsf{Causal\ Consistency}$}
				\label{cc_def}
			\end{subfigure}
			
			\\ \hline			  
			
			
			\begin{subfigure}[b]{.31\textwidth}
			\centering
			\begin{tikzpicture}[->,>=stealth,shorten >=1pt,auto,node distance=4cm,
			 semithick, transform shape]
			\node[transaction state, text=black] at (0,0)       (t_1)           {$t_1$};
			\node[transaction state] at (2,0)       (t_3)           {$t_3$};
			\node[transaction state, text=black,label={above:\textcolor{black}{$\writeVar{ }{x}$}}] at (-0.5,1.5) (t_2) {$t_2$};
			\node[transaction state] at (1.5,1.5) (t_4) {$t_4$};
			\path (t_1) edge[wrColor] node {$\wro_x$} (t_3);
			% \path (t_2) edge[blue] node {$\CO$} (t_1);
			\path (t_2) edge[coColor, double] node {$\co^*$} (t_4);
			\path (t_4) edge[left] node {$(\so \cup \wro)$} (t_3);
			\path (t_2) edge[left,double, coColor] node {$\co$} (t_1);
			\end{tikzpicture}
			\parbox{\textwidth}{
			$\forall \xvar,\ \forall t_1, t_2,\ \forall t_3.\ t_1\neq t_2\ \land$
			
			\hspace{4mm}$\tup{t_1,t_3}\in \wro_x \land \writeVar{t_2}{\xvar}\ \land$ 
			
			\hspace{9mm}$\tup{t_2,t_3}\in\co^*\circ\,(\wro\cup\so)$
			
			\hspace{14mm}$\implies \tup{t_2,t_1}\in\co$
			}
			
			\caption{$\mathsf{Prefix}$}
			\label{pre_def}
			\end{subfigure}
			     
			
			&
			\begin{subfigure}[b]{.35\textwidth}
			    \centering
			    \begin{tikzpicture}[->,>=stealth,shorten >=1pt,auto,node distance=4cm,
			      semithick, transform shape]
			     \node[transaction state, text=black] at (0,0)       (t_1)           {$t_1$};
			     \node[transaction state, label={right:$\writeVar{ }{\yvar}$}] at (2,0)       (t_3)           {$t_3$};
			     \node[transaction state, text=black,label={above:\textcolor{black}{$\writeVar{ }{\xvar}$}}] at (-.5,1.5) (t_2) {$t_2$};
			     \node[transaction state, label={right:{$\writeVar{}{\yvar}$}}] at (1.5,1.5) (t_4) {$t_4$};
			     \path (t_1) edge[wrColor] node {$\wro_x$} (t_3);
			     % \path (t_2) edge[blue] node {$\CO$} (t_1);
			     \path (t_2) edge [coColor, double] node {$\co^*$} (t_4);
			     \path (t_4) edge [coColor, double] node {$\co$} (t_3);
			     \path (t_2) edge[left,double, coColor] node {$\co$} (t_1);
			    \end{tikzpicture}
			    \parbox{\textwidth}{
			     $\forall \xvar,\ \forall t_1, t_2,\ \forall t_3, t_4,\ \forall \yvar.\ t_1\neq t_2\ \land$
			     
			     \hspace{4mm}$\tup{t_1,t_3}\in \wro_x \land \writeVar{t_2}{\xvar}\ \land$ 
			     
			     \hspace{9mm}$\writeVar{t_3}{\yvar}\ \land \writeVar{t_4}{\yvar}\ \land$ 
			     
			     \hspace{12mm}$\tup{t_2,t_4}\in\co^*\ \land \tup{t_4,t_3}\in\co$
			     
			     \hspace{16mm}$\implies \tup{t_2,t_1}\in\co$
			    }
			    
			    \caption{$\mathsf{Conflict}$}
			    \label{confl_def}
			   \end{subfigure}
			&     
			\begin{subfigure}[b]{.31\textwidth}
				\centering
				\begin{tikzpicture}[->,>=stealth,shorten >=1pt,auto,node distance=4cm,
					semithick, transform shape]
					\node[transaction state, text=black] at (0,0)       (t_1)           {$t_1$};
					\node[transaction state] at (2,0)       (t_3)           {$t_3$};
					\node[transaction state, text=black, label={above:\textcolor{black}{$\writeVar{ }{x}$}}] at (-.5,1.5) (t_2) {$t_2$};
					\path (t_1) edge[wrColor] node {$\wro_x$} (t_3);
					% \path (t_2) edge[blue] node {$\CO$} (t_1);
					\path (t_2) edge[bend left, double, coColor] node {$\co$} (t_3);
					\path (t_2) edge[left,double, coColor] node {$\co$} (t_1);
				\end{tikzpicture}
				\parbox{\textwidth}{
					$\forall x,\ \forall t_1, t_2,\ \forall t_3.\ t_1\neq t_2\ \land$
					
					\hspace{4mm}$\tup{t_1,t_3}\in \wro_x \land \writeVar{t_2}{x}\ \land$ 
					
					\hspace{9mm}$\tup{t_2,t_3}\in\co$
					
					\hspace{14mm}$\implies \tup{t_2,t_1}\in\co$
				}
				
				\caption{$\mathsf{Serializability}$}
				\label{ser_def}
			\end{subfigure}
		
		\\\hline
		\end{tabular}
	}
	%  \vspace{-3mm}
	\caption{Axioms defining isolations levels. The reflexive and transitive, resp., transitive, closure of a relation $rel$ is denoted by $rel^*$, resp., $rel^+$. Also, $\circ$ denotes the composition of two relations, i.e., $rel_1 \circ rel_2 = \{\tup{a, b} | \exists c. \tup{a, c} \in rel_1 \land \tup{c, b} \in rel_2\}$.}
	\label{fig:consistency_defs}
	%  \vspace{-2mm}
\end{figure}

A history is said to satisfy a certain isolation level if there exists a strict total order $\co$ on its transaction logs, called \emph{commit order}, which extends the write-read relation and the session order, and which satisfies certain properties. These properties, called \emph{axioms}, relate the commit order with the session-order and the write-read relation in the history. 
%The axioms define mandatory $\co$ predecessors $\tr_2$ of a transaction $\tr_1$ that is read in the history. 
They are defined as 
first-order formulas of the following form:
\begin{align}
  & \forall \key,\ \forall \tr_1\neq \tr_2,\ \forall \tau.\ \nonumber\\
  & \hspace{3mm}  \tup{\tr_1,\tau}\in \wro[\key] \land \writeVar{\tr_2}{\key} \land \phi(\tr_2,\tau) \implies \tup{\tr_2,\tr_1}\in\co \label{eq:axiom}
%  & \hspace{5.4cm} \implies \tup{\tr_2,\tr_1}\in\co \nonumber
\end{align}
where $\phi$ is a property relating $\tr_2$ and $\tau$ (i.e., the read or the
transaction reading from $\tr_1$) that varies from one axiom to another.\footnote{These formulas are interpreted on tuples $\tup{\hist,\co}$ of a history $\hist$ and a commit order $\co$ on the transactions in $\hist$ as usual.}  Intuitively, this axiom schema states the following: in order for $\tau$ to read specifically $t_1$'s write on $k$, it must be the case that every $t_2$ that also writes $k$ and satisfies $\phi(t_2,\tau)$ was committed before $t_1$. 
%Note that in all cases we consider, $\phi(t_2,\tau)$ already ensures that $t_2$ is committed before the read $\tau$, so this axiom schema ensures that $t_2$ is furthermore committed before $t_1$'s write.
The property $\phi$ relates $\tr_2$ and $\tau$ using the relations in a history and the commit order. 
Figure~\ref{fig:consistency_defs} shows four axioms which correspond to their homonymous isolation levels: \textit{Read Committed} ($\RC$), \textit{Read Atomic} ($\RA$), \textit{Causal Consistency} ($\CC$), and \textit{Serializability} ($\SER$). The conjunction of the other two axioms Conflict and Prefix defines \textit{Snapshot Isolation} ($\SI$). Note that $\SER$ is stronger than $\SI$ (i.e., every history satisfying $\SER$ satisfies $\SI$ as well), $\SI$ is stronger than $\CC$, $\CC$ is stronger than $\RA$, and $\RA$ is stronger than $\RC$.
% as the model where prefix and conflict axioms both hold. 
%We say a history $h$ satisfies an isolation level $I$ if there is a total order called \callout{commit order} $\co$ that extend $\so \cup \wro$ and satisfies its axioms. However, by the definition of $\RC, \RA$ and $\CC$, it is clear that for every history $h$ s.t. the relation $\co$ deduced from $\so \cup \wro$ is acyclic exists a commit order for those isolation levels.
%Figure~\ref{fig:consistency_defs} shows the axioms defining Read Committed, Causal Consistency, and Serializability (see \citet{DBLP:journals/pacmpl/BiswasE19} for axioms defining Read Atomic, Prefix, and Snapshot Isolation). 



%For instance, $\mathsf{Read\ Committed}$~\cite{DBLP:conf/sigmod/BerensonBGMOO95} requires that every read returns a value written in a committed transaction, and also, that the reads in the same transaction are ``monotonic'', i.e., they do not return values that are older, w.r.t. the commit order, than values read in the past.
%%\footnote{This monotonicity property corresponds to the fact that in the original formulation of $\mathsf{Read\ Committed}$~\cite{DBLP:conf/sigmod/BerensonBGMOO95}, every write is guarded by the acquisition of a lock on the written key, that is held until the end of the transaction.}. 
%While the first condition holds for every history (because of the surjectivity of $\wro$), the second condition is expressed by the axiom $\mathsf{Read\ Committed}$ in Figure~\ref{lock_rc_def}, which states that for any transaction $\tr_1$ writing a key $\key$ that is read at an operaion $\alpha$ in a transaction, the set of transactions $\tr_2$ writing $\key$ and read previously in the same transaction (these reads may concern other keys) must precede $\tr_1$ in commit order. 
%For instance, Figure~\ref{rc_example:1} shows a history and a (partial) commit order that does not satisfy this axiom because $\rd{\key_1}{1}$ returns the value written in a transaction ``older'' than the transaction read in the previous $\rd{\key_2}{2}$. %An exa


\begin{figure}
  
   \centering
%   \begin{subfigure}{.3\textwidth}
%  \resizebox{\textwidth}{!}{
%\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
%    semithick, transform shape]
%    \node[draw, rounded corners=2mm] (t1) at (0, 0) {\begin{tabular}{l} $\wrt{\key_1}{1}$ \end{tabular}};
%   \node[draw, rounded corners=2mm,outer sep=0] (t2) at (0, -1.5) {\begin{tabular}{l} $\wrt{\key_1}{2}$ \\ $\wrt{\key_2}{2}$\end{tabular}};
%   \node[draw, rounded corners=2mm, minimum width=1.8cm, minimum height=2.5cm] (t3) at (3, -0.75) {};
%   \node[style={inner sep=0,outer sep=0}] (t3_1) at (3, 0) {\begin{tabular}{l} $\rd{\key_2}{2}$ \end{tabular}};
%   \node[style={inner sep=0,outer sep=0}] (t3_2) at (3, -1.5) {\begin{tabular}{l} $\rd{\key_1}{1}$ \end{tabular}};
%   % \path (t1) edge node {} (t3_2);
%   % \path (t2) edge node {} (t3_1);
%   \path (t1) edge node {$\co$} (t2);
%   \path (t3_1) edge node {$\po$} (t3_2);
%   \path (t1) edge[below] node[yshift=-4,xshift=4] {$\wro$} (t3_2);
%   \path (t2) edge node[yshift=-2,xshift=7] {$\wro$} (t3_1);
%  \end{tikzpicture}  
%    }
%    \caption{$\mathsf{Read\ Committed}$ violation.}
%    \label{rc_example:1}
%\end{subfigure}
%\hspace{1cm}
\begin{subfigure}{.4\textwidth}
\resizebox{\textwidth}{!}{
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
 semithick, transform shape]
 \node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]180:$t_1$}] (t1) at (0, 1.5) {$\ewrt{x,1}$};
\node[draw, rounded corners=2mm,outer sep=0,label={[font=\small]0:$t_2$}] (t2) at (3, 1.5) {\begin{tabular}{l} $\erd{x}$ \\ $\ewrt{x,2}$ \end{tabular}};
\node[draw, rounded corners=2mm,outer sep=0,label={[font=\small]0:$t_3$}] (t3) at (3, 0) {\begin{tabular}{l} $\erd{x}$ \\ $\erd{y}$ \end{tabular}};
\node[draw, rounded corners=2mm,outer sep=0,label={[font=\small]180:$t_4$}] (t4) at (0, 0) {\begin{tabular}{l} $\erd{x}$ \\ $\ewrt{y,1}$\end{tabular}};

\path (t1) edge[above] node[yshift=0,xshift=0] {$\wro_x$} (t2);

\path (t1) edge[below] node[yshift=-3,xshift=3] {$\wro_x$} (t3);

\path (t2) edge[above] node[yshift=-6,xshift=-18] {$\wro_x$} (0,0.58);

\path (t4) edge[below] node[yshift=0,xshift=0] {$\wro_y$} (t3);
\end{tikzpicture}  
}
% \caption{Causal C violation.}
% \label{cc_example:1}
\end{subfigure}
%\vspace{-3mm}
  \caption{Causal Consistency violation. Boxes group events from the same transaction.}
  \label{counter_example:1}
%\vspace{-3mm}
\end{figure}

For instance, the axiom defining Causal Consistency~\cite{DBLP:journals/cacm/Lamport78} states that for any transaction $\tr_1$ writing a variable $x$ that is read in a transaction $\tr_3$, the set of $(\wro\cup \so)^+$ predecessors of $\tr_3$ writing $x$ must precede $\tr_1$ in commit order ($(\wro\cup \so)^+$ is usually called the \emph{causal} order). A violation of this axiom can be found in Figure~\ref{counter_example:1}: the transaction $\tr_2$ writing 2 to $x$ is a $(\wro\cup \so)^+$ predecessor of the transaction $\tr_3$ reading 1 from $x$ because the transaction $\tr_4$, writing 1 to $y$, reads $x$ from $\tr_2$ and $\tr_3$ reads $y$ from $\tr_4$. This implies that $\tr_2$ should precede in commit order the transaction $\tr_1$ writing 1 to $x$, which again, is inconsistent with the write-read relation ($\tr_2$ reads from $\tr_1$).

The $\mathsf{Serializability}$ axiom requires that for any transaction $\tr_1$ writing to a variable $x$ that is read in a transaction $\tr_3$, the set of $\co$ predecessors of $\tr_3$ writing $x$ must precede $\tr_1$ in commit order. This ensures that each transaction observes the effects of all the $\co$ predecessors. 

%It was shown in~\cite{DBLP:journals/pacmpl/BiswasE19} that as expected, $\mathsf{Serializability}$ implies $\mathsf{Causal}$, which implies $\mathsf{Read\ Committed}$ (when interpreted as first-order formulas).

\begin{definition}
For an isolation level $I$ defined by a set of axioms $X$, a history
$\hist=\tup{T, \so, \wro}$ \emph{satisfies} $I$ iff there is a strict total
order $\co$ s.t. $\wro\cup\so\subseteq \co$ and $\tup{h,\co}$ satisfies $X$.\footnote{Isolation levels like Snapshot Isolation require more than one axiom.}
 % Given a $\CO$(\textit{commit order}), a total order on $T$ which extends $\wro \cup \so$, we can define consistency axioms from table \ref{consistency_defs}. For each axiom, the situation in the table implies, $\Path{\tr_2}{\CO}{\tr_1}$.
 \label{axiom-criterion}
\end{definition}

A history that satisfies an isolation level $I$ is called $I$-consistent.

%=====
%
%To fully model any behavior of a transactional concurrent program we are obliged to formally describe the database section. This notion will be depicted as the concept of \textit{model}:
%
%%Those notions are generic enough to only describe a possible set of instructions that a parallel program may execute along with the $\wr$ relations that exist between them.
%
%\begin{comment}
%\begin{definition}
%An axiomatic \callout{model} $\mathcal{M}$ over histories is a collection of rules that enforce a \callout{consistency criterion} over them. The histories that satisfy those criteria are called \callout{consistent} while the rest are simply denoted inconsistent. 
%\end{definition}
%\end{comment}
%
%\begin{definition}
%An axiomatic \callout{model} $\mathcal{M}$ over histories is a collection of rules that enforce a \callout{consistency criterion} over them. The histories that satisfy those criteria are called \callout{$\mathcal{M}$-consistent} while the rest are simply denoted $\mathcal{M}$-inconsistent. If there is no ambiguity on the model, we will simply denote them consistent or inconsistent.%
%
%\end{definition}
%
%
%
%In figure \ref{fig:consistency_defs} it is depicted five axioms which correspond to their homonymous isolation levels: \textit{Read Committed} ($\RC$), \textit{Read Atomic} ($\RA$), \textit{Causal Consistency} ($\CC$)  \textit{Prefix Consistency} ($\PRE$) and \textit{Serializability} ($\SER$); along with the conflict axiom. Conflict and Prefix allow us to define \textit{Snapshot Isolation} ($\SI$) as the model where prefix and conflict axioms both hold. We say a history $h$ satisfies an isolation level $I$ if there is a total order called \callout{commit order} $\co$ that extend $\so \cup \wro$ and satisfies its axioms. However, by the definition of $\RC, \RA$ and $\CC$, it is clear that for every history $h$ s.t. the relation $\co$ deduced from $\so \cup \wro$ is acyclic exists a commit order for those isolation levels.
%
%TODO DEFINE $I$-consistent histories

\subsection{Program Semantics}\label{ssec:semantics}

\begin{figure} [t]
\small
  \centering
  \begin{mathpar}
    \inferrule[spawn]{\tr \mbox{ fresh}\quad e \mbox{ fresh}\quad  \mathsf{P}(j) = \ibegin; \mathsf{Body}; \icommit; \mathsf{S} \quad \vec{\mathsf{B}}(j) = \epsilon}{
      \hist,\vec{\gamma},\vec{\mathsf{B}},\mathsf{P}
      \Rightarrow_I
      \hist \oplus_j \tup{\tr,\{\tup{e,\ebegin}\},\emptyset},\vec{\gamma}[j\mapsto \emptyset],\vec{\mathsf{B}}[j\mapsto \mathsf{Body}; \icommit],\mathsf{P}[j\mapsto \mathsf{S}]
    } 

    \inferrule[if-true]{\psi(\vec{x})[x\mapsto \vec{\gamma}(j)(x): x\in\vec{x}]\mbox{ true} \\
    \vec{\mathsf{B}}(j) = \iif{\psi(\vec{x})}{\mathsf{Instr}};\mathsf{B}
    }{
      \hist,\vec{\gamma},\vec{\mathsf{B}}, \mathsf{P}
      \Rightarrow_I
      \hist,\vec{\gamma},\vec{\mathsf{B}}[j\mapsto \mathsf{Instr};\mathsf{B}],\mathsf{P}
    } 

    \inferrule[if-false]{\psi(\vec{x})[x\mapsto \vec{\gamma}(j)(x): x\in\vec{x}]\mbox{ false} \\
    \vec{\mathsf{B}}(j) = \iif{\psi(\vec{x})}{\mathsf{Instr}};\mathsf{B}
    }{
      \hist,\vec{\gamma},\vec{\mathsf{B}}, \mathsf{P}
      \Rightarrow_I
      \hist,\vec{\gamma},\vec{\mathsf{B}}[j\mapsto \mathsf{B}],\mathsf{P}
    } 

    \inferrule[local]{v = \vec{\gamma}(j)(e) \\ \vec{\mathsf{B}}(j) = a := e;\mathsf{B}
    }{
      \hist,\vec{\gamma},\vec{\mathsf{B}}, \mathsf{P}
      \Rightarrow_I
      \hist,\vec{\gamma}[(j,\xvar)\mapsto \val],\vec{\mathsf{B}}[j\mapsto \mathsf{B}],\mathsf{P}
    } 

    \inferrule[write]{v = \vec{\gamma}(j)(x)\quad e\mbox{ fresh} \quad 
    \vec{\mathsf{B}}(j) = \iwrite(\key,\xvar);\mathsf{B}\quad \hist \oplus_j \tup{e,\ewrt{\key,\val}}\mbox{ satisfies $I$}
    }{
      \hist,\vec{\gamma},\vec{\mathsf{B}}, \mathsf{P}
      \Rightarrow_I
      \hist \oplus_j \tup{e,\ewrt{\key,\val}},\vec{\gamma},\vec{\mathsf{B}}[j\mapsto \mathsf{B}], \mathsf{P}
    } 

    \inferrule[read-local]{
    \writeOp{\mathit{last}(\hist,j)}\mbox{ contains a }\wrt{\key}{\val}\mbox{ event}\\
    e\mbox{ fresh } \\
    \vec{\mathsf{B}}(j) = \xvar := \iread(\key);\mathsf{B}
    }{
      \hist,\vec{\gamma},\vec{\mathsf{B}}, \mathsf{P}
      \Rightarrow_I
      \hist \oplus_j \tup{e,\erd{\key}},\vec{\gamma}[(j,\xvar)\mapsto \val],\vec{\mathsf{B}}[j\mapsto \mathsf{B}],\mathsf{P}
    } 

    \inferrule[read-extern]{
    \writeOp{\mathit{last}(\hist,j)}\mbox{ does not contain a }\wrt{\key}{\val}\mbox{ event} \\
    e\mbox{ fresh }\\
    \vec{\mathsf{B}}(j) = \xvar := \iread(\key);\mathsf{B} \\
    \hist=(T,\so,\wro) \\
    \tr =\mathit{last}(\hist,j) \\
    \wrt{\key}{\val}\in\writeOp{\tr'}\mbox{ with $\tr'\in \transC{\hist}$ and $\tr\neq \tr'$} \\
    \hist' = (\hist \oplus_j \tup{e,\erd{\key}}) \oplus \wro(\tr',e) \\
    \hist' \mbox{ satisfies }I }{
      \hist,\vec{\gamma},\vec{\mathsf{B}}, \mathsf{P}
      \Rightarrow_I
      \hist',\vec{\gamma}[(j,\xvar)\mapsto \val],\vec{\mathsf{B}}[j\mapsto \mathsf{B}],\mathsf{P}
    } 

    \inferrule[commit]{e\mbox{ fresh} \quad 
    \vec{\mathsf{B}}(j) = \icommit 
    }{
      \hist,\vec{\gamma},\vec{\mathsf{B}}, \mathsf{P}
      \Rightarrow_I
      \hist \oplus_j \tup{e,\icommit},\vec{\gamma},\vec{\mathsf{B}}[j\mapsto \epsilon], \mathsf{P}
    } 
  \end{mathpar}
% \vspace{-5mm}
  \caption{An operational semantics for transactional programs. Above, $\mathit{last}(h,j)$ denotes the last transaction log in the session order $\so(j)$ of $h$, and $\transC{\hist}$ denotes the set of transaction logs in $\hist$ that are complete.}
  \label{fig:op:sem:baseline}
\end{figure}

We define a small-step operational semantics for transactional programs, which is parametrized by an isolation level $I$. The semantics keeps a history of previously executed database accesses in order to maintain consistency with $I$. 

For readability, we define a program as a partial function $\prog:\mathsf{SessId}\rightharpoonup \mathsf{Sess}$ that associates session identifiers in $\mathsf{SessId}$ with concrete code as defined in Figure~\ref{fig:syntax} (i.e., sequences of transactions). Similarly, the session order $\so$ in a history is defined as a partial function $\so:\mathsf{SessId}\rightharpoonup \mathsf{Tlogs}^*$ that associates session identifiers with sequences of transaction logs. Two transaction logs are ordered by $\so$ if one occurs before the other in some sequence $\so(j)$ with 
$j\in \mathsf{SessId}$.

Formally, the operational semantics is defined as a transition relation $\Rightarrow_I$ between \emph{configurations}, which are defined as tuples containing the following:
\begin{itemize}
	\item history $\hist$ storing the events generated by database accesses executed in the past, 
	\item a valuation map $\vec{\gamma}$ that records local variable values in the current transaction of each session ($\vec{\gamma}$ associates identifiers of sessions that have live transactions with valuations of local variables),
	\item a map $\vec{B}$ that stores the code of each live transaction (associating session identifiers with code), and
	\item sessions/transactions $\prog$ that remain to be executed from the original program.
\end{itemize}



Before presenting the definition of $\Rightarrow_I$, we introduce some notation. Let $\hist$ be a history that contains a representation of $\so$ as above. We use $\hist\oplus_j \tup{\tr,E,\po_t}$ to denote a history where $\tup{\tr,E,\po_t}$ is appended to $\so(j)$. 
Also, for an event $e$, $\hist\oplus_j e$ is the history obtained from $\hist$ by adding $e$ to the last transaction log in $\so(j)$ and as a last event in the program order of this log (i.e.,  if $\so(j)=\sigma; \tup{t,E,\po_t}$, then the session order $\so'$ of $\hist\oplus_j e$ is defined by $\so'(k)=\so(k)$ for all $k\neq j$ and $\so(j) =\sigma; \tup{t,E\cup\{e\},\po_t\cup \{(e',e): e'\in E\}}$). Finally, for a history $\hist = \tup{T, \so, \wro}$, $\hist\oplus\wro(\tr,e)$ is the history obtained from $\hist$ by adding $(\tr,e)$ to the write-read relation.

Figure~\ref{fig:op:sem:baseline} lists the rules defining $\Rightarrow_I$. %(the others can be defined in a similar manner). 
\textsc{spawn} starts a new transaction in a session $j$ provided that this session has no live transaction ($\vec{\mathsf{B}}(j) = \epsilon$). It adds a transaction log with a single $\ebegin$ event to the history and schedules the body of the transaction. \textsc{if-true} and \textsc{if-false} check the truth value of a Boolean condition of an $\mathtt{if}$ conditional. \textsc{local} models the execution of an assignment to a local variable which does not impact the stored history. \textsc{read-local} and \textsc{read-extern} concern read instructions. \textsc{read-local} handles the case where the read follows a write on the variable $x$ in the same transaction: the read returns the value written by the last write on $x$ in that transaction. Otherwise, \textsc{read-extern} corresponds to reading a value written in another transaction $\tr'$. The transaction $\tr'$ is chosen non-deterministically as long as extending the current history with the write-read dependency associated to this choice leads to a history that still satisfies $I$. \textsc{read-extern} applies only when the executing transaction contains no write on the same variable.

An \emph{initial} configuration for program $\prog$ contains the program $\prog$ along with a history $\hist=\tup{\{\tr_0\},\emptyset,\emptyset}$, where $\tr_0$ is a transaction log containing only writes that write the initial values of all variables, and empty current transaction code ($\mathsf{B}=\epsilon$). 
An execution of a program $\prog$ under an isolation level $I$ is a sequence of configurations $c_0 c_1\ldots c_n$ where $c_0$ is an initial configuration for $\prog$, and $c_m\Rightarrow_I c_{m+1}$, for every $0\leq m < n$. We say that $c_n$ is \emph{$I$-reachable} from $c_0$.
The history of such an execution is the history $\hist$ in the last configuration $c_n$. 
A configuration is called \emph{final} if it contains the empty program ($\prog=\emptyset$).
Let $\histOf[I]{\prog}$ denote the set of all histories of an execution of $\prog$ under $I$ that ends in a final configuration.

