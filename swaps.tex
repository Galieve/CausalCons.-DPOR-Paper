%!TEX root = main.tex
\subsection{Re-Ordering Events in Histories}
\label{subsection:SwappingHistories} %Provisional

After extending the current history with one more event, $\textsc{explore}$ may recurse on other histories obtained by re-ordering events in the current one (and dropping some other events).
%Besides sound and complete, we would also seek for an optimal algorithm, i.e. that avoids computing a history $h$ whose extensions are all inconsistent; also called a \textit{blocking} execution. If this is not achieved, our search would employ more resources such as time or memory than it actually needs for doing its purpose.

\begin{figure}[H]

	\centering
	\begin{subfigure}[b]{.25\textwidth}
		\begin{adjustbox}{max width=\textwidth}
	\begin{tabular}{c||c}
		\begin{lstlisting}[xleftmargin=5mm,basicstyle=\ttfamily\scriptsize,escapeinside={(*}{*)}, tabsize=1]
begin;
a = read((*x*));
b = read((*y*));
commit
		\end{lstlisting} &
		\begin{lstlisting}[xleftmargin=5mm,basicstyle=\ttfamily\scriptsize,escapeinside={(*}{*)}, tabsize=1]
begin;
write((*$x$*),2);
write((*$y$*),2);
commit
		\end{lstlisting} 
	\end{tabular} 
\end{adjustbox}
\vspace{1.2cm}
%		}
		\caption{Program.}
		\label{fig:dead_branch:prog}
	\end{subfigure}
\centering
	\begin{subfigure}[b]{.125\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				
				%\\ \multicolumn{1}{c}{ \ldots}
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3.25, 0) {\begin{tabular}{l} $\init$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_1$}] (t2) at (-3.25, -2) {\begin{tabular}{l} 
						$\rd{x}$ \\ $\rd{y}$
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_2$}] (t3) at (-3.25, -4) {\begin{tabular}{l} 
						$\wrt{x}{2}$\pgfsetfillopacity{0.3}\\
						$\wrt{y}{2}$
				\end{tabular}};			
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1x);
				\path (t1.south east) -- (t1.south) coordinate[pos=0.67] (t1y);
				\path (t2.north west) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t2.north east) -- (t2.north) coordinate[pos=0.67] (t2y);
				
				\path (t1.south) edge [left] node {$\wro$} (t2.north);

				%\path (t2) edge [right] node {$\wro_x$} (t3);
			\end{tikzpicture}  
			
		}
		\caption{Current.}
		\label{fig:dead_branch:a}
	\end{subfigure}
	\hspace{.175cm}
	\centering
	\begin{subfigure}[b]{.125\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3.25, 0) {\begin{tabular}{l} $\init$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_2$}] (t2) at (-3.25, -4) {\begin{tabular}{l} 
						$\rd{x}$ \pgfsetfillopacity{0.3}\\ $\rd{y}$
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_1$}] (t3) at (-3.25, -2) {\begin{tabular}{l} 
						$\wrt{x}{2}$\pgfsetfillopacity{0.3}\\
						$\wrt{y}{2}$
				\end{tabular}};			
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1x);
				\path (t2.north west) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t3.north west) -- (t3.west) coordinate[pos=0.67] (t3x);
				
				\path (t3.south) edge [left] node {$\wro_x$} (t2.north); %[yshift=8,xshift=0]
				%\path (t1x) edge [right] node {$\wro_y$} (t2x);
			\end{tikzpicture}  
			
		}
		\caption{Reorder.}
		\label{fig:dead_branch:b}
	\end{subfigure}
	\hspace{.175cm}
	\centering
		\begin{subfigure}[b]{.177\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3.25, 0) {\begin{tabular}{l} $\init$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_2$}] (t2) at (-3.25, -4) {\begin{tabular}{l} 
						$\rd{x}$ \\ $\rd{y}$
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_1$}] (t3) at (-3.25, -2) {\begin{tabular}{l} 
						$\wrt{x}{2}$\pgfsetfillopacity{0.3}\\
						$\wrt{y}{2}$
				\end{tabular}};			
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1x);
				\path (t2.north west) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t3.north west) -- (t3.west) coordinate[pos=0.67] (t3x);
				
				%\path (t3x) edge [above] node[yshift=8,xshift=0] {$\wro_x$} (t2.north east);
				\path (t3.south) edge [left] node {$\wro_x$} (t2.north);
				\path (t1.south west) edge [bend right] node[left] {$\wro_y$} (t2.north west);
			\end{tikzpicture}
		}
		\caption{Extended.}
		\label{fig:dead_branch:c}
	\end{subfigure}
	\hspace{.175cm}
	\centering
	\begin{subfigure}[b]{.177\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3.25, 0) {\begin{tabular}{l} $\init$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_2$}] (t2) at (-3.25, -4) {\begin{tabular}{l} 
						$\rd{x}$ \\ $\rd{y}$
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_1$}] (t3) at (-3.25, -2) {\begin{tabular}{l} 
						$\wrt{x}{2}$\\
						$\wrt{y}{2}$
				\end{tabular}};			
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1x);
				\path (t2.north west) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t3.north west) -- (t3.west) coordinate[pos=0.67] (t3x);
				
				%\path (t3x) edge [above] node[yshift=8,xshift=0] {$\wro_x$} (t2.north east);
				\path (t3.south) edge [left] node {$\wro_x$} (t2.north);
				\path (t1.south west) edge [bend right] node[left] {$\wro_y$} (t2.north west);
			\end{tikzpicture}
			
		}
		\caption{Inconsistent.}
		\label{fig:dead_branch:d}
	\end{subfigure}
	\caption{Example of inconsistency after swapping two events. All $\so$-edges from $\init$ to the other transactions are omitted for legibility. All transaction logs are history-ordered top to bottom according to their position in the figure. Events in gray are not yet added to the history. }
	\label{fig:dead_branch}
	%\vspace{-3mm}
\end{figure}

%Proceeding this way we can ensure that every complete history is not inconsistent, but we cannot yet ensure every incomplete consistent history lead to a complete and consistent one. Guaranteeing it would mean that every step done in the algorithm is meaningful; that any explored branch would lead to a dead end. 
%The process of re-ordering events must maintain the invariant that the algorithm explores histories with at most one pending transaction, 
Re-ordering events must preserve the invariant of producing histories with at most one pending transaction.
To explain the use of this invariant in avoiding fruitless explorations, let us consider the program in Figure~\ref{fig:dead_branch:prog} assuming an exploration under Read Committed. The oracle order gives priority to the transaction on the left.
Assume that the current history reached by the exploration is the one pictured in Figure~\ref{fig:dead_branch:a} (the last added event is $\wrt{x}{2}$). Swapping the $\wrt{x}{2}$ event with the $\rd{x}$ event would result in the history pictured in Figure~\ref{fig:dead_branch:b}. To ensure that this swap produces a new history which was not explored in the past, the $\wro_x$ dependency of $\rd{x}$ is changed towards the $\wrt{x}{2}$ transaction (we detail this later).
%$\RA$
%One example of this undesired behavior can be easily seen under RA memory model with the program depicted in Figure~\ref{fig:dead_branch}. Here we consider three transactions ordered from left to right, top to bottom, and we start with the history depicted in Figure~\ref{fig:dead_branch:a}. After executing the $\nextEvent$ event, the $\iwrite$ $w_x  \coloneqq \wrt{x}{2}$, 
%one possible action would be swapping $w_x$ with the event $a \gets \rd{x}$; obtaining the history $h_2$ portrayed in Figure~\ref{fig:dead_branch:b}. 
By the definition of $\nextEvent$ (and the oracle order), this history shall be extended with $\rd{y}$, and this read event will be associated by $\wro_y$ to the only available $\iwrite(y,\_)$ event. This is pictured in 
Figure~\ref{fig:dead_branch:c}. The next exploration step will extend the history with $\ewrt{x,2}$ (the only extension possible) which however, results in a history that does \emph{not} satisfy Read Committed, thereby, the recursive exploration branch being blocked.
%as there is only one $\iwrite(y,\_)$ event, the $\wro$ dependncy for this
%that writes $y$, $r_b$ must read from the very first transaction; as seen in Figure~\ref{fig:dead_branch:c}. However, when completing the third transaction we must inexorably admit that our history in Figure~\ref{fig:dead_branch:d} is inconsistent. Therefore, all the computation required to complete the unfinished transactions after the swap was in vain; we couldn't detect after computing $h_2$ the dead end.
% As $\nextEvent$ function always prioritize pending transactions
The core issue is related to the history in Figure \ref{fig:dead_branch:c} which has a pending transaction that is \emph{not} $(\so \cup \wro)^*$-maximal. Being able to extend such a transaction while maintaining consistency with the intended isolation level is not guaranteed by Read Committed (and any other isolation level we consider). Nevertheless, causal extensibility guarantees the existence of an extension for pending transactions that are $(\so \cup \wro)^*$-maximal. We enforce this requirement by restricting the explored histories to have at most one pending transaction. This pending transaction will necessarily by $(\so \cup \wro)^*$-maximal.

%
%Hence, for being always able to extend a history by invoking the model's causally-extensibility, we have to never produce pending transactions that are non $\so \cup \wro$-maximal. A simple solution is always executing histories in isolation, i.e. having exactly one pending transaction; thus, $\so \cup \wro$-maximal,  otherwise there would be a previous point where two pending transactions coexisted. To sum up, we are not going to swap just after executing a $\iwrite$ event but when its transaction is completed.

%TODO EXPLAIN THE DEFINITIONS BELOW

To enforce histories with at most one pending transaction, the function $\genericCompute$, which identifies events to reorder, has a non-empty return value only when the last added event is $\ecommit$ (the end of a transaction). Therefore, in such a case, it returns pairs of read and write events on the same variable, the write event coming from the last completed transaction, and such that the transactions containing the two events are not causally dependent (i.e., related by $[\so \cup \wro]^*$).

\begin{cframed}[pinegreen]
	\begin{equation*}
		\begin{array}{lcl}
			\genericCompute(h_<) & \coloneqq & \{(r,w) \in \Events \ | \ r < w \land r \in \readOp{t} \land w \in \writeOp{t}\\[1mm]
			&& \hspace{1.9cm} \land\ \variable{r} = \variable{w} \\ [1mm]
			&& \hspace{1.9cm} \land\ (\trans{h}{r},t)\not\in [\so \cup \wro]^*\land \mbox{$t$ is complete}   \} \\[1mm]
			&& \mbox{where $t$ is the transaction log of the last event in $<$}
		\end{array}
	\end{equation*}
\end{cframed}

\begin{figure}[H]
\centering
\begin{subfigure}[b]{.25\textwidth}
	\begin{adjustbox}{max width=\textwidth}
		\begin{tabular}{c||c}
			\begin{lstlisting}[xleftmargin=5mm,basicstyle=\ttfamily\scriptsize,escapeinside={(*}{*)}, tabsize=1]
begin;
a = read((*x*));
write((*$y$*),1)
commit
begin;
b = read((*x*));
commit		
			\end{lstlisting} &
			\begin{lstlisting}[xleftmargin=5mm,basicstyle=\ttfamily\scriptsize,escapeinside={(*}{*)}, tabsize=1]
begin;
write((*$y$*),3);
commit
begin;
write((*$x$*),4);
commit
			\end{lstlisting} 
		\end{tabular} 
	\end{adjustbox}
	
	
	\caption{Program.}
	\label{fig:compute-reordering:prog}
\end{subfigure} 
\hspace{.15cm}%\pgfsetfillopacity{0.3}\\
	\centering
	\begin{subfigure}[b]{.2\textwidth}
		\resizebox{.81\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				
				%\\ \multicolumn{1}{c}{ \ldots}
				\node[draw, rounded corners=2mm,outer sep=0] (t0) at (0, 0) {\begin{tabular}{l} $\init$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_1$}] (t1) at (0, -1.5) {\begin{tabular}{l} 
					$\rd{x}$ \\ $\wrt{y}{1}$ 
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_2$}] (t2) at (0, -3) {\begin{tabular}{l} 
					$\rd{x}$
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_3$}] (t3) at (0, -4.5) {\begin{tabular}{l} 
					$\wrt{y}{3}$
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_4$}] (t4) at (0, -6) {\begin{tabular}{l} 
					$\wrt{x}{4}$
				\end{tabular}};			
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1x);
				\path (t1.south east) -- (t1.south) coordinate[pos=0.67] (t1y);
				\path (t2.north west) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t2.north east) -- (t2.north) coordinate[pos=0.67] (t2y);
				
				\path (t1.south) edge [left] node {$\so$} (t2.north);
				\path (t3.south) edge [left] node {$\so$} (t4.north);
				\path (t0.south) edge [left] node {$\wro_x$} (t1.north);\\
				\path (t0.south east) edge [bend left] node[right] {$\wro_x$} (t2.north east);
				
				%\path (t2) edge [right] node {$\wro_x$} (t3);
			\end{tikzpicture}  
			
		}
		\caption{Current.}
		\label{fig:compute-reordering:a}
	\end{subfigure}
	\hspace{.15cm}
	\centering
	\begin{subfigure}[b]{.2\textwidth}

		\resizebox{.77\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t0) at (0, 0) {\begin{tabular}{l} $\init$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_1$}] (t1) at (0, -1.5) {\begin{tabular}{l} 
						$\rd{x}$ \\ $\wrt{y}{1}$ 
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_2$}] (t2) at (0, -6) {\begin{tabular}{l} 
						$\rd{x}$
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_3$}] (t3) at (0, -3) {\begin{tabular}{l} 
						$\wrt{y}{3}$
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_4$}] (t4) at (0, -4.5) {\begin{tabular}{l} 
						$\wrt{x}{4}$
				\end{tabular}};			
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1x);
				\path (t1.south east) -- (t1.south) coordinate[pos=0.67] (t1y);
				\path (t2.north west) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t2.north east) -- (t2.north) coordinate[pos=0.67] (t2y);
				
				\path (t1.south east) edge [bend left] node [left] {$\so$} (t2.north east);
				\path (t3.south) edge [left] node {$\so$} (t4.north);
				\path (t0.south) edge [left] node {$\wro_x$} (t1.north);\\
				\path (t4.south) edge [left] node{$\wro_x$} (t2.north);
				 %[yshift=8,xshift=0]
				%\path (t1x) edge [right] node {$\wro_y$} (t2x);
			\end{tikzpicture}  

		}
		
				\caption{Swap $t_2$ and $t_4$.}
	
		\label{fig:compute-reordering:b}
	\end{subfigure}
	\hspace{.15cm}
	\centering
	\begin{subfigure}[b]{.2\textwidth}
		\resizebox{.6\textwidth}{!}{
				\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t0) at (0, 0) {\begin{tabular}{l} $\init$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_1$}] (t1) at (0, -4.5) {\begin{tabular}{l} 
						$\rd{x}$ \\ \pgfsetfillopacity{0.3}$\wrt{y}{1}$ 
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, opacity=0.3, label={[font=\small]50:$t_2$}] (t2) at (0, -6) {\begin{tabular}{l} 
						$\rd{x}$
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_3$}] (t3) at (0, -1.5) {\begin{tabular}{l} 
						$\wrt{y}{3}$
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_4$}] (t4) at (0, -3) {\begin{tabular}{l} 
						$\wrt{x}{4}$
				\end{tabular}};			
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1x);
				\path (t1.south east) -- (t1.south) coordinate[pos=0.67] (t1y);
				\path (t2.north west) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t2.north east) -- (t2.north) coordinate[pos=0.67] (t2y);
				
				\path[opacity=0.3] (t1.south) edge [left] node [right] {$\so$} (t2.north);
				\path (t3.south) edge [left] node {$\so$} (t4.north);
				\path (t4.south) edge [left] node {$\wro_x$} (t1.north);\\
				%\path (t4.south) edge [left] node{$\wro_x$} (t2.north);
				%[yshift=8,xshift=0]
				%\path (t1x) edge [right] node {$\wro_y$} (t2x);
			\end{tikzpicture}  
			
		}
		\caption{Swap $t_1$ and $t_4$.}
		\label{fig:compute-reordering:c}
	\end{subfigure}
	\caption{Example of inconsistency after swapping two events. All $\so$-edges from $\init$ to the other transactions are omitted for legibility. All transaction logs are history-ordered top to bottom according to their position in the figure. Events in gray are not yet added to the history.}
	\label{fig:compute-reordering}
	%\vspace{-3mm}
\end{figure}

For example, given the program in Figure~\ref{fig:compute-reordering:prog} and history $h$ in Figure~\ref{fig:compute-reordering:b}, $\compute(h)$ would return $(r_1, t_4)$ and $(r_2, t_4)$ where $r_1$ and $r_2$ are the event $\rd{x}$ both belonging to $t_1$ and $t_2$ respectively.

Given a pair $(r,w)$, the function $\genericSwap$ produces a new history $\hist'$ which contains all events ordered before $r$ (w.r.t. $<$), the transaction that contains $w$ and all its $[\so \cup \wro]^*$ predecessors, and the event $r$ reading from $w$. Note that the $\po$ predecessors of $r$ from the same transaction are ordered before $r$ by $<$ and they will be also included in $\hist'$. More generally, the history $\hist'$ without $r$ is a prefix of the input history $\hist$. By definition, the only pending transaction in $\hist'$ is the one containing the read $r$. The order relation is updated by moving the transaction containing the read $r$ to be the last; it remains unchanged for the rest of the events.

\begin{cframed}[pinegreen]
	\begin{equation*}
		\begin{array}{lcl}
			\genericSwap(h_<, r, w, \locals) & \coloneqq &\big(h' = (h \setminus D) \oplus \wro(w,r), <'\big ), \locals', \text{ where} \\[1mm]
			&& \hspace{1cm}D = \{e \ | \ r < e \land (\trans{h}{e},\trans{h}{w})\not\in [\so \cup \wro]^*\} \\[1mm]
			&& \hspace{1cm}<' = \big( <\ \downarrow\ (\events{h'}\setminus \events{\trans{h'}{r}}) \big) \cdot \trans{h'}{r} \\[1mm]
			&& \hspace{1cm}\mbox{$\locals' = \locals \downarrow \events{h'}$.}
		\end{array}
	\end{equation*}
\end{cframed}

Above, $h \setminus D$ denotes the prefix of $\hist$ obtained by deleting all the events in $D$ from its transaction logs; a transaction log is removed all together if it becomes empty. Also, $\hist'' \oplus \wro(w,r)$ denotes an \emph{update} of the $\wro$ relation of $\hist''$ where any pair $(\_,r)$ is replaced by $(w,r)$. Finally, $<'' \cdot\ \trans{h'}{r}$ denotes an extension of the total order $<''$ obtained by appending the events in $\trans{h'}{r}$ according to program order.

Continuing with the example of Figure~\ref{fig:compute-reordering}, while swapping $t_1$ and $t_4$, every event in transaction $t_2$ and $\wrt{y}{1}$ in $t_1$ belong to $\{e \ | \ r < e \land (\trans{h}{e},\trans{h}{w})\not\in [\so \cup \wro]^*\}$, so it will not belong to the swapped history; as it can be seen in Figure~\ref{fig:compute-reordering:c}. If the other swap is done, no event but the commit in $t_2$ will be deleted (Figure~\ref{fig:compute-reordering:b}).

%Following algorithm \ref{algorithm:algo-class}'s schema, we define two functions $\compute, \swap$ that plays the role of $\genericCompute, \genericSwap$ respectively. In addition, for the history $h' = \swap(h, r, w)$ we declare the algorithm order of $h'$, $\leq_{h'}$ as $\leq_{h'} = \leq_{(h \setminus \tr(r) ) \restriction_{h'}} \cup \{\langle e, e' \rangle \ | \ e \in h' \setminus \tr(r), e' \in \tr(r)\} \cup \po_{\tr(r) \restriction_{h'}}$.
%
%\begin{cframed}[pinegreen]
%	\begin{equation*}
%		\begin{array}{ccc}
%			\compute(h) & \coloneqq & \{(r,w) \in h^2 \ | \ r <_h w \land \variable{r} = \variable{w} \land w \in \tr(\last{h}) \} \\
%			\swap(h, r, w) & \coloneqq & (h \setminus D) \bullet_w r \\
%			& \text{where} & D = \{e \ | \ r \leq_h e \land \lnot (\tr(e) \ [\so \cup \wro]^* \ \tr(w))\}
%		\end{array}
%	\end{equation*}
%\end{cframed}


\subsection{Avoiding Redundancy}

%Conversely, adding a $\iwrite$ $w$ is more complicated, multiple events may read this new event; specifically. the number of possible histories is exponential, $2^{|\iread(h)|}$. Moreover, after changing a $\wro$-edge from a $\iread$ $r$, we have no knowledge of the rest of the event's presence: some conditional instruction may be executed after $r$ and it may be meaningless talking about them. Thus, checking for every possible set of $\iread$ events if reading from $w$ leads to something consistent is no reasonable. Therefore, we have to define a criterion to determine whose sets of read events shall be analyzed. One hand, the history $h \bullet w$ where no $\iread$ reads from $w$ has to be explored, with an algorithm order defined in an analogously as for any other aforementioned history. On the other hand, we select one $\iread$ $r$ that will be the first event in $h$ reading from $w$ while the ones that follow $r$ will have to be re-executed. As $r$ had already been executed, what at the end we produce is a swap between the relative orders of $r$ and $w$; so $r$ would be thereinafter called \textit{swapped}.

%As in a more formal way definition \ref{def:swapped} states, this read $r$ would be thereinafter called \textit{swapped}

%Moreover, after changing a $\wro$-edge, we have no knowledge of the rest of the event's presence: some conditional instruction may be executed after that $\iread$ and it may be meaningless talking about the rest of the events. Moreover, by the prefix-closedness of our model, an inconsistent history only leads to inconsistent ones; so there is no reasonable reason for exploring those. Thus, instead of generating every single one of them and check afterwards if they are consistent, we prefer to generate a small subset and only extends those ones that are consistent; by the prefix-closedness of our model, an inconsistent history only leads to inconsistent ones. %Therefore, we can detect inconsistencies early on.

%Our protocol is defined as follows: we will select one $\iread$ event that will be the first event in $h$ reading from $w$ while the ones that proceed $r$ will be marked as postponed; they will have to be re-executed. As in a more formal way definition \ref{def:swapped} states, This read $r$ would be thereinafter called \textit{swapped}:

%, and we will enforce the following properties: no event before $r$ will read from $w$, $r$ reads from $w$, every read after $r$ may or may not read from $w$. 



While extending histories according to $\genericNext$ and recursing on re-ordered histories whenever possible (taking $\genericProtocol$ as $\mathit{true}$) guarantees soundness and completeness, it does not guarantee optimality. There are two sources of redundancy in this trivial algorithm: (1) re-ordering the same read multiple times, and (2) applying $\genericSwap$ on different histories may give the same result.

\begin{figure}[h]
	
\begin{subfigure}[b]{.3\textwidth}
\begin{adjustbox}{max width=\textwidth}
\begin{tabular}{c||c}
	\begin{lstlisting}[xleftmargin=5mm,basicstyle=\ttfamily\scriptsize,escapeinside={(*}{*)}, tabsize=1]
begin;
a=read((*$x$*));
commit
	\end{lstlisting} &
	\begin{lstlisting}[xleftmargin=5mm,basicstyle=\ttfamily\scriptsize,escapeinside={(*}{*)}, tabsize=1]
begin;
b=read((*$y$*));
commit
	\end{lstlisting} 

\\
\multicolumn{1}{c}{} & \multicolumn{1}{c}{}
\\
	\begin{lstlisting}[xleftmargin=5mm,basicstyle=\ttfamily\scriptsize,escapeinside={(*}{*)}, tabsize=1]
begin;
write((*$y$*),3);
commit
	\end{lstlisting} &
	\begin{lstlisting}[xleftmargin=5mm,basicstyle=\ttfamily\scriptsize,escapeinside={(*}{*)}, tabsize=1]
begin;
write((*$x$*),4);
commit
	\end{lstlisting}
\end{tabular} 
\end{adjustbox}

\caption{Program.}
\label{fig:redundant_Swap:prog}
\end{subfigure}
	\centering
	\begin{subfigure}[b]{.21\textwidth}
		\resizebox{.6\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t0) at (-3, 0) {\begin{tabular}{l} $\init$ \end{tabular}};
				
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_1$}] (t1) at (-3, -1.5) {\begin{tabular}{l} $\rd{x}$\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_2$}] (t2) at (-3, -3) {\begin{tabular}{l} $\rd{y}$  \end{tabular}};
				
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_3$}] (t3) at (-3, -4.5) {\begin{tabular}{l} $\wrt{y}{3}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_4$}] (t4) at (-3, -6) {\begin{tabular}{l} $\wrt{x}{4}$ \end{tabular}};
				
				%\path (t0.south west) edge[above, bend right] node[left] {$\wro$} (t3.north west);
				\path (t0.south west) edge[above, bend right] node[left] {$\wro$} (t2.north west);
				\path (t0.south) edge node[left] {$\wro$} (t1.north);
				%\path (t0.south east) edge[above, bend left] node[left] {$\wro$} (t4.north east);
			\end{tikzpicture}  
		}
		\caption{Current history.}
		\label{fig:redundant_swap:a}
	\end{subfigure}
	\hspace{.25cm}
	\centering
	\begin{subfigure}[b]{.21\textwidth}
		\resizebox{.63\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t0) at (-3, 0) {\begin{tabular}{l} $\init$ \end{tabular}};
				
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_1$}] (t1) at (-3, -1.5) {\begin{tabular}{l} $\rd{x}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_2$}] (t2) at (-3, -4.5) {\begin{tabular}{l} $\rd{y}$ \end{tabular}};
				
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_3$}] (t3) at (-3, -3) {\begin{tabular}{l} $\wrt{y}{3}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_4$}] (t4) at (-3, -6) {\begin{tabular}{l} $\wrt{x}{4}$ \end{tabular}};
				
				\path (t0.south west) edge[above, bend right] node[left] {$\wro$} (t3.north west);
				\path (t3.south) edge node[left] {$\wro$} (t2.north);
				\path (t0.south) edge node[left] {$\wro$} (t1.north);
				%\path (t0.south east) edge[above, bend left] node[left] {$\wro$} (t4.north east);
			\end{tikzpicture}  
		}
		
		\caption{Swap $t_2$ and $t_3$.}
		\label{fig:redundant_swap:b}
	\end{subfigure}
	\hspace{.25cm}
	\centering
	\begin{subfigure}[b]{.21\textwidth}
		\resizebox{.65\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t0) at (-3, 0) {\begin{tabular}{l} $\init$ \end{tabular}};
				
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_1$}] (t1) at (-3, -3) {\begin{tabular}{l} $\rd{x}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_2$}] (t2) at (-3, -4.5) {\begin{tabular}{l} $\rd{y}$ \end{tabular}};
				
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_3$}] (t3) at (-3, -6) {\begin{tabular}{l} $\wrt{y}{3}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_4$}] (t4) at (-3, -1.5) {\begin{tabular}{l} $\wrt{x}{4}$ \end{tabular}};
				
				%\path (t0.south west) edge[above, bend right] node[left] {$\wro$} (t3.north west);
				\path (t0.south west) edge[above, bend right] node[left] {$\wro$} (t2.north west);
				\path (t4.south) edge node[left] {$\wro$} (t1.north);
				%\path (t0.south) edge node[left] {$\wro$} (t4.north);
			\end{tikzpicture}  
		}
		
		\caption{Swap $t_1$ and $t_4$.}
		\label{fig:redundant_swap:c}
	\end{subfigure}\hspace{.5cm}
	\caption{Two possible computable histories starting from a current one. The four transactions belong each one to a different independent thread.}
	\label{fig:redundant_swap}
	%\vspace{-3mm}
\end{figure}

For example, under the program depicted in Figure~\ref{fig:redundant_Swap:prog} with four independent threads, the algorithm may compute the history $h_1$ pictured in figure \ref{fig:redundant_swap:a}. Therefore, two different histories will also be computed via swapping two transactions: $h_2$ if we swap $t_2$ and $t_3$  (Figure~\ref{fig:redundant_swap:b}) and $h_3$ if we swap $t_1$ and $t_4$ (Figure~\ref{fig:redundant_swap:c}). However, from $h_2$ we can also swap $t_1$ and $t_4$ to produce a history that can be extended to $h_3$; obtaining twice the same history.


%TODO GIVE AN EXAMPLE FOR THE 1ST ISSUE. JUSTIFYING THE SWAPPED CONDITION. 

\begin{figure}[h]
	\begin{subfigure}[b]{.22\textwidth}
		\begin{adjustbox}{max width=\textwidth}
			\begin{tabular}{c||c}
				\begin{lstlisting}[xleftmargin=5mm,basicstyle=\ttfamily\scriptsize,escapeinside={(*}{*)}, tabsize=1]

begin;
write((*$x$*),2);
commit
				\end{lstlisting} &
				\begin{lstlisting}[xleftmargin=5mm,basicstyle=\ttfamily\scriptsize,escapeinside={(*}{*)}, tabsize=1]
begin;
a=read((*$x$*));
commit
				\end{lstlisting} 
				
				\\
				\multicolumn{1}{c}{} & \multicolumn{1}{c}{}
				\\
				\begin{lstlisting}[xleftmargin=5mm,basicstyle=\ttfamily\scriptsize,escapeinside={(*}{*)}, tabsize=1]
begin;
b=read((*$x$*));
commit
	\end{lstlisting} &
				\begin{lstlisting}[xleftmargin=5mm,basicstyle=\ttfamily\scriptsize,escapeinside={(*}{*)}, tabsize=1]
begin;
write((*$x$*),4);
commit
				\end{lstlisting}
			\end{tabular} 
		\end{adjustbox}
		
		\caption{Program.\\ $ $}
		\label{fig:non-optimality:prog}
	\end{subfigure}
	\centering
	\begin{subfigure}[b]{.15\textwidth}
		\resizebox{.95\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3, 0) {\begin{tabular}{l} $\init$ \end{tabular}};
				
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_1$}] (t2) at (-3, -1.5) {\begin{tabular}{l} $\wrt{x}{2}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_2$}] (t3) at (-3, -3) {\begin{tabular}{l} $\rd{x}$ \end{tabular}};
				
				\node[draw, rounded corners=2mm,outer sep=0, opacity=0.3, label={[font=\small]50:$t_3$}] (t4) at (-3, -4.5) {\begin{tabular}{l} $\rd{x}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, opacity=0.3, label={[font=\small]50:$t_4$}] (t5) at (-3, -6) {\begin{tabular}{l} $\wrt{x}{2}$ \end{tabular}};
				
				\path (t1.south west) edge[above, bend right] node[left] {$\wro$} (t3.north west);
				%\path (-4.5,-3.75) edge[-,dashed] (-1,-3.75);
			\end{tikzpicture}  
			
		}
		\caption{Before reading.}
		\label{fig:non_optimality:a}
	\end{subfigure}
	\hspace{.15cm}
	\centering	
	\begin{subfigure}[b]{.15\textwidth}
		\resizebox{1.24\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3, 0) {\begin{tabular}{l} $\init$ \end{tabular}};
				
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_1$}] (t2) at (-3, -1.5) {\begin{tabular}{l} $\wrt{x}{2}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_2$}] (t3) at (-3, -3) {\begin{tabular}{l} $\rd{x}$ \end{tabular}};
				
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_3$}] (t4) at (-3, -4.5) {\begin{tabular}{l} $\rd{x}$ \end{tabular}};
				
				\node[draw, rounded corners=2mm, opacity=0.3, label={[font=\small]50:$t_4$}] (t5) at (-3, -6) {\begin{tabular}{l} $\wrt{x}{4}$ \end{tabular}};
				
				%\path (t3) edge node {$\so$} (t5);
				%\path (t3) edge node {$\po$} (t3);
				%\path (t1) edge[below] node[yshift=-4,xshift=-4] {$\wro$} (t3_2);
				%\path (t2) edge[below] node[yshift=-4,xshift=4] {$\wro$} (t4_2);
%				\path (t1) edge[above] node[yshift=0,xshift=0] {$\wro$} (t3);
%				\path (t1) edge[below] node[yshift=-2,xshift=-2] {$\wro$} (t4);
				\path (t1.south west) edge[above, bend right] node[left] {$\wro$} (t3.north west);
				\path (t1.south east) edge[below, bend left] node[right] {$\wro$} (t4.north east);
				%\path (-4.5,-5.25) edge[-,dashed] (-1,-5.25);
			\end{tikzpicture}  
			
		}
		\caption{$t_3$ reads from $\init$.}
		\label{fig:non_optimality:b}
	\end{subfigure}
	\hspace{.15cm}
	\centering
	\begin{subfigure}[b]{.15\textwidth}
		\resizebox{1.24\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3, 0) {\begin{tabular}{l} $\init$ \end{tabular}};
				
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_1$}] (t2) at (-3, -1.5) {\begin{tabular}{l} $\wrt{x}{2}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_2$}] (t3) at (-3, -3) {\begin{tabular}{l} $\rd{x}$ \end{tabular}};
				
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_3$}] (t4) at (-3, -4.5) {\begin{tabular}{l} $\rd{x}$ \end{tabular}};
				
				\node[draw, rounded corners=2mm, opacity=0.3, label={[font=\small]50:$t_4$}] (t5) at (-3, -6) {\begin{tabular}{l} $\wrt{x}{4}$ \end{tabular}};
				
				
				\path (t1.south west) edge[above, bend right] node[left] {$\wro$} (t3.north west);
				\path (t2.south east) edge[below, bend left] node[right] {$\wro$} (t4.north east);
				%\path (-4.5,-5.25) edge[-,dashed] (-1,-5.25);
			\end{tikzpicture}  
			
		}
		\caption{$t_3$ reads from $t_2$.}
		\label{fig:non_optimality:c}
	\end{subfigure}
	\hspace{.15cm}
	\centering
	\begin{subfigure}[b]{.15\textwidth}
		\resizebox{.75\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3, 0) {\begin{tabular}{l} $\init$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_1$}] (t2) at (-3, -1.5) {\begin{tabular}{l} $\wrt{x}{2}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_2$}] (t3) at (-3, -4.5) {\begin{tabular}{l} $\rd{x}$ \end{tabular}};
				
				\node[draw, rounded corners=2mm,outer sep=0, opacity=0.3, label={[font=\small]50:$t_3$}] (t4) at (-3, -6) {\begin{tabular}{l} $\rd{x}$ \end{tabular}};
				
				\node[draw, rounded corners=2mm, label={[font=\small]50:$t_4$}] (t5) at (-3, -3) {\begin{tabular}{l} $\wrt{x}{4}$ \end{tabular}};				
				
				\path (t5) edge[left] node {$\wro$} (t3);
				
			\end{tikzpicture}  
			
		}
		\caption{After swap.\\$ $}
		\label{fig:non_optimality:d}
	\end{subfigure}
	
	\caption{Re-ordering events versus optimality. We assume an oracle order orders transaction from left to right, top to bottom in the program. All transaction logs are history-ordered top to bottom according to their position in the figure. Events in gray are not yet added to the history.}
	\label{fig:non_optimality}	
\end{figure}

Without further restrictions on swaps, it is also possible that different branches of the recursion lead to the same history, thereby, violating optimality. As an example, consider a program with 2 transactions that only read some variable $x$ and 2 transactions that only write on $x$. Assume that $\textsc{explore}$ reaches the ordered history pictured in Figure~\ref{fig:non_optimality:a} and $\genericNext$ is about to return the second reading transaction. $\textsc{explore}$ will recurse on the two histories pictured in Figure~\ref{fig:non_optimality:b} and Figure~\ref{fig:non_optimality:c} that differ in the write that this last read is reading from (either the initial write or the first write transaction). On both branches of the recursion, $\genericNext$ will extend the history with the last write transaction. For both histories, swapping this last write with the first read on $x$ will result in the history pictured in Figure~\ref{fig:non_optimality:d} (cf. the definition of $\genericCompute$ and $\genericSwap$). Therefore, both branches of the recursion will continue extending the same history and optimality is violated. The source of non-optimality is related to $\wro$ dependencies that are \emph{removed} when computing the result of $\genericSwap$. The histories in Figure~\ref{fig:non_optimality:b} and Figure~\ref{fig:non_optimality:c} were different because of the $\wro$ dependency involving the last read, but this difference was discarded during the computation of $\genericSwap$. Therefore, we will restrict the application of $\genericSwap$ on histories where the discarded $\wro$ dependencies relate to some ``fixed'' set of writes, i.e., latest writes (w.r.t. <) that are valid, i.e., preserve consistency with the intended isolation level (see the definition of $\isMaximallyAdded{\_}{\_}$ below), e.g., when the second read reads from $\ewrt{x,2}$.

%Let's suppose we have a program $\mathcal{P}$ as depicted in figure \ref{fig:non_optimality}, assuming $\leq_{\ora}$ order transactions as presented from left to right, top to bottom. Then, the algorithm computes histories \ref{fig:non_optimality:a}, $h$, and \ref{fig:non_optimality:b}, $h'$. After adding $T_4$ in both $h,h'$ we can produce a swap between $r_a \coloneqq a \gets \rd{x}$ and $w_4 \coloneqq \wrt{x}{4}$; deleting the event $r_b \coloneqq b \gets \rd{x}$ as $\lnot(\tr(r_b) \ [\wro \cup \so]^+ \ \tr(w_4)) $. Therefore, after the swap in both cases we arrive to the history depicted in Figure~\ref{fig:non_optimality:c}; obtaining a non-optimal situation. 

%In conclusion, we cannot swap transactions without any restriction. As the example in figure \ref{fig:non_optimality} shows, the key of redundancy lies in every $\wro$ edge that is going to be modified or erased: if two histories only differ on those, the resultant history is the same.

The $\genericProtocol$ condition, which restricts re-orderings, requires that every read that will be deleted by $\genericSwap$ or the re-ordered read $r$ (whose $\wro$ dependency will be modified) is not already swapped and it reads from a latest valid write ($D$ has the same definition as in $\genericSwap$):
\begin{cframed}[pinegreen]
	\begin{equation*}
		\begin{array}{l}
			\genericProtocol(h_<, r, w) \coloneqq 
%			\begin{array}{l}
%				\forall r'\in \readOp{h}. \ (r,r')\in \po^* \implies \lnot \swapped{h_<}{r'}\\[1mm]
%				\land\ 
				\forall r'\in \readOp{h}\cap (D\cup\{r\}). \lnot \swapped{h_<}{r'}\land \isMaximallyAdded{h_<}{r'} \\[2mm]
%			\end{array} \\[4mm]
%			\hspace{2cm}\text{where }  D = \{e \ | \ r < e \land (\trans{h}{e},\trans{h}{w})\not\in [\so \cup \wro]^*\} %  \\ \multicolumn{3}{c}{
 		\end{array}
	\end{equation*}
\end{cframed}

We say that a read $r$ is \emph{swapped} in $\hist_<$ when (1) it reads from a write $w$ that is a successor in the oracle order (the write was added by $\genericNext$ after the read), which is now a predecessor\footnote{The $\textsc{explore}$ maintains the invariant that every read follows the write it reads from in the history order $<$.} in the history order $<$ (2) there is no transaction $t$ that is before $r$ in both the oracle order $<_{\ora}$ and the history order $<$, and which is a $[\so \cup \wro]^+$ successor of $w$'s transaction, and (3) $r$ is the first read in its transaction to read from $w$. Formally, 
% of $r$ is the first in oracle order to be after transaction containing $w$ in $[\so \cup \wro]^+$, and 
%\begin{definition}
%	A $\iread$ event $r$ is \callout{swapped} if the following conditions hold:
%	\begin{itemize}
%		\item For $w= h.\wro(r)$, $w <_h r$ and $w >_{\ora} r$.
%		\item $\tr(r)$ is the first transaction that depends on $\tr(w)$: $\nexists T <_{\ora} \tr(r)$ s $T <_h \tr(r)$ and $\tr(w) \ [\so \cup \wro]^+ \ T$. %\textcolor{red}{Note: I changed $T \neq \tr(r)$ to $T <_{\ora} \tr(r)$ for the proof as by $\ora$-respectfulness (defined in proof's section), we obtain both are equivalent.}
%		\item $r$ is the first $\iread$ event that reads from $\tr(w)$: $\nexists r'\in \tr(r), r' \leq_{\ora} r$ such that $\tr(h.\wro(r')) = \tr(w)$
%	\end{itemize}
%	\label{def:swapped}
%\end{definition}

\begin{cframed}[pinegreen]
	\begin{equation*}
		\begin{array}{lcl}
			\swapped{h_<}{r} & \coloneqq & 
			\begin{array}{c}
				w < r \land w >_{\ora} r \\
				\land \\
				\forall e \in h. \trans{h}{e} <_{\ora} \trans{h}{r} \implies (r < e  \lor (\trans{h}{w},\trans{h}{e})\not\in [\so \cup \wro]^+) \\
				\land \\
				\forall r' \in \readOp{h}.\ (\trans{h}{w},r')\in\wro \implies (r',r)\not\in \po  %\trans{h}{w'} \neq \trans{h}{w}
			\end{array} \\[11mm]
			&&\mbox{where $w$ is the write event such that $(w,r)\in\wro$}
		\end{array}
	\end{equation*}
\end{cframed}

A read $r$ reads from a latest valid write, denoted as $\isMaximallyAdded{h_<}{r}$, if reading from any other later write w.r.t. $<$ violates the isolation level $I$. Formally,

\begin{cframed}[pinegreen]
	\begin{equation*}
		\begin{array}{lcl}
			%\exists x \in \mathcal{V}, \exists w \in \writeOp{h} \text{ s.t. } 
			\isMaximallyAdded{h_<}{r} & \coloneqq &  
			\begin{array}{c}
%				\lnot \swapped{h}{r} \land 	\isConsistent{h}\\
%				\land \\
				%\forall r'\in \readOp{h}.\ \ (r,r')\in\po^* \implies 
%				\lnot \swapped{h_<}{r}\\
%				\land \\
				\forall w' \in \writeOp{h}.\ \ w < w' < r \implies 
				(h \setminus \{e \ | \ r < e\}) \oplus \wro(w',r)\not\models I)
%				\text{where } D = \{e \ | \ r \leq_h e\}
				%\left(\text{where } %h' = h \land 
				%\left\{\begin{array}{cc}
				%	h'.\wro(e') = h.\wro(e') & \text{if } e' \neq e \\ 
				%	h'.\wro(e) = w & \text{otherwise} \\ 
				%\end{array}\right\}\right)
			\end{array} \\[2mm]
			&&\mbox{where $w$ is the write event such that $(w,r)\in\wro$}
		\end{array}
	\end{equation*}
\end{cframed}
%Intuitively, definition~\ref{def:max_added} allow us to detect when a $\iread$ event $r$ reads from some \textit{default} value, the last $\iwrite$ $w$ event writing $x$ that was added before $r$ and such that the resultant history is consistent. In general, the source of non-optimality comes from the existence of histories differing in some $\wro$-edge involving a transaction that will be deleted. Therefore, we can stablish a simple criterion for guaranteeing optimality: a swap between two events can only happen when every event that have to be re-executed is maximally added. This criterion is defined as function $\protocol$ and it will play the role of $\genericProtocol$ function in our algorithm \ref{algorithm:algo-class}'s instance.

%\begin{figure}[H]
%	
%	\centering
%	\begin{subfigure}[b]{.3\textwidth}
%		\resizebox{\textwidth}{!}{
%			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
%				semithick, transform shape]
%				
%				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \\ $a \gets \rd{x}$ \end{tabular}};
%				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3, -1.75) {\begin{tabular}{l} $b \gets \rd{x}$\end{tabular}};
%				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {\begin{tabular}{l} $\wrt{x}{2}$ \\ $\wrt{y}{2}$\end{tabular}};
%				\node[draw, rounded corners=2mm, outer sep=0] (t4) at (3, -0) {
%					\begin{tabular}{l} 
%						$c \gets \rd{x}$ \\
%						{\pgfsetfillopacity{0.3}$\wrt{x}{3}$}
%				\end{tabular}};
%				\node[draw, rounded corners=2mm, opacity=0.3] (t5) at (3, -1.75) {\begin{tabular}{l} $\wrt{y}{4}$ \end{tabular}};
%				\path[opacity=0.3] (t4) edge node[opacity=0.3] {$\so$} (t5);
%				
%				
%				\path (t3.south east) -- (t3.east) coordinate[pos=0.67] (t3x);
%				\path (t4.south west) -- (t4.west) coordinate[pos=0.67] (t4x);
%				\path (t3x) edge[above] node[yshift=0,xshift=0] {$\wro_x$} (t4x);
%				
%				\path (t1.north west) -- (t1.north) coordinate[pos=0.5] (t1a);
%				\path (t1.west) edge [out=140, in=120, looseness=2.25] (t1a);
%				%[out=100,in=120,looseness=5] bend left=50, 
%				
%				\node[above left =0.125 and 0.05 of t1.north](t1alab) {$\wro_x$};
%				\path (t1) edge [left] node {$\wro_x$} (t2);
%			\end{tikzpicture}  
%			
%		}
%		\caption{Current history.}
%		\label{fig:add_write:a}
%	\end{subfigure}
%	\hspace{.5cm}
%	\centering
%	\begin{subfigure}[b]{.3\textwidth}
%		\resizebox{\textwidth}{!}{
%			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
%				semithick, transform shape]
%				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \\ $a \gets \rd{x}$ \end{tabular}};
%				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3, -1.75) {\begin{tabular}{l} $b \gets \rd{x}$\end{tabular}};
%				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {\begin{tabular}{l} $\wrt{x}{2}$ \\ $\wrt{y}{2}$\end{tabular}};
%				\node[draw, rounded corners=2mm, outer sep=0] (t4) at (3, -0) {
%					\begin{tabular}{l} 
%						$c \gets \rd{x}$ \\
%						$\wrt{x}{3}$
%				\end{tabular}};
%				\node[draw, rounded corners=2mm, opacity=0.3] (t5) at (3, -1.75) {\begin{tabular}{l} $\wrt{y}{4}$ \end{tabular}};
%				\path[opacity=0.3] (t4) edge node[opacity=0.3] {$\so$} (t5);
%				
%				
%				\path (t3.south east) -- (t3.east) coordinate[pos=0.67] (t3x);
%				\path (t4.south west) -- (t4.west) coordinate[pos=0.67] (t4x);
%				\path (t3x) edge[above] node[yshift=0,xshift=0] {$\wro_x$} (t4x);
%				
%				\path (t4.south west) edge [bend left=15] node[above] {$\wro_x$} (t2.east);
%				
%				\path (t1.north west) -- (t1.north) coordinate[pos=0.5] (t1a);
%				\path (t1.west) edge [out=140, in=120, looseness=2.25] (t1a);
%				%[out=100,in=120,looseness=5] bend left=50, 
%				
%				\node[above left =0.125 and 0.05 of t1.north](t1alab) {$\wro_x$};
%				
%			\end{tikzpicture}  
%			
%		}
%		\caption{One possible swap.}
%		\label{fig:add_write:b}
%	\end{subfigure}
%	\hspace{.5cm}
%	\centering
%	\begin{subfigure}[b]{.29\textwidth}
%		\resizebox{\textwidth}{!}{
%			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
%				semithick, transform shape]
%				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \\ $a \gets \rd{x}$ \end{tabular}};
%				\node[draw, rounded corners=2mm,outer sep=0, opacity=0.3] (t2) at (-3, -1.75) {\begin{tabular}{l} $b \gets \rd{x}$\end{tabular}};
%				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {\begin{tabular}{l} $\wrt{x}{2}$ \\ $\wrt{y}{2}$\end{tabular}};
%				\node[draw, rounded corners=2mm, outer sep=0] (t4) at (3, -0) {
%					\begin{tabular}{l} 
%						$c \gets \rd{x}$ \\
%						$\wrt{x}{3}$
%				\end{tabular}};
%				\node[draw, rounded corners=2mm, opacity=0.3] (t5) at (3, -1.75) {\begin{tabular}{l} $\wrt{y}{4}$ \end{tabular}};
%				\path[opacity=0.3] (t4) edge node[opacity=0.3] {$\so$} (t5);
%				
%				
%				\path (t3.south east) -- (t3.east) coordinate[pos=0.67] (t3x);
%				\path (t4.south west) -- (t4.west) coordinate[pos=0.67] (t4x);
%				\path (t3x) edge[above] node[yshift=0,xshift=0] {$\wro_x$} (t4x);
%				
%				\path (t4.north west) edge [bend right=15] node[above] {$\wro_x$} (t1.north east);
%				
%			\end{tikzpicture}  
%			
%		}
%		\caption{Another possible swap.}
%		\label{fig:add_write:c}
%	\end{subfigure}
%	\caption{Extensions of a history by adding a $\iwrite$ event.}
%	\label{fig:add_write}
%	%\vspace{-3mm}
%\end{figure}
%
%%\textcolor{red}{Talk about this example, explain why t2 disappears in 4.3}
%
%Let us show with an example the power of swapping. Here, in Figure~\ref{fig:add_write:a} we can see an incomplete history whose $\nextEvent$ event, $w \coloneqq \wrt{x}{3}$, is a $\iwrite$ event. There are four possible histories, depending if the first and second $\iread$ events, $r_a \coloneqq a \gets \rd{x} $ and $r_b \coloneqq b \gets \rd{x}$, read or not from $w$ (as $c \gets \rd{x}$ will never be able to read from $w$). In Figure~\ref{fig:add_write:b} we can see the history $h_b$ where only $r_b$ reads from $w$. As $r_a <_h r_b$, we simply state that $w \ [\wro] \ r_b$ in $h_b$. The other two cases that modify the write-read relation are due to the edge $w \ [\wro] \ r_a$; their common root. Therefore, we can construct the history $h_c$ depicted in Figure~\ref{fig:add_write:c}, mark $r_b$ as no executed to later on re-execute it and decide, in a later moment, if $w \ [\wro] \ r_b$ or not. In even in this small case we can realize that if $h_c$ would be inconsistent, we would already reduce the number of explored histories by one; its extensions would also be inconsistent. %we can delete $r_b$ for re-executing it later as depicted in Figure~\ref{fig:add_write:c} and by the rules described above, we know that two histories, one where $r_a$ reads from $w$ and another where it does not will be generated. 
%
%In a more general context, when swapping two events $r$ and $w$, we will delete all those events $e$ that are between $r$ and $w$ in the history-order such that $\tr(w)$ does not depends on. Otherwise, deleting some event $e$ such that $\tr(e) \ [\so \cup \wro]^* \ \tr(w)$ holds will produce a history where either some $\iread$ is reading from a deleted $\iwrite$ or some event would be executed before its $\so$-predecessor; both impossible situations in real life.




%The name ``swapping'' $w$ and $r$ refers to the change of relative order between those two events; $r <_{\ora} w$ but in the new history their order is reversed: $w <_h r$. Moreover, every event $e$ after $r$ that does not unlock $w$ (i.e. the condition $\tr(e) \ [\so \cup \wro]^+ \ \tr(w) $ does not hold) will be not taking into account to check this consistency. The reason for this is simple: if we want to compute every possible history, we may need to restate where some read-events read from, and we achieve this by re-executing them. To avoid redundancies, only those that $\tr(w)$ not depend on should being able to be re-executed.

%\begin{comment}
%\begin{algorithm}[H]
%\caption{\textsc{STMC}$_0$}
%\begin{algorithmic}[1]
%\InputAlgorithmic $h$: history.
%\If{ $\lnot \ \textsc{IsConsistent}_{\mathcal{M}}(h)$} \Return
%\ElsIf{$\textsc{IsComplete}(h)$}
%\State $\textsc{processHistory}(h)$
%\Else
%\State $a \gets  \nextEvent(h)$; $\; x \gets a.var()$
%\Switch{$a.type()$}
%\Case{$\ibegin$}
%\Comment{$\ibegin$ and $\iend$ cases coincide.}
%\EndCase
%\Case{$\iend$}
%\State $\textsc{STMC}_0(h \bullet a)$
%\Break
%\EndCase
%\Case{$\iread$}
%\ForAll{$w \in h \text{ s.t. } \writeVar{w}{x}$}
%\State $h' \gets h \bullet a$; $\; h'.\wro[a] \gets w$
%\State $\textsc{STMC}_0(h')$
%\EndFor
%\Break
%\EndCase
%\Case{$\iwrite$}
%\State $\textsc{STMC}_0(h \bullet a)$
%\ForAll{$r \in h \text{ s.t. } \readVar{r}{x}$}
%\State $D \gets \{e \ | \ r <_h e \land \lnot (\tr(e) \ [\so \cup \wro]^* \ \tr(a))\}$
%\State $h' \gets (h \setminus D) \bullet a$; $\; h'.\wro[r] \gets a$
%\State $\textsc{STMC}_0(h')$
%\EndFor
%\Break
%\EndCase
%\EndSwitch
%\EndIf
%
%\end{algorithmic}
%\label{algorithm:stmc0}
%\end{algorithm}
%\end{comment}


