%!TEX root = main.tex
\subsection{Re-Ordering Events in Histories}
\label{subsection:SwappingHistories} %Provisional

After extending the current history with one more event, $\textsc{explore}$ may recurse on other histories obtained by re-ordering events in the current one (and dropping some other events).
%Besides sound and complete, we would also seek for an optimal algorithm, i.e. that avoids computing a history $h$ whose extensions are all inconsistent; also called a \textit{blocking} execution. If this is not achieved, our search would employ more resources such as time or memory than it actually needs for doing its purpose.

\begin{figure}[H]

	\centering
	\begin{subfigure}[b]{.28\textwidth}
%	\resizebox{\textwidth}{!}{
\begin{minipage}{1.8cm}
\begin{lstlisting}[xleftmargin=5mm,basicstyle=\ttfamily\scriptsize,escapeinside={(*}{*)}]
begin;
a=read((*$x$*));
b=read((*$y$*));
commit
\end{lstlisting}
\end{minipage}
\begin{minipage}{1mm}
||
\end{minipage}
\hspace{-5mm}
\begin{minipage}{1.3cm}
\begin{lstlisting}[xleftmargin=5mm,basicstyle=\ttfamily\scriptsize,escapeinside={(*}{*)}]
begin;
write((*$x$*),2);
write((*$y$*),2);
commit
\end{lstlisting}
\end{minipage}
\vspace{1.2cm}
%		}
		\caption{Program.}
		\label{fig:dead_branch:prog}
	\end{subfigure}
	\begin{subfigure}[b]{.125\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				
				%\\ \multicolumn{1}{c}{ \ldots}
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3.25, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \\ $\wrt{y}{0}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3.25, -2) {\begin{tabular}{l} 
						$\rd{x}$ \\ $\rd{y}$
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (-3.25, -4) {\begin{tabular}{l} 
						$\wrt{x}{2}$\pgfsetfillopacity{0.3}\\
						$\wrt{y}{2}$
				\end{tabular}};			
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1x);
				\path (t1.south east) -- (t1.south) coordinate[pos=0.67] (t1y);
				\path (t2.north west) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t2.north east) -- (t2.north) coordinate[pos=0.67] (t2y);
				
				\path (t1x) edge [left] node {$\wro_y$} (t2x);
				\path (t1y) edge [right] node {$\wro_x$} (t2y);
				%\path (t2) edge [right] node {$\wro_x$} (t3);
			\end{tikzpicture}  
			
		}
		\caption{Current.}
		\label{fig:dead_branch:a}
	\end{subfigure}
	\hspace{.175cm}
	\centering
	\begin{subfigure}[b]{.12\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3.25, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \\ $\wrt{y}{0}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3.25, -4) {\begin{tabular}{l} 
						$\rd{x}$ \pgfsetfillopacity{0.3}\\ $\rd{y}$
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (-3.25, -2) {\begin{tabular}{l} 
						$\wrt{x}{2}$\pgfsetfillopacity{0.3}\\
						$\wrt{y}{2}$
				\end{tabular}};			
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1x);
				\path (t2.north west) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t3.north west) -- (t3.west) coordinate[pos=0.67] (t3x);
				
				\path (t3.south) edge [left] node {$\wro_x$} (t2.north); %[yshift=8,xshift=0]
				%\path (t1x) edge [right] node {$\wro_y$} (t2x);
			\end{tikzpicture}  
			
		}
		\caption{Swapped.}
		\label{fig:dead_branch:b}
	\end{subfigure}
	\hspace{.175cm}
	\centering
		\begin{subfigure}[b]{.177\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3.25, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \\ $\wrt{y}{0}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3.25, -4) {\begin{tabular}{l} 
						$\rd{x}$ \\ $\rd{y}$
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (-3.25, -2) {\begin{tabular}{l} 
						$\wrt{x}{2}$\pgfsetfillopacity{0.3}\\
						$\wrt{y}{2}$
				\end{tabular}};			
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1x);
				\path (t2.north west) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t3.north west) -- (t3.west) coordinate[pos=0.67] (t3x);
				
				%\path (t3x) edge [above] node[yshift=8,xshift=0] {$\wro_x$} (t2.north east);
				\path (t3.south) edge [left] node {$\wro_x$} (t2.north);
				\path (t1.south west) edge [bend right] node[left] {$\wro_y$} (t2.north west);
			\end{tikzpicture}
		}
		\caption{Extended.}
		\label{fig:dead_branch:c}
	\end{subfigure}
	\hspace{.175cm}
	\centering
	\begin{subfigure}[b]{.177\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3.25, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \\ $\wrt{y}{0}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3.25, -4) {\begin{tabular}{l} 
						$\rd{x}$ \\ $\rd{y}$
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (-3.25, -2) {\begin{tabular}{l} 
						$\wrt{x}{2}$\\
						$\wrt{y}{2}$
				\end{tabular}};			
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1x);
				\path (t2.north west) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t3.north west) -- (t3.west) coordinate[pos=0.67] (t3x);
				
				%\path (t3x) edge [above] node[yshift=8,xshift=0] {$\wro_x$} (t2.north east);
				\path (t3.south) edge [left] node {$\wro_x$} (t2.north);
				\path (t1.south west) edge [bend right] node[left] {$\wro_y$} (t2.north west);
			\end{tikzpicture}
			
		}
		\caption{Inconsistent.}
		\label{fig:dead_branch:d}
	\end{subfigure}
	\caption{Example of inconsistency after swapping two events. TODO MAY NEED TO EXPLAIN THE CONVENTIONS IN THE PICTURE.}
	\label{fig:dead_branch}
	%\vspace{-3mm}
\end{figure}

%Proceeding this way we can ensure that every complete history is not inconsistent, but we cannot yet ensure every incomplete consistent history lead to a complete and consistent one. Guaranteeing it would mean that every step done in the algorithm is meaningful; that any explored branch would lead to a dead end. 
%The process of re-ordering events must maintain the invariant that the algorithm explores histories with at most one pending transaction, 
Re-ordering events must preserve the invariant of producing histories with at most one pending transaction.
To explain the use of this invariant in avoiding fruitless explorations, let us consider the program in Figure~\ref{fig:dead_branch:prog} assuming an exploration under Read Committed. The oracle order gives priority to the transaction on the left.
Assume that the current history reached by the exploration is the one pictured in Figure~\ref{fig:dead_branch:a} (the last added event is $\wrt{x}{2}$). Swapping the $\wrt{x}{2}$ event with the $\rd{x}$ event would result in the history pictured in Figure~\ref{fig:dead_branch:b}. To ensure that this swap produces a new history which was not explored in the past, the $\wro_x$ dependency of $\rd{x}$ is changed towards the $\wrt{x}{2}$ transaction (we detail this later).
%$\RA$
%One example of this undesired behavior can be easily seen under RA memory model with the program depicted in Figure~\ref{fig:dead_branch}. Here we consider three transactions ordered from left to right, top to bottom, and we start with the history depicted in Figure~\ref{fig:dead_branch:a}. After executing the $\nextEvent$ event, the $\iwrite$ $w_x  \coloneqq \wrt{x}{2}$, 
%one possible action would be swapping $w_x$ with the event $a \gets \rd{x}$; obtaining the history $h_2$ portrayed in Figure~\ref{fig:dead_branch:b}. 
By the definition of $\nextEvent$ (and the oracle order), this history shall be extended with $\rd{y}$, and this read event will be associated by $\wro_y$ to the only available $\iwrite(y,\_)$ event. This is pictured in 
Figure~\ref{fig:dead_branch:c}. The next exploration step will extend the history with $\ewrt{x,2}$ (the only extension possible) which however, results in a history that does \emph{not} satisfy Read Committed, thereby, the recursive exploration branch being blocked.
%as there is only one $\iwrite(y,\_)$ event, the $\wro$ dependncy for this
%that writes $y$, $r_b$ must read from the very first transaction; as seen in Figure~\ref{fig:dead_branch:c}. However, when completing the third transaction we must inexorably admit that our history in Figure~\ref{fig:dead_branch:d} is inconsistent. Therefore, all the computation required to complete the unfinished transactions after the swap was in vain; we couldn't detect after computing $h_2$ the dead end.
% As $\nextEvent$ function always prioritize pending transactions
The core issue is related to the history in Figure \ref{fig:dead_branch:c} which has a pending transaction that is \emph{not} $(\so \cup \wro)^*$-maximal. Being able to extend such a transaction while maintaining consistency with the intended isolation level is not guaranteed by Read Committed (and any other isolation level we consider). Nevertheless, causal extensibility guarantees the existence of an extension for pending transactions that are $(\so \cup \wro)^*$-maximal. We enforce this requirement by restricting the explored histories to have at most one pending transaction. This pending transaction will necessarily by $(\so \cup \wro)^*$-maximal.

%
%Hence, for being always able to extend a history by invoking the model's causally-extensibility, we have to never produce pending transactions that are non $\so \cup \wro$-maximal. A simple solution is always executing histories in isolation, i.e. having exactly one pending transaction; thus, $\so \cup \wro$-maximal,  otherwise there would be a previous point where two pending transactions coexisted. To sum up, we are not going to swap just after executing a $\iwrite$ event but when its transaction is completed.

TODO EXPLAIN THE DEFINITIONS BELOW

To enforce histories with at most one pending transaction, the function $\genericCompute$, which identifies events to reorder, has a non-empty return value only when the last added event is $\ecommit$ (the end of a transaction).

\begin{cframed}[pinegreen]
	\begin{equation*}
		\begin{array}{lcl}
			\genericCompute(h_<) & \coloneqq & \{(r,w) \in \Events \ | \ r < w \land \variable{r} = \variable{w} \land w \in \writeOp{t}\\[1mm]
			&& \hspace{1.9cm} \land\ (\trans{h}{r},t)\not\in [\so \cup \wro]^*   \} \\[1mm]
			&& \mbox{where }t = \lastTr{h_<}
		\end{array}
	\end{equation*}
\end{cframed}

\begin{cframed}[pinegreen]
	\begin{equation*}
		\begin{array}{lcl}
			\swap(h_<, r, w, \locals) & \coloneqq &\big(h' = (h \setminus D) \oplus \wro(w,r), <'\big ), \locals', \text{ where} \\[1mm]
			&& \hspace{1cm}D = \{e \ | \ r < e \land (\trans{h}{e},\trans{h}{w})\not\in [\so \cup \wro]^*\} \\[1mm]
			&& \hspace{1cm}<' = \big( <\ \downarrow\ (\tlogs{h'}\setminus \trans{h'}{r}) \big) \cdot \trans{h'}{r} \\[1mm]
			&& \hspace{1cm}\mbox{$\locals'$ is the projection of $\locals$ on events in $\hist'$.}
		\end{array}
	\end{equation*}
\end{cframed}


%Following algorithm \ref{algorithm:algo-class}'s schema, we define two functions $\compute, \swap$ that plays the role of $\genericCompute, \genericSwap$ respectively. In addition, for the history $h' = \swap(h, r, w)$ we declare the algorithm order of $h'$, $\leq_{h'}$ as $\leq_{h'} = \leq_{(h \setminus \tr(r) ) \restriction_{h'}} \cup \{\langle e, e' \rangle \ | \ e \in h' \setminus \tr(r), e' \in \tr(r)\} \cup \po_{\tr(r) \restriction_{h'}}$.
%
%\begin{cframed}[pinegreen]
%	\begin{equation*}
%		\begin{array}{ccc}
%			\compute(h) & \coloneqq & \{(r,w) \in h^2 \ | \ r <_h w \land \variable{r} = \variable{w} \land w \in \tr(\last{h}) \} \\
%			\swap(h, r, w) & \coloneqq & (h \setminus D) \bullet_w r \\
%			& \text{where} & D = \{e \ | \ r \leq_h e \land \lnot (\tr(e) \ [\so \cup \wro]^* \ \tr(w))\}
%		\end{array}
%	\end{equation*}
%\end{cframed}


\subsection{Avoiding Redundancy}

Conversely, adding a $\iwrite$ $w$ is more complicated, multiple events may read this new event; specifically. the number of possible histories is exponential, $2^{|\iread(h)|}$. Moreover, after changing a $\wro$-edge from a $\iread$ $r$, we have no knowledge of the rest of the event's presence: some conditional instruction may be executed after $r$ and it may be meaningless talking about them. Thus, checking for every possible set of $\iread$ events if reading from $w$ leads to something consistent is no reasonable. Therefore, we have to define a criterion to determine whose sets of read events shall be analyzed. One hand, the history $h \bullet w$ where no $\iread$ reads from $w$ has to be explored, with an algorithm order defined in an analogously as for any other aforementioned history. On the other hand, we select one $\iread$ $r$ that will be the first event in $h$ reading from $w$ while the ones that follow $r$ will have to be re-executed. As $r$ had already been executed, what at the end we produce is a swap between the relative orders of $r$ and $w$; so $r$ would be thereinafter called \textit{swapped}.

%As in a more formal way definition \ref{def:swapped} states, this read $r$ would be thereinafter called \textit{swapped}

%Moreover, after changing a $\wro$-edge, we have no knowledge of the rest of the event's presence: some conditional instruction may be executed after that $\iread$ and it may be meaningless talking about the rest of the events. Moreover, by the prefix-closedness of our model, an inconsistent history only leads to inconsistent ones; so there is no reasonable reason for exploring those. Thus, instead of generating every single one of them and check afterwards if they are consistent, we prefer to generate a small subset and only extends those ones that are consistent; by the prefix-closedness of our model, an inconsistent history only leads to inconsistent ones. %Therefore, we can detect inconsistencies early on.

%Our protocol is defined as follows: we will select one $\iread$ event that will be the first event in $h$ reading from $w$ while the ones that proceed $r$ will be marked as postponed; they will have to be re-executed. As in a more formal way definition \ref{def:swapped} states, This read $r$ would be thereinafter called \textit{swapped}:

%, and we will enforce the following properties: no event before $r$ will read from $w$, $r$ reads from $w$, every read after $r$ may or may not read from $w$. 

\begin{definition}
	A $\iread$ event $r$ is \callout{swapped} if the following conditions hold:
	\begin{itemize}
		\item For $w= h.\wro(r)$, $w <_h r$ and $w >_{\ora} r$.
		\item $\tr(r)$ is the first transaction that depends on $\tr(w)$: $\nexists T <_{\ora} \tr(r)$ s $T <_h \tr(r)$ and $\tr(w) \ [\so \cup \wro]^+ \ T$. %\textcolor{red}{Note: I changed $T \neq \tr(r)$ to $T <_{\ora} \tr(r)$ for the proof as by $\ora$-respectfulness (defined in proof's section), we obtain both are equivalent.}
		\item $r$ is the first $\iread$ event that reads from $\tr(w)$: $\nexists r'\in \tr(r), r' \leq_{\ora} r$ such that $\tr(h.\wro(r')) = \tr(w)$
	\end{itemize}
	\label{def:swapped}
\end{definition}

This definition is summarized in the following function:

\begin{cframed}[pinegreen]
	\begin{equation*}
		\begin{array}{lcl}
			\swapped{h_<}{r} & \coloneqq & 
			\begin{array}{c}
				w < r \land w >_{\ora} r \\
				\land \\
				\forall e \in h.\ \trans{h}{e} <_{\ora} \trans{h}{r} \implies (r < e  \lor (\trans{h}{w},\trans{h}{e})\not\in [\so \cup \wro]^+) \\
				\land \\
				\forall r' \in \readOp{h}.\ (\trans{h}{w},r')\in\wro \implies (r',r)\not\in \po  %\trans{h}{w'} \neq \trans{h}{w}
			\end{array} \\[11mm]
			&&\mbox{where $w$ is the write event such that $(\trans{h}{w},r)\in\wro$}
		\end{array}
	\end{equation*}
\end{cframed}

\begin{cframed}[pinegreen]
	\begin{equation*}
		\begin{array}{lcl}
			%\exists x \in \mathcal{V}, \exists w \in \writeOp{h} \text{ s.t. } 
			\isMaximallyAdded{h_<}{r} & \coloneqq &  
			\begin{array}{c}
%				\lnot \swapped{h}{r} \land 	\isConsistent{h}\\
%				\land \\
				%\forall r'\in \readOp{h}.\ \ (r,r')\in\po^* \implies 
				\lnot \swapped{h_<}{r}\\
				\land \\
				\forall w' \in \writeOp{h}.\ \ w < w' < r \implies 
				(h \setminus \{e \ | \ r < e\}) \oplus \wro(w',r)\not\models I)
%				\text{where } D = \{e \ | \ r \leq_h e\}
				%\left(\text{where } %h' = h \land 
				%\left\{\begin{array}{cc}
				%	h'.\wro(e') = h.\wro(e') & \text{if } e' \neq e \\ 
				%	h'.\wro(e) = w & \text{otherwise} \\ 
				%\end{array}\right\}\right)
			\end{array} \\[7mm]
			&&\mbox{where $w$ is the write event such that $(\trans{h}{w},r)\in\wro$}
		\end{array}
	\end{equation*}
\end{cframed}

\begin{figure}[H]
	
	\centering
	\begin{subfigure}[b]{.3\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \\ $a \gets \rd{x}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3, -1.75) {\begin{tabular}{l} $b \gets \rd{x}$\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {\begin{tabular}{l} $\wrt{x}{2}$ \\ $\wrt{y}{2}$\end{tabular}};
				\node[draw, rounded corners=2mm, outer sep=0] (t4) at (3, -0) {
					\begin{tabular}{l} 
						$c \gets \rd{x}$ \\
						{\pgfsetfillopacity{0.3}$\wrt{x}{3}$}
				\end{tabular}};
				\node[draw, rounded corners=2mm, opacity=0.3] (t5) at (3, -1.75) {\begin{tabular}{l} $\wrt{y}{4}$ \end{tabular}};
				\path[opacity=0.3] (t4) edge node[opacity=0.3] {$\so$} (t5);
				
				
				\path (t3.south east) -- (t3.east) coordinate[pos=0.67] (t3x);
				\path (t4.south west) -- (t4.west) coordinate[pos=0.67] (t4x);
				\path (t3x) edge[above] node[yshift=0,xshift=0] {$\wro_x$} (t4x);
				
				\path (t1.north west) -- (t1.north) coordinate[pos=0.5] (t1a);
				\path (t1.west) edge [out=140, in=120, looseness=2.25] (t1a);
				%[out=100,in=120,looseness=5] bend left=50, 
				
				\node[above left =0.125 and 0.05 of t1.north](t1alab) {$\wro_x$};
				\path (t1) edge [left] node {$\wro_x$} (t2);
			\end{tikzpicture}  
			
		}
		\caption{Current history.}
		\label{fig:add_write:a}
	\end{subfigure}
	\hspace{.5cm}
	\centering
	\begin{subfigure}[b]{.3\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \\ $a \gets \rd{x}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3, -1.75) {\begin{tabular}{l} $b \gets \rd{x}$\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {\begin{tabular}{l} $\wrt{x}{2}$ \\ $\wrt{y}{2}$\end{tabular}};
				\node[draw, rounded corners=2mm, outer sep=0] (t4) at (3, -0) {
					\begin{tabular}{l} 
						$c \gets \rd{x}$ \\
						$\wrt{x}{3}$
				\end{tabular}};
				\node[draw, rounded corners=2mm, opacity=0.3] (t5) at (3, -1.75) {\begin{tabular}{l} $\wrt{y}{4}$ \end{tabular}};
				\path[opacity=0.3] (t4) edge node[opacity=0.3] {$\so$} (t5);
				
				
				\path (t3.south east) -- (t3.east) coordinate[pos=0.67] (t3x);
				\path (t4.south west) -- (t4.west) coordinate[pos=0.67] (t4x);
				\path (t3x) edge[above] node[yshift=0,xshift=0] {$\wro_x$} (t4x);
				
				\path (t4.south west) edge [bend left=15] node[above] {$\wro_x$} (t2.east);
				
				\path (t1.north west) -- (t1.north) coordinate[pos=0.5] (t1a);
				\path (t1.west) edge [out=140, in=120, looseness=2.25] (t1a);
				%[out=100,in=120,looseness=5] bend left=50, 
				
				\node[above left =0.125 and 0.05 of t1.north](t1alab) {$\wro_x$};
				
			\end{tikzpicture}  
			
		}
		\caption{One possible swap.}
		\label{fig:add_write:b}
	\end{subfigure}
	\hspace{.5cm}
	\centering
	\begin{subfigure}[b]{.29\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \\ $a \gets \rd{x}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, opacity=0.3] (t2) at (-3, -1.75) {\begin{tabular}{l} $b \gets \rd{x}$\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {\begin{tabular}{l} $\wrt{x}{2}$ \\ $\wrt{y}{2}$\end{tabular}};
				\node[draw, rounded corners=2mm, outer sep=0] (t4) at (3, -0) {
					\begin{tabular}{l} 
						$c \gets \rd{x}$ \\
						$\wrt{x}{3}$
				\end{tabular}};
				\node[draw, rounded corners=2mm, opacity=0.3] (t5) at (3, -1.75) {\begin{tabular}{l} $\wrt{y}{4}$ \end{tabular}};
				\path[opacity=0.3] (t4) edge node[opacity=0.3] {$\so$} (t5);
				
				
				\path (t3.south east) -- (t3.east) coordinate[pos=0.67] (t3x);
				\path (t4.south west) -- (t4.west) coordinate[pos=0.67] (t4x);
				\path (t3x) edge[above] node[yshift=0,xshift=0] {$\wro_x$} (t4x);
				
				\path (t4.north west) edge [bend right=15] node[above] {$\wro_x$} (t1.north east);
				
			\end{tikzpicture}  
			
		}
		\caption{Another possible swap.}
		\label{fig:add_write:c}
	\end{subfigure}
	\caption{Extensions of a history by adding a $\iwrite$ event.}
	\label{fig:add_write}
	%\vspace{-3mm}
\end{figure}

%\textcolor{red}{Talk about this example, explain why t2 disappears in 4.3}

Let us show with an example the power of swapping. Here, in Figure~\ref{fig:add_write:a} we can see an incomplete history whose $\nextEvent$ event, $w \coloneqq \wrt{x}{3}$, is a $\iwrite$ event. There are four possible histories, depending if the first and second $\iread$ events, $r_a \coloneqq a \gets \rd{x} $ and $r_b \coloneqq b \gets \rd{x}$, read or not from $w$ (as $c \gets \rd{x}$ will never be able to read from $w$). In Figure~\ref{fig:add_write:b} we can see the history $h_b$ where only $r_b$ reads from $w$. As $r_a <_h r_b$, we simply state that $w \ [\wro] \ r_b$ in $h_b$. The other two cases that modify the write-read relation are due to the edge $w \ [\wro] \ r_a$; their common root. Therefore, we can construct the history $h_c$ depicted in Figure~\ref{fig:add_write:c}, mark $r_b$ as no executed to later on re-execute it and decide, in a later moment, if $w \ [\wro] \ r_b$ or not. In even in this small case we can realize that if $h_c$ would be inconsistent, we would already reduce the number of explored histories by one; its extensions would also be inconsistent. %we can delete $r_b$ for re-executing it later as depicted in Figure~\ref{fig:add_write:c} and by the rules described above, we know that two histories, one where $r_a$ reads from $w$ and another where it does not will be generated. 

In a more general context, when swapping two events $r$ and $w$, we will delete all those events $e$ that are between $r$ and $w$ in the history-order such that $\tr(w)$ does not depends on. Otherwise, deleting some event $e$ such that $\tr(e) \ [\so \cup \wro]^* \ \tr(w)$ holds will produce a history where either some $\iread$ is reading from a deleted $\iwrite$ or some event would be executed before its $\so$-predecessor; both impossible situations in real life.

\begin{cframed}[pinegreen]
	\begin{equation*}
		\begin{array}{lcl}
			\genericProtocol(h_<, r, w) & \coloneqq & 
			\begin{array}{l}
%				\forall r'\in \readOp{h}. \ (r,r')\in \po^* \implies \lnot \swapped{h_<}{r'}\\[1mm]
%				\land\ 
				\forall r'\in \readOp{h}\cap (D\cup\{r\}). \ \isMaximallyAdded{h_<}{r'}
			\end{array} \\[4mm]
			\multicolumn{3}{c}{\text{where }  D = \{e \ | \ r < e \land (\trans{h}{e},\trans{h}{w})\not\in [\so \cup \wro]^*\}} \\
		\end{array}
	\end{equation*}
\end{cframed}


%The name ``swapping'' $w$ and $r$ refers to the change of relative order between those two events; $r <_{\ora} w$ but in the new history their order is reversed: $w <_h r$. Moreover, every event $e$ after $r$ that does not unlock $w$ (i.e. the condition $\tr(e) \ [\so \cup \wro]^+ \ \tr(w) $ does not hold) will be not taking into account to check this consistency. The reason for this is simple: if we want to compute every possible history, we may need to restate where some read-events read from, and we achieve this by re-executing them. To avoid redundancies, only those that $\tr(w)$ not depend on should being able to be re-executed.

%\begin{comment}
%\begin{algorithm}[H]
%\caption{\textsc{STMC}$_0$}
%\begin{algorithmic}[1]
%\InputAlgorithmic $h$: history.
%\If{ $\lnot \ \textsc{IsConsistent}_{\mathcal{M}}(h)$} \Return
%\ElsIf{$\textsc{IsComplete}(h)$}
%\State $\textsc{processHistory}(h)$
%\Else
%\State $a \gets  \nextEvent(h)$; $\; x \gets a.var()$
%\Switch{$a.type()$}
%\Case{$\ibegin$}
%\Comment{$\ibegin$ and $\iend$ cases coincide.}
%\EndCase
%\Case{$\iend$}
%\State $\textsc{STMC}_0(h \bullet a)$
%\Break
%\EndCase
%\Case{$\iread$}
%\ForAll{$w \in h \text{ s.t. } \writeVar{w}{x}$}
%\State $h' \gets h \bullet a$; $\; h'.\wro[a] \gets w$
%\State $\textsc{STMC}_0(h')$
%\EndFor
%\Break
%\EndCase
%\Case{$\iwrite$}
%\State $\textsc{STMC}_0(h \bullet a)$
%\ForAll{$r \in h \text{ s.t. } \readVar{r}{x}$}
%\State $D \gets \{e \ | \ r <_h e \land \lnot (\tr(e) \ [\so \cup \wro]^* \ \tr(a))\}$
%\State $h' \gets (h \setminus D) \bullet a$; $\; h'.\wro[r] \gets a$
%\State $\textsc{STMC}_0(h')$
%\EndFor
%\Break
%\EndCase
%\EndSwitch
%\EndIf
%
%\end{algorithmic}
%\label{algorithm:stmc0}
%\end{algorithm}
%\end{comment}


