\subsection{Avoiding inconsistent branches}

Besides sound and complete, we would also seek for an optimal algorithm, i.e. that avoids computing a history $h$ whose extensions are all inconsistent; also called a \textit{blocking} execution. If this is not achieved, our search would employ more resources such as time or memory than it actually needs for doing its purpose.

\begin{figure}[H]
	
	\centering
	\begin{subfigure}[b]{.23\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				
				%\\ \multicolumn{1}{c}{ \ldots}
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3.25, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \\ $\wrt{y}{0}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3.25, -2) {\begin{tabular}{l} 
						$a \gets \rd{x}$ \\ $b \gets \rd{y}$
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, opacity=0.3] (t3) at (0, 0) {\begin{tabular}{l} 
						$\wrt{x}{2}$ \\ $\wrt{y}{2}$
				\end{tabular}};			
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1x);
				\path (t1.south east) -- (t1.south) coordinate[pos=0.67] (t1y);
				\path (t2.north west) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t2.north east) -- (t2.north) coordinate[pos=0.67] (t2y);
				
				\path (t1x) edge [left] node {$\wro_y$} (t2x);
				\path (t1y) edge [right] node {$\wro_x$} (t2y);
			\end{tikzpicture}  
			
		}
		\caption{Current.}
		\label{fig:dead_branch:a}
	\end{subfigure}
	\hspace{.175cm}
	\centering
	\begin{subfigure}[b]{.23\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3.25, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \\ $\wrt{y}{0}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3.25, -2) {\begin{tabular}{l} 
						$a \gets \rd{x}$ \pgfsetfillopacity{0.3}\\ $b \gets \rd{y}$
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {\begin{tabular}{l} 
						$\wrt{x}{2}$\pgfsetfillopacity{0.3}\\
						$\wrt{y}{2}$
				\end{tabular}};			
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1x);
				\path (t2.north west) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t3.north west) -- (t3.west) coordinate[pos=0.67] (t3x);
				
				\path (t3x) edge [above] node[yshift=8,xshift=0] {$\wro_x$} (t2.north east);
				%\path (t1x) edge [right] node {$\wro_y$} (t2x);
			\end{tikzpicture}  
			
		}
		\caption{After swapping.}
		\label{fig:dead_branch:b}
	\end{subfigure}
	\hspace{.175cm}
	\centering
	\begin{subfigure}[b]{.23\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3.25, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \\ $\wrt{y}{0}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3.25, -2) {\begin{tabular}{l} 
						$a \gets \rd{x}$ \\ $b \gets \rd{y}$
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {\begin{tabular}{l} 
						$\wrt{x}{2}$\pgfsetfillopacity{0.3}\\
						$\wrt{y}{2}$
				\end{tabular}};			
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1x);
				\path (t2.north west) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t3.north west) -- (t3.west) coordinate[pos=0.67] (t3x);
				
				\path (t3x) edge [above] node[yshift=8,xshift=0] {$\wro_x$} (t2.north east);
				\path (t1x) edge [right] node {$\wro_y$} (t2x);
			\end{tikzpicture}
			
		}
		\caption{Extended.}
		\label{fig:dead_branch:c}
	\end{subfigure}
	\hspace{.175cm}
	\centering
	\begin{subfigure}[b]{.23\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3.25, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \\ $\wrt{y}{0}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3.25, -2) {\begin{tabular}{l} 
						$a \gets \rd{x}$ \\ $b \gets \rd{y}$
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {\begin{tabular}{l} 
						$\wrt{x}{2}$\\
						$\wrt{y}{2}$
				\end{tabular}};			
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1x);
				\path (t2.north west) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t3.north west) -- (t3.west) coordinate[pos=0.67] (t3x);
				
				\path (t3x) edge [above] node[yshift=8,xshift=0] {$\wro_x$} (t2.north east);
				\path (t1x) edge [right] node {$\wro_y$} (t2x);
			\end{tikzpicture}
			
		}
		\caption{Inconsistent.}
		\label{fig:dead_branch:d}
	\end{subfigure}
	\caption{Example of a dead-lock after swapping two events.}
	\label{fig:dead_branch}
	%\vspace{-3mm}
\end{figure}

%Proceeding this way we can ensure that every complete history is not inconsistent, but we cannot yet ensure every incomplete consistent history lead to a complete and consistent one. Guaranteeing it would mean that every step done in the algorithm is meaningful; that any explored branch would lead to a dead end. 
One example of this undesired behavior can be easily seen under RA memory model with the program depicted in Figure~\ref{fig:dead_branch}. Here we consider three transactions ordered from left to right, top to bottom, and we start with the history depicted in Figure~\ref{fig:dead_branch:a}. After executing the $\nextEvent$ event, the $\iwrite$ $w_x  \coloneqq \wrt{x}{2}$, one possible action would be swapping $w_x$ with the event $a \gets \rd{x}$; obtaining the history $h_2$ portrayed in Figure~\ref{fig:dead_branch:b}. By definition of the $\nextEvent$ function, that history shall be extended with $r_b \coloneqq b \gets \rd{y}$, but as there is only one $\iwrite$ instruction that writes $y$, $r_b$ must read from the very first transaction; as seen in Figure~\ref{fig:dead_branch:c}. However, when completing the third transaction we must inexorably admit that our history in Figure~\ref{fig:dead_branch:d} is inconsistent. Therefore, all the computation required to complete the unfinished transactions after the swap was in vain; we couldn't detect after computing $h_2$ the dead end.

% As $\nextEvent$ function always prioritize pending transactions
This example fails as history from figure \ref{fig:dead_branch:c} has a pending transaction that is not $\so \cup \wro$-maximal. Hence, for being always able to extend a history by invoking the model's causally-extensibility, we have to never produce pending transactions that are non $\so \cup \wro$-maximal. A simple solution is always executing histories in isolation, i.e. having exactly one pending transaction; thus, $\so \cup \wro$-maximal,  otherwise there would be a previous point where two pending transactions coexisted. To sum up, we are not going to swap just after executing a $\iwrite$ event but when its transaction is completed.

Following algorithm \ref{algorithm:algo-class}'s schema, we define two functions $\compute, \swap$ that plays the role of $\genericCompute, \genericSwap$ respectively. In addition, for the history $h' = \swap(h, r, w)$ we declare the algorithm order of $h'$, $\leq_{h'}$ as $\leq_{h'} = \leq_{(h \setminus \tr(r) ) \restriction_{h'}} \cup \{\langle e, e' \rangle \ | \ e \in h' \setminus \tr(r), e' \in \tr(r)\} \cup \po_{\tr(r) \restriction_{h'}}$.



\begin{cframed}[pinegreen]
	\begin{equation*}
		\begin{array}{ccc}
			\compute(h) & \coloneqq & \{(r,w) \in h^2 \ | \ r <_h w \land \variable{r} = \variable{w} \land w \in \tr(\last{h}) \} \\
			\swap(h, r, w) & \coloneqq & (h \setminus D) \bullet_w r \\
			& \text{where} & D = \{e \ | \ r \leq_h e \land \lnot (\tr(e) \ [\so \cup \wro]^* \ \tr(w))\}
		\end{array}
	\end{equation*}
\end{cframed}


\begin{comment}
so by induction, we can always obtain total histories at any point in the algorithm.

contenidos...

\begin{theorem}
\label{theorem:isolationAlwaysExtensible}
For every maximal closed model $\mathcal{M}$ that satisfies \textcolor{red}{ref properties of models} and every non-total consistent history $h$ executed in isolation there is a consistent extension $h' = h \bullet e$, where $e = \nextEvent(h)$.
\begin{proof}

\end{proof}
\end{theorem}

By theorem \ref{theorem:isolationAlwaysExtensible}, our objective can be achieved if every transaction can be executed in isolation. In our previous example, when swapping $w_x$ with $r_x$, at least two transactions remained unfinished: $\tr(w_x)$ and $\tr(r_x)$. For avoiding this situation, we are not going to swap just after executing a $\iwrite$ event but when its transaction is completed. %This forces us a subtle change in our decisions: instead of swapping some $\iwrite$ $w$ with a $\iread$ $r$, we will delay the swap until we find the end of $\tr(w)$.
\end{comment}



%Algorithm \ref{algorithm:sound-complete} is in charge of extending non-total consistent histories, detecting inconsistencies as soon as they are created (line \ref{algorithm:sound-complete:isConsistent}). For doing so, given a history $h$, it computes the $\nextEvent$ event $a$ with which $h$ is going to be extended (line \ref{algorithm:sound-complete:next}). If $a$ has type $\ibegin$ or $\iwrite$ there is only way to extend $h$, via $h \bullet a$ (line \ref{algorithm:caseBeginWriteRec}). In case $a$ is a $\iread$ event (line \ref{algorithm:caseReadRec}), we explore all possible histories $h'$ where $h'.\wro(a) = w$ (line \ref{algorithm:sound-complete:forRead}). Otherwise, $a$ has type $\iend$ and we explore the case where no swap is produced (line \ref{algorithm:sound-complete:endNoSwap}) and when it is produced (line \ref{algorithm:sound-complete:forEnd}). There we compute the set $D$ of events that have to be deleted from the history as explained in \ref{subsection:ExtendingHistories}, removing it from $h$ and setting a new $\wro$ edge between $r$ and $w$. 

%Only in the last case there is one transaction ending up pending, but thanks to theorem \ref{theorem:causalExtensibleModels}, if $h$ is executed in isolation, $h'$ will also be. Both arguments justify soundness and non-blocking properties of our algorithm. Completeness, on the other hand, it is not a immediate property.