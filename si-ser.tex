%!TEX root = main.tex
\section{Weak DPOR algorithms for Snapshot Isolation and Serializability}

As show in section \ref{sec:proofs-algorithm}, algorithm \ref{algorithm:optimal-instantiated}'s completeness proof (theorem \ref{theorem:completeness}) is model-depending, as it heavily relies on its causal-extensibility. Immediately, the question of the algorithm's extensibility to stricter isolation levels arise. For understanding the difference between the formers and $\SI$ or $\SER$, let's analyze how algorithm \ref{algorithm:optimal-instantiated} behaves for the program depicted in figure \ref{fig:ser-non-optimal:a} under them. We study this example as it has exactly two consistent executions but a dead-lock one under $\SI$ and $\SER$.

\begin{figure}[H]
	
	\centering
	\begin{subfigure}[b]{.25\textwidth}
%		\resizebox{\textwidth}{!}{
%			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
%				semithick, transform shape]
%				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-1.5, -0.25) {\begin{tabular}{l} $\init$ \end{tabular}};
%				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]130:$T_1$}] (t2) at (-3, -2) {\begin{tabular}{l} 
%						$\wrt{z}{1}$ \\ $a \gets \rd{x}$ \\ $\wrt{y}{1}$ \\ \ldots
%				\end{tabular}};
%				\node[draw, rounded corners=2mm,outer sep=0,  label={[font=\small]50:$T_2$}] (t2) at (0, -2) {\begin{tabular}{l} 
%						$\wrt{z}{2}$ \\ $b \gets \rd{y}$ \\ $\wrt{x}{2}$ \\ \ldots
%				\end{tabular}};		
%				
%				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1x);
%				\path (t2.north west) -- (t2.north) coordinate[pos=0.67] (t2x);
%				\path (t3.north west) -- (t3.west) coordinate[pos=0.67] (t3x);
%				
%				%\path (t3x) edge [above] node[yshift=8,xshift=0] {$\wro_x$} (t2.north east);
%				%\path (t1x) edge [right] node {$\wro_y$} (t2x);
%			\end{tikzpicture}  
%		}
\begin{minipage}{2cm}
\begin{lstlisting}[xleftmargin=5mm,basicstyle=\ttfamily\scriptsize,escapeinside={(*}{*)}]
begin;
write((*$z$*),1);
a = read((*$x$*));
write((*$y$*),1);
commit
\end{lstlisting}
\end{minipage}
\begin{minipage}{1mm}
||
\end{minipage}
\hspace{-5mm}
\begin{minipage}{1.3cm}
\begin{lstlisting}[xleftmargin=5mm,basicstyle=\ttfamily\scriptsize,escapeinside={(*}{*)}]
begin;
write((*$z$*),2);
b = read((*$y$*));
write((*$x$*),2);
commit
\end{lstlisting}
\end{minipage}
		\caption{Program.}
		\label{fig:ser-non-optimal:prog}
	\end{subfigure}
	\hspace{.5cm}
	\centering
	\begin{subfigure}[b]{.25\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-1.5, -0.25) {\begin{tabular}{l} $\init$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3, -2) {\begin{tabular}{l} 
						$\wrt{z}{1}$ \\ $\rd{x}$ \\ \pgfsetfillopacity{0.3}$\wrt{y}{1}$ 
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, -2) {\begin{tabular}{l} 
						$\wrt{z}{2}$ \\ \pgfsetfillopacity{0.3}$\rd{y}$ \\ \pgfsetfillopacity{0.3}$\wrt{x}{2}$ 
				\end{tabular}};		
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1sw);
				\path (t1.south east) -- (t1.south) coordinate[pos=0.67] (t1se);
				\path (t2.north east) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t3.north west) -- (t3.north) coordinate[pos=0.67] (t3x);
				
				%\path (t3x) edge [above] node[yshift=8,xshift=0] {$\wro_x$} (t2.north east);
				\path (t1sw) edge [left] node {$\wro_x$} (t2x);
%				\path (t1se) edge [right] node {$\wro_y$} (t3x);
			\end{tikzpicture}  
			
		}
		\caption{History.}
		\label{fig:ser-non-optimal:a}
	\end{subfigure}
	\hspace{.3cm}
	\centering
	\begin{subfigure}[b]{.10\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (0, 0) {\begin{tabular}{l} $\init$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (0, -1.8) {\begin{tabular}{l} 
						$\wrt{z}{1}$ \\ $\rd{x}$ \\ $\wrt{y}{1}$ 
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, -4) {\begin{tabular}{l} 
						\pgfsetfillopacity{0.3}$\wrt{z}{2}$ \\ \pgfsetfillopacity{0.3}$\rd{y}$ \\ \pgfsetfillopacity{0.3}$\wrt{x}{2}$ 
				\end{tabular}};		
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1sw);
				\path (t1.south east) -- (t1.south) coordinate[pos=0.67] (t1se);
				\path (t2.north east) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t3.north west) -- (t3.north) coordinate[pos=0.67] (t3x);
				
				%\path (t3x) edge [above] node[yshift=8,xshift=0] {$\wro_x$} (t2.north east);
				\path (t1.south) edge [left] node {$\wro_x$} (t2.north);
%				\path (t2.south) edge [left] node {$\wro_y$} (t3.north);
			\end{tikzpicture}  			
		}
		\caption{History.}
		\label{fig:ser-non-optimal:a}
	\end{subfigure}
	\hspace{.3cm}
	\centering
	\begin{subfigure}[b]{.25\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-1.5, -0.25) {\begin{tabular}{l} $\init$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3, -2) {\begin{tabular}{l} 
						$\wrt{z}{1}$ \\ $\rd{x}$ \\ \pgfsetfillopacity{0.3}$\wrt{y}{1}$ 
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, -2) {\begin{tabular}{l} 
						$\wrt{z}{2}$ \\ $\rd{y}$ \\ \pgfsetfillopacity{0.3}$\wrt{x}{2}$ 
				\end{tabular}};		
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1sw);
				\path (t1.south east) -- (t1.south) coordinate[pos=0.67] (t1se);
				\path (t2.north east) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t3.north west) -- (t3.north) coordinate[pos=0.67] (t3x);
				
				%\path (t3x) edge [above] node[yshift=8,xshift=0] {$\wro_x$} (t2.north east);
				\path (t1sw) edge [left] node {$\wro_x$} (t2x);
				\path (t1se) edge [right] node {$\wro_y$} (t3x);
			\end{tikzpicture}  
			
		}
		\caption{History.}
		\label{fig:ser-non-optimal:a}
	\end{subfigure}
	\hspace{.3cm}
	\centering
		\begin{subfigure}[b]{.22\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (0, 0) {\begin{tabular}{l} $\init$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (0, -1.8) {\begin{tabular}{l} 
						$\wrt{z}{1}$ \\ $\rd{x}$ \\ $\wrt{y}{1}$ 
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, -4) {\begin{tabular}{l} 
						$\wrt{z}{2}$ \\ $\rd{y}$ \\ \pgfsetfillopacity{0.3}$\wrt{x}{2}$ 
				\end{tabular}};		
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1sw);
				\path (t1.south east) -- (t1.south) coordinate[pos=0.67] (t1se);
				\path (t2.north east) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t3.north west) -- (t3.north) coordinate[pos=0.67] (t3x);
				
				%\path (t3x) edge [above] node[yshift=8,xshift=0] {$\wro_x$} (t2.north east);
				\path (t1.south) edge [left] node {$\wro_x$} (t2.north);
				\path (t2.south) edge [left] node {$\wro_y$} (t3.north);
			\end{tikzpicture}  
			\hspace{2mm}
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (0, 0) {\begin{tabular}{l} $\init$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (0, -1.8) {\begin{tabular}{l} 
						$\wrt{z}{2}$ \\ $\rd{y}$ \\ $\wrt{x}{2}$ 
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, -4) {\begin{tabular}{l} 
						$\wrt{z}{1}$ \\ $\rd{x}$ \\ \pgfsetfillopacity{0.3}$\wrt{y}{1}$ 
				\end{tabular}};		
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1sw);
				\path (t1.south east) -- (t1.south) coordinate[pos=0.67] (t1se);
				\path (t2.north east) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t3.north west) -- (t3.north) coordinate[pos=0.67] (t3x);
				
				%\path (t3x) edge [above] node[yshift=8,xshift=0] {$\wro_x$} (t2.north east);
				\path (t1.south) edge [left] node {$\wro_y$} (t2.north);
				\path (t2.south) edge [left] node {$\wro_x$} (t3.north);
			\end{tikzpicture}  			
		}
		\caption{Histories.}
		\label{fig:ser-non-optimal:b}
	\end{subfigure}
	\hspace{.5cm}
	\centering
	\begin{subfigure}[b]{.25\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-1.5, -0.25) {\begin{tabular}{l} $\init$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3, -2) {\begin{tabular}{l} 
						$\wrt{z}{1}$ \\ $\rd{x}$ \\ $\wrt{y}{1}$ 
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, -2) {\begin{tabular}{l} 
						$\wrt{z}{2}$ \\ $\rd{y}$ \\ $\wrt{x}{2}$ 
				\end{tabular}};		
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1sw);
				\path (t1.south east) -- (t1.south) coordinate[pos=0.67] (t1se);
				\path (t2.north east) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t3.north west) -- (t3.north) coordinate[pos=0.67] (t3x);
				
				%\path (t3x) edge [above] node[yshift=8,xshift=0] {$\wro_x$} (t2.north east);
				\path (t1sw) edge [left] node {$\wro_x$} (t2x);
				\path (t1se) edge [right] node {$\wro_y$} (t3x);
			\end{tikzpicture}  
		}
		\caption{Inconsistent history.}
		\label{fig:ser-non-optimal:c}
	\end{subfigure}
	\caption{A program and some partial histories. In gray, instructions not yet executed.}
	\label{fig:ser-non-optimal}
	%\vspace{-3mm}
\end{figure}

\begin{theorem}
If $I$ is \textit{Snapshot Isolation} or \textit{Serializability}, there exists no $\textsc{explore}$ algorithm that is $I$-sound, $I$-complete, and strongly optimal.
\end{theorem}
\begin{proof}
We consider the program in Figure~\ref{fig:ser-non-optimal:prog}, and show that any concrete instance of the $\textsc{explore}$ function in Algorithm~\ref{algorithm:algo-class} \emph{can not be both} $I$-complete and strongly optimal. Assuming that the function $\genericNext$ is not itself blocking (which would violate strong optimality), the $\textsc{explore}$ function will recurse on the history in Figure~\ref{fig:ser-non-optimal:a} and \emph{only one} of the histories in Figure~\ref{fig:ser-non-optimal:b} in the best case. Indeed, since $\genericNext$ has to respect the program order, it will start with the first write in one of the two transactions, and then, either follow with both read events before
\end{proof}

As $\mathcal{P}$ is symmetric and every computed partial execution have at most one pending transaction, we can assume, without loss of generality, the oracle order where $T_1$ precedes $T_2$. In this setting, when $A$ execute the read event $r_1 \coloneqq a \gets \rd{x}$, it will only be able to read from $\init$. After completing $T_1$, it executes the read-event $r_2 \coloneqq b \gets \rd{x}$ from $T_2$. One one hand, if $r_2$ reads from $T_1$, then we obtain a consistent history that can be extended to a total consistent one, $h$. However, from $h$ we cannot swap any two transactions as $T_2$ depends on $T_1$, which also depends on $\init$. On the other hand, if $r_2$ reads from $\init$ we will obtain a history $h'$ that leads to a deadlock (figure \ref{fig:ser-non-optimal:c}) and cannot be swapped before $T_2$'s completion; otherwise we would obtain a partial history $h''$ with two pending transaction. To sum up, algorithm \ref{algorithm:optimal-instantiated} is incomplete for $\SI$ and $\SER$.

This show that our proposal is not flexible enough to satisfy the constraints that new models may require. Therefore, we want to analyze what properties shall we weak for still obtaining a $\mathcal{M}$-sound, complete and optimal while employing polynomial memory; for $\SI$ and $\SER$ models. Let's suppose then that there exists such an algorithm $A \in \mathcal{S}_{\mathcal{M}}$ and see how it behaves under the same program $\mathcal{P}$. As $A$ is complete, whenever a $\iread$ event $r$ reading from some $\iwrite$ $w$ does not lead to an inconsistency, it will explore that possible history (the algorithm cannot deduce in advance if a dead-lock/inconsistency will appear later on). In particular, a consistent extension of the history shown in \ref{fig:ser-non-optimal:b} will be computed with either $\wrt{y}{1}$ or $\wrt{x}{2}$ in it. Without loss of generality, let's assume $w_2 \coloneqq \wrt{x}{2} \not \in h$. By definition of $\genericNext$ function, $a = \genericNext(h) \in h$, and as stated in lines \ref{algorithm:algo-class:exploreRead}, \ref{algorithm:algo-class:exploreStd}, the history $h \bullet a$ is an extension of $h$ that will always be explored. Moreover, as $A$ is $\mathcal{M}$-sound, $\texttt{N}(h')$ cannot return $w_2$ as $\lnot \ \textsc{IsConsistent}_{\mathcal{M}}(h' \bullet w_2)$ for any extension $h'$ of $h$. Therefore, there is a history $h'$ that extends $h$ where all events but those in $T_2$ $\po$-after $w_2$ will be executed. In conclusion, $\texttt{N}(h') = \bot$ but $h'$ is not total, so it must be a blocking execution. That contradicts $A$ is an optimal algorithm.


%Let's suppose on the contrary that such algorithm $A$ exists. As $A$ is complete, whenever a $\iread$ event $r$ reading from some $\iwrite$ $w$ does not lead to an inconsistency, it will explore that possible history. In particular, a consistent extension of the history shown in \ref{fig:ser-non-optimal:b} will be computed  with either $\wrt{y}{1}$ or $\wrt{x}{2}$ in it. Without loss of generality, let's assume $w_x \coloneqq \wrt{x}{2} \not \in h$. \textcolor{red}{Shall I develop this a bit more? how?}. As $A$ is weakly optimal, for every $a = \texttt{N}(h)$, $a \not\in h $ (otherwise $A$ will compute $h$ and $h \bullet a = h$); and as stated in lines \ref{algorithm:algo-class:exploreRead}, \ref{algorithm:algo-class:exploreStd}, the history $h \bullet a$ will always be explored. Moreover, as $A$ is $\mathcal{M}$-sound, $\texttt{N}(h')$ cannot return $w_x$ as $\lnot \ \textsc{IsConsistent}_{\mathcal{M}}(h' \bullet w_x)$, for any history $h'$ extending $h$. Therefore, there is an extension $h'$ of $h$ where all events but those in $T_2$ $\po$ after $w_x$ will be executed. In conclusion, $\texttt{N}(h') = \bot$ but $h'$ is not total, so it must be a blocking execution. That contradicts $A$ is an optimal algorithm.

\begin{theorem}
There is no algorithm in $\mathcal{S}_{\mathcal{M}} \cap \mathcal{O}^n_{\mathcal{M}}$, $n$ in $\mathbb{N}$, for neither SI nor SER.
\label{theorem:si-ser-bad-models}
\begin{comment}
\begin{proof}

\textcolor{red}{
During this proof let's call $\mathcal{P}$ to the program depicted in \ref{fig:ser-non-optimal:a}. Let's suppose on the contrary that such algorithm $A$ exists. As $A$ is complete, whenever a $\iread$ event $r$ reading from some $\iwrite$ $w$ does not lead to an inconsistency, it will explore that possible history. In particular, a consistent extension of the history shown in \ref{fig:ser-non-optimal:b} will be computed  with either $\wrt{y}{1}$ or $\wrt{x}{2}$ in it. Without loss of generality, let's assume $w_x \coloneqq \wrt{x}{2} \not \in h$. \textcolor{red}{Shall I develop this a bit more? how?}. As $A$ is weakly optimal, for every $a = \texttt{N}(h)$, $a \not\in h $ (otherwise $A$ will compute $h$ and $h \bullet a = h$); and as stated in lines \ref{algorithm:algo-class:exploreRead}, \ref{algorithm:algo-class:exploreStd}, the history $h \bullet a$ will always be explored. Moreover, as $A$ is $\mathcal{M}$-sound, $\texttt{N}(h')$ cannot return $w_x$ as $\lnot \ \textsc{IsConsistent}_{\mathcal{M}}(h' \bullet w_x)$, for any history $h'$ extending $h$. Therefore, there is an extension $h'$ of $h$ where all events but those in $T_2$ $\po$ after $w_x$ will be executed. In conclusion, $\texttt{N}(h') = \bot$ but $h'$ is not total, so it must be a blocking execution. That contradicts $A$ is an optimal algorithm.
}

%\underline{$S_{\mathcal{M}} \cap \mathcal{L}^1_{\mathcal{M}} = \emptyset$}. 

%Let's suppose on the contrary that such algorithm $A$ exists. As $A$ is in $\mathcal{L}^1_{\mathcal{M}}$ and $\mathcal{P}$ is symmetric, with out loss of generality we can assume $A$ execute first $T_1$ and then $T_2$. Then, it will execute the read event $r_1 \coloneqq a \gets \rd{x}$, which can only read from $\init$. After $T_1$, it executes the first event of $T_2$: $r_2 \coloneqq b \gets \rd{x}$. If $r_2$ reads from $T_1$, then we obtain a consistent history that can be extended to a total consistent one, $h$. However, from $h$ we cannot swap any two transactions as $T_2$ depends on $T_1$, which also depends on $\init$. On the other hand, if $r_2$ reads from $\init$, we will obtain a history $h'$ that leads to a deadlock and cannot be swapped before $T_2$'s completion; otherwise $A$ would have two pending transaction. Therefore, $A$ would only explore exactly one execution, so it is incomplete. This contradicts $A$ is in $\mathcal{L}^1_{\mathcal{M}}$.

%from this history, there %only has two transactions, $A$ can either execute the first or the second transaction at a time. As $A$ is complete and the history depicted in \ref{fig:ser-non-optimal:b} is consistent, there is an execution $h$ extending that history
%As after executing any event, $A$ has no information on the future events' availability, it will explore any possible consistent history. 

\textcolor{red}{The first case is due to the non-$\wro \cup \so$-maximality of SI, SER (second example we discussed). The second one is the example when there is only one branch computed (first example we discussed).}
\end{proof}
\end{comment}
\end{theorem}

In particular, the program in figure \ref{fig:ser-non-optimal} shows that both $\SI$ and $\SER$ are actually not causally-extensible. Nevertheless, we present a swapping-based $\mathcal{M}$-sound, complete, weakly optimal algorithm employing polynomial memory based on \ref{algorithm:optimal-instantiated}:

\textcolor{red}{Present code}

\begin{theorem}
Algorithm \textcolor{red}{cite SER's algo} belongs to $\mathcal{S}_{\mathcal{M}} \cap \mathcal{W}_{\mathcal{M}}$ for model $\mathcal{M}$, $\mathcal{M} \in \{\SI, \SER\}$.
\end{theorem}

\textcolor{red}{Discuss the exponential total branches ditched}
%The reason why theorem \ref{theorem:si-ser-bad-models} holds for $\SI$ and $\SER$ but not for the rest of isolation levels described in \ref{fig:consistency_defs} is due to the lack of causal-extensibility. Nevertheless, weakening

% Under any of them the event $\wrt{x}{2}$ would always be eligible to be added to the aforementioned history $h$, and therefore any final dead-lock would be reached.

