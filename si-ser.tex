%!TEX root = main.tex
\section{Swapping-based model checking for Snapshot Isolation and Serializability}\label{sec:ser}

%As show in section \ref{sec:proofs-algorithm}, algorithm \ref{algorithm:optimal-instantiated}'s completeness proof (theorem \ref{theorem:completeness}) is model-depending, as it heavily relies on its causal-extensibility. Immediately, the question of the algorithm's extensibility to stricter isolation levels arise. For understanding the difference between the formers and $\SI$ or $\SER$, let's analyze how algorithm \ref{algorithm:optimal-instantiated} behaves for the program depicted in figure \ref{fig:ser-non-optimal:a} under them. We study this example as it has exactly two consistent executions but a dead-lock one under $\SI$ and $\SER$.
For $\textsc{explore-ce}$, the part of strong optimality concerning \emph{not} engaging in fruitless explorations was a direct consequence of causal extensibility (of the isolation level). However, isolation levels such as SI and SER are \emph{not} causally extensible (see Section~\ref{ssec:causal_ext}). Therefore, the question we investigate in this section is whether there exists another implementation of $\textsc{explore}$ that can ensure strong optimality along with $I$-soundness and $I$-completeness for $I$ being SI or SER. We answer this question in the negative, and as a result, propose an SMC algorithm that extends $\textsc{explore-ce}$ by just filtering histories at the end before outputting to be consistent with SI or SER.

\begin{figure}[t]
	\centering
	\begin{subfigure}[b]{.25\textwidth}
%		\resizebox{\textwidth}{!}{
%			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
%				semithick, transform shape]
%				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-1.5, -0.25) {\begin{tabular}{l} $\init$ \end{tabular}};
%				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]130:$T_1$}] (t2) at (-3, -2) {\begin{tabular}{l} 
%						$\wrt{z}{1}$ \\ $a \gets \rd{x}$ \\ $\wrt{y}{1}$ \\ \ldots
%				\end{tabular}};
%				\node[draw, rounded corners=2mm,outer sep=0,  label={[font=\small]50:$T_2$}] (t2) at (0, -2) {\begin{tabular}{l} 
%						$\wrt{z}{2}$ \\ $b \gets \rd{y}$ \\ $\wrt{x}{2}$ \\ \ldots
%				\end{tabular}};		
%				
%				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1x);
%				\path (t2.north west) -- (t2.north) coordinate[pos=0.67] (t2x);
%				\path (t3.north west) -- (t3.west) coordinate[pos=0.67] (t3x);
%				
%				%\path (t3x) edge [above] node[yshift=8,xshift=0] {$\wro_x$} (t2.north east);
%				%\path (t1x) edge [right] node {$\wro_y$} (t2x);
%			\end{tikzpicture}  
%		}
\begin{minipage}{2cm}
\begin{lstlisting}[xleftmargin=5mm,basicstyle=\ttfamily\scriptsize,escapeinside={(*}{*)}]
begin;
write((*$z$*),1);
a = read((*$x$*));
write((*$y$*),1);
(*$\ldots$*)
commit
\end{lstlisting}
\end{minipage}
\begin{minipage}{1mm}
||
\end{minipage}
\hspace{-5mm}
\begin{minipage}{1.3cm}
\begin{lstlisting}[xleftmargin=5mm,basicstyle=\ttfamily\scriptsize,escapeinside={(*}{*)}]
begin;
write((*$z$*),2);
b = read((*$y$*));
write((*$x$*),2);
(*$\ldots$*)
commit
\end{lstlisting}
\end{minipage}
		\caption{Program.}
		\label{fig:ser-non-optimal:prog}
	\end{subfigure}
	\hspace{.5cm}
	\centering
	\begin{subfigure}[b]{.25\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-1.5, -0.25) {\begin{tabular}{l} $\init$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3, -2) {\begin{tabular}{l} 
						$\wrt{z}{1}$ \\ $\rd{x}$ \\ \pgfsetfillopacity{0.3}$\wrt{y}{1}$  \\ \ldots
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, -2) {\begin{tabular}{l} 
						$\wrt{z}{2}$ \\ \pgfsetfillopacity{0.3}$\rd{y}$ \\ \pgfsetfillopacity{0.3}$\wrt{x}{2}$ \\ \ldots
				\end{tabular}};		
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1sw);
				\path (t1.south east) -- (t1.south) coordinate[pos=0.67] (t1se);
				\path (t2.north east) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t3.north west) -- (t3.north) coordinate[pos=0.67] (t3x);
				
				%\path (t3x) edge [above] node[yshift=8,xshift=0] {$\wro_x$} (t2.north east);
				\path (t1sw) edge [left] node {$\wro_x$} (t2x);
%				\path (t1se) edge [right] node {$\wro_y$} (t3x);
			\end{tikzpicture}  
		}
		
		\vspace{2mm}
		
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-1.5, -0.25) {\begin{tabular}{l} $\init$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3, -2) {\begin{tabular}{l} 
						$\wrt{z}{1}$ \\ \pgfsetfillopacity{0.3}$\rd{x}$ \\ \pgfsetfillopacity{0.3}$\wrt{y}{1}$  \\ \pgfsetfillopacity{0.3}\ldots
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, -2) {\begin{tabular}{l} 
						$\wrt{z}{2}$ \\ $\rd{y}$ \\ \pgfsetfillopacity{0.3}$\wrt{x}{2}$ \\ \pgfsetfillopacity{0.3}\ldots
				\end{tabular}};		
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1sw);
				\path (t1.south east) -- (t1.south) coordinate[pos=0.67] (t1se);
				\path (t2.north east) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t3.north west) -- (t3.north) coordinate[pos=0.67] (t3x);
				
				%\path (t3x) edge [above] node[yshift=8,xshift=0] {$\wro_x$} (t2.north east);
				\path (t1se) edge [right] node {$\wro_y$} (t3x);
%				\path (t1se) edge [right] node {$\wro_y$} (t3x);
			\end{tikzpicture}  
		}
		\caption{History $\hist_1$ (top).}
		\label{fig:ser-non-optimal:1}
	\end{subfigure}
	\hspace{.3cm}
	\centering
	\begin{subfigure}[b]{.23\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (0, 0) {\begin{tabular}{l} $\init$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (0, -1.8) {\begin{tabular}{l} 
						$\wrt{z}{1}$ \\ $\rd{x}$ \\ $\wrt{y}{1}$ \\ \pgfsetfillopacity{0.3}\ldots
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, -4) {\begin{tabular}{l} 
						\pgfsetfillopacity{0.3}$\wrt{z}{2}$ \\ \pgfsetfillopacity{0.3}$\rd{y}$ \\ \pgfsetfillopacity{0.3}$\wrt{x}{2}$ \\ \ldots
				\end{tabular}};		
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1sw);
				\path (t1.south east) -- (t1.south) coordinate[pos=0.67] (t1se);
				\path (t2.north east) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t3.north west) -- (t3.north) coordinate[pos=0.67] (t3x);
				
				%\path (t3x) edge [above] node[yshift=8,xshift=0] {$\wro_x$} (t2.north east);
				\path (t1.south) edge [left] node {$\wro_x$} (t2.north);
%				\path (t2.south) edge [left] node {$\wro_y$} (t3.north);
			\end{tikzpicture}  	
			\hspace{3mm}
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (0, 0) {\begin{tabular}{l} $\init$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (0, -1.8) {\begin{tabular}{l} 
						$\wrt{z}{2}$ \\ $\rd{y}$ \\ $\wrt{x}{2}$ \\ \pgfsetfillopacity{0.3}\ldots
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, -4) {\begin{tabular}{l} 
						\pgfsetfillopacity{0.3}$\wrt{z}{1}$ \\ \pgfsetfillopacity{0.3}$\rd{x}$ \\ \pgfsetfillopacity{0.3}$\wrt{y}{1}$ \\ \ldots
				\end{tabular}};		
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1sw);
				\path (t1.south east) -- (t1.south) coordinate[pos=0.67] (t1se);
				\path (t2.north east) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t3.north west) -- (t3.north) coordinate[pos=0.67] (t3x);
				
				%\path (t3x) edge [above] node[yshift=8,xshift=0] {$\wro_x$} (t2.north east);
				\path (t1.south) edge [left] node {$\wro_y$} (t2.north);
%				\path (t2.south) edge [left] node {$\wro_y$} (t3.north);
			\end{tikzpicture}  		
		}
		\caption{History $\hist_2$ (left).}
		\label{fig:ser-non-optimal:2}
	\end{subfigure}
	\hspace{.3cm}
	\centering
	\begin{subfigure}[b]{.25\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-1.5, -0.25) {\begin{tabular}{l} $\init$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3, -2) {\begin{tabular}{l} 
						$\wrt{z}{1}$ \\ $\rd{x}$ \\ \pgfsetfillopacity{0.3}$\wrt{y}{1}$ \\ \ldots
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, -2) {\begin{tabular}{l} 
						$\wrt{z}{2}$ \\ $\rd{y}$ \\ \pgfsetfillopacity{0.3}$\wrt{x}{2}$ \\ \ldots
				\end{tabular}};		
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1sw);
				\path (t1.south east) -- (t1.south) coordinate[pos=0.67] (t1se);
				\path (t2.north east) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t3.north west) -- (t3.north) coordinate[pos=0.67] (t3x);
				
				%\path (t3x) edge [above] node[yshift=8,xshift=0] {$\wro_x$} (t2.north east);
				\path (t1sw) edge [left] node {$\wro_x$} (t2x);
				\path (t1se) edge [right] node {$\wro_y$} (t3x);
			\end{tikzpicture}  
			
		}
		\caption{History $\hist_{11}$.}
		\label{fig:ser-non-optimal:11}
	\end{subfigure}
	\hspace{.3cm}
	\centering
		\begin{subfigure}[b]{.11\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (0, 0) {\begin{tabular}{l} $\init$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (0, -1.8) {\begin{tabular}{l} 
						$\wrt{z}{1}$ \\ $\rd{x}$ \\ $\wrt{y}{1}$ \\ \ldots
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, -4.5) {\begin{tabular}{l} 
						$\wrt{z}{2}$ \\ $\rd{y}$ \\ \pgfsetfillopacity{0.3}$\wrt{x}{2}$ \\ \ldots
				\end{tabular}};		
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1sw);
				\path (t1.south east) -- (t1.south) coordinate[pos=0.67] (t1se);
				\path (t2.north east) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t3.north west) -- (t3.north) coordinate[pos=0.67] (t3x);
				
				%\path (t3x) edge [above] node[yshift=8,xshift=0] {$\wro_x$} (t2.north east);
				\path (t1.south) edge [left] node {$\wro_x$} (t2.north);
				\path (t2.south) edge [left] node {$\wro_y$} (t3.north);
			\end{tikzpicture}  
%			\hspace{2mm}
%			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
%				semithick, transform shape]
%				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (0, 0) {\begin{tabular}{l} $\init$ \end{tabular}};
%				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (0, -1.8) {\begin{tabular}{l} 
%						$\wrt{z}{2}$ \\ $\rd{y}$ \\ $\wrt{x}{2}$ 
%				\end{tabular}};
%				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, -4) {\begin{tabular}{l} 
%						$\wrt{z}{1}$ \\ $\rd{x}$ \\ \pgfsetfillopacity{0.3}$\wrt{y}{1}$ 
%				\end{tabular}};		
%				
%				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1sw);
%				\path (t1.south east) -- (t1.south) coordinate[pos=0.67] (t1se);
%				\path (t2.north east) -- (t2.north) coordinate[pos=0.67] (t2x);
%				\path (t3.north west) -- (t3.north) coordinate[pos=0.67] (t3x);
%				
%				%\path (t3x) edge [above] node[yshift=8,xshift=0] {$\wro_x$} (t2.north east);
%				\path (t1.south) edge [left] node {$\wro_y$} (t2.north);
%				\path (t2.south) edge [left] node {$\wro_x$} (t3.north);
%			\end{tikzpicture}  			
		}
		\caption{History $\hist_{12}=\hist_{21}$.}
		\label{fig:ser-non-optimal:12}
	\end{subfigure}
	\hspace{.5cm}
	\centering
		\begin{subfigure}[b]{.25\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-1.5, -0.25) {\begin{tabular}{l} $\init$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3, -2) {\begin{tabular}{l} 
						$\wrt{z}{1}$ \\ $\rd{x}$ \\ $\wrt{y}{1}$ \\ \ldots
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, -2) {\begin{tabular}{l} 
						$\wrt{z}{2}$ \\ $\rd{y}$ \\ \pgfsetfillopacity{0.3}$\wrt{x}{2}$ \\ \ldots
				\end{tabular}};		
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1sw);
				\path (t1.south east) -- (t1.south) coordinate[pos=0.67] (t1se);
				\path (t2.north east) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t3.north west) -- (t3.north) coordinate[pos=0.67] (t3x);
				
				%\path (t3x) edge [above] node[yshift=8,xshift=0] {$\wro_x$} (t2.north east);
				\path (t1sw) edge [left] node {$\wro_x$} (t2x);
				\path (t1se) edge [right] node {$\wro_y$} (t3x);
			\end{tikzpicture}  			
		}
		\caption{History $\hist_{12}'=\hist_{21}'$.}
		\label{fig:ser-non-optimal:22}
	\end{subfigure}
	\hspace{.5cm}
	\centering
	\begin{subfigure}[b]{.25\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-1.5, -0.25) {\begin{tabular}{l} $\init$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3, -2) {\begin{tabular}{l} 
						$\wrt{z}{1}$ \\ $\rd{x}$ \\ $\wrt{y}{1}$ \\ \ldots
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, -2) {\begin{tabular}{l} 
						$\wrt{z}{2}$ \\ $\rd{y}$ \\ $\wrt{x}{2}$ \\ \ldots
				\end{tabular}};		
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1sw);
				\path (t1.south east) -- (t1.south) coordinate[pos=0.67] (t1se);
				\path (t2.north east) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t3.north west) -- (t3.north) coordinate[pos=0.67] (t3x);
				
				%\path (t3x) edge [above] node[yshift=8,xshift=0] {$\wro_x$} (t2.north east);
				\path (t1sw) edge [left] node {$\wro_x$} (t2x);
				\path (t1se) edge [right] node {$\wro_y$} (t3x);
			\end{tikzpicture}  
		}
		\caption{History $\hist$.}
		\label{fig:ser-non-optimal:221}
	\end{subfigure}
\vspace{-2mm}
	\caption{A program and some partial histories. Events in grey are not yet added to the history. For $\hist_{12}$ and $\hist$, the number of events that follow $\ewrt{y,1}$ and $\ewrt{x,2}$ is not important (we use black $\ldots$  to signify that).}
	\label{fig:ser-non-optimal}
\vspace{-5mm}
\end{figure}

\begin{theorem}\label{th:impos}
If $I$ is \textit{Snapshot Isolation} or \textit{Serializability}, there exists no $\textsc{explore}$ algorithm that is $I$-sound, $I$-complete, and strongly optimal.
\end{theorem}
\begin{proof}
We consider the program in Figure~\ref{fig:ser-non-optimal:prog}, and show that any concrete instance of the $\textsc{explore}$ function in Algorithm~\ref{algorithm:algo-class} \emph{can not be both} $I$-complete and strongly optimal. This program contains two transactions, where only the first 3 instructions in each transaction are important.
We show that if $\textsc{explore}$ is $I$-complete, then it will necessarily be called recursively on a history $\hist$ like in Figure~\ref{fig:ser-non-optimal:221} which does not satisfy $I$, thereby violating strong optimality. In the history $\hist$, both \textit{Snapshot Isolation} and \textit{Serializability} forbid the two reads reading initial values while the writes following them are also executed (committed).

Assuming that the function $\genericNext$ is not itself blocking (which would violate strong optimality), the $\textsc{explore}$ will be called recursively on \emph{exactly one} of the four histories in Figure~\ref{fig:ser-non-optimal:1} and Figure~\ref{fig:ser-non-optimal:2}, depending on which of the two reads is returned first by $\genericNext$ and the order defined by $\genericNext$ between the writes. 
We will continue our discussion with the history $\hist_1$ on the top of Figure~\ref{fig:ser-non-optimal:1} and the history $\hist_2$ on the left of Figure~\ref{fig:ser-non-optimal:2}. The other cases are similar (symmetric). 
% \emph{on only one of the two histories} $\hist_1$ in Figure~\ref{fig:ser-non-optimal:1} and $\hist_2$ in Figure~\ref{fig:ser-non-optimal:2}, depending on the order defined by $\genericNext$ between $\ewrt{y,1}$ and $\ewrt{z,2}$ ($\ewrt{z,2}$ is returned by $\genericNext$ before $\ewrt{y,1}$ in $\hist_1$ and vice-versa in $\hist_2$).
%We are actually assuming that $\genericNext$ prioritizes the transaction on the left in Figure~\ref{fig:ser-non-optimal:prog}, but this is without loss of generality because the program is symmetric. 

From $\hist_1$, $\textsc{explore}$ can be called recursively either on $\hist_{11}$ in Figure~\ref{fig:ser-non-optimal:11}, or on $\hist_{12}$ and $\hist_{12}'$ in Figure~\ref{fig:ser-non-optimal:12} and Figure~\ref{fig:ser-non-optimal:22}, depending on the order defined by $\genericNext$ between $\erd{y}$ and $\ewrt{y,1}$ ($\erd{y}$ is returned by $\genericNext$ before $\ewrt{y,1}$ in $\hist_{11}$ and vice-versa in $\hist_{12}$ and $\hist_{12}'$). The histories $\hist_{12}$ and $\hist_{12}'$ differ in the read-from associated to $\erd{y}$, and exploring at least $\hist_{12}'$ is the best scenario towards ensuring $I$-completeness. 
% the latter histories differ in the read-from associated to $\erd{y}$). 
%Being called recursively on both $\hist_{12}$ and $\hist_{12}'$ is the best case scenario towards ensuring $I$-completeness. 
If $\textsc{explore}$ is called recursively only on $\hist_{12}$, then $I$-completeness is violated because $\hist_{12}$ and any extension does not enable any re-ordering, and the history where $\erd{x}$ reads from $\ewrt{x,2}$ will never be explored. Indeed, the two transactions in $\hist_{12}$ are related by $\wro$ and events can be re-ordered earlier only together with their $(\so\cup\wro)^*$ predecessors. From histories $\hist_{11}$ and $\hist_{12}'$, $\textsc{explore}$ will necessarily be called recursively on a history $\hist$ like in Figure~\ref{fig:ser-non-optimal:221} 
%(the events that follow $\ewrt{y,1}$ and $\ewrt{x,2}$ are not important) 
which does not satisfy $I$, thereby violating strong optimality.

From $\hist_2$, $\textsc{explore}$ can be called recursively on $\hist_{21}$ in Figure~\ref{fig:ser-non-optimal:12} and $\hist_{21}'$ in Figure~\ref{fig:ser-non-optimal:22}. As explained above for $\hist_{12}=\hist_{21}$, being called recursively only on $\hist_{21}$ violates $I$-completeness, while being called recursively on $\hist_{21}' = \hist_{12}'$ leads to an inconsistent history, thereby violating strong optimality.
\end{proof}

%As $\mathcal{P}$ is symmetric and every computed partial execution have at most one pending transaction, we can assume, without loss of generality, the oracle order where $T_1$ precedes $T_2$. In this setting, when $A$ execute the read event $r_1 \coloneqq a \gets \rd{x}$, it will only be able to read from $\init$. After completing $T_1$, it executes the read-event $r_2 \coloneqq b \gets \rd{x}$ from $T_2$. One one hand, if $r_2$ reads from $T_1$, then we obtain a consistent history that can be extended to a total consistent one, $h$. However, from $h$ we cannot swap any two transactions as $T_2$ depends on $T_1$, which also depends on $\init$. On the other hand, if $r_2$ reads from $\init$ we will obtain a history $h'$ that leads to a deadlock (figure \ref{fig:ser-non-optimal:c}) and cannot be swapped before $T_2$'s completion; otherwise we would obtain a partial history $h''$ with two pending transaction. To sum up, algorithm \ref{algorithm:optimal-instantiated} is incomplete for $\SI$ and $\SER$.
%
%This show that our proposal is not flexible enough to satisfy the constraints that new models may require. Therefore, we want to analyze what properties shall we weak for still obtaining a $\mathcal{M}$-sound, complete and optimal while employing polynomial memory; for $\SI$ and $\SER$ models. Let's suppose then that there exists such an algorithm $A \in \mathcal{S}_{\mathcal{M}}$ and see how it behaves under the same program $\mathcal{P}$. As $A$ is complete, whenever a $\iread$ event $r$ reading from some $\iwrite$ $w$ does not lead to an inconsistency, it will explore that possible history (the algorithm cannot deduce in advance if a dead-lock/inconsistency will appear later on). In particular, a consistent extension of the history shown in \ref{fig:ser-non-optimal:b} will be computed with either $\wrt{y}{1}$ or $\wrt{x}{2}$ in it. Without loss of generality, let's assume $w_2 \coloneqq \wrt{x}{2} \not \in h$. By definition of $\genericNext$ function, $a = \genericNext(h) \in h$, and as stated in lines \ref{algorithm:algo-class:exploreRead}, \ref{algorithm:algo-class:exploreStd}, the history $h \bullet a$ is an extension of $h$ that will always be explored. Moreover, as $A$ is $\mathcal{M}$-sound, $\texttt{N}(h')$ cannot return $w_2$ as $\lnot \ \textsc{IsConsistent}_{\mathcal{M}}(h' \bullet w_2)$ for any extension $h'$ of $h$. Therefore, there is a history $h'$ that extends $h$ where all events but those in $T_2$ $\po$-after $w_2$ will be executed. In conclusion, $\texttt{N}(h') = \bot$ but $h'$ is not total, so it must be a blocking execution. That contradicts $A$ is an optimal algorithm.


%Let's suppose on the contrary that such algorithm $A$ exists. As $A$ is complete, whenever a $\iread$ event $r$ reading from some $\iwrite$ $w$ does not lead to an inconsistency, it will explore that possible history. In particular, a consistent extension of the history shown in \ref{fig:ser-non-optimal:b} will be computed  with either $\wrt{y}{1}$ or $\wrt{x}{2}$ in it. Without loss of generality, let's assume $w_x \coloneqq \wrt{x}{2} \not \in h$. \textcolor{red}{Shall I develop this a bit more? how?}. As $A$ is weakly optimal, for every $a = \texttt{N}(h)$, $a \not\in h $ (otherwise $A$ will compute $h$ and $h \bullet a = h$); and as stated in lines \ref{algorithm:algo-class:exploreRead}, \ref{algorithm:algo-class:exploreStd}, the history $h \bullet a$ will always be explored. Moreover, as $A$ is $\mathcal{M}$-sound, $\texttt{N}(h')$ cannot return $w_x$ as $\lnot \ \textsc{IsConsistent}_{\mathcal{M}}(h' \bullet w_x)$, for any history $h'$ extending $h$. Therefore, there is an extension $h'$ of $h$ where all events but those in $T_2$ $\po$ after $w_x$ will be executed. In conclusion, $\texttt{N}(h') = \bot$ but $h'$ is not total, so it must be a blocking execution. That contradicts $A$ is an optimal algorithm.

%\begin{theorem}
%There is no algorithm in $\mathcal{S}_{\mathcal{M}} \cap \mathcal{O}^n_{\mathcal{M}}$, $n$ in $\mathbb{N}$, for neither SI nor SER.
%\label{theorem:si-ser-bad-models}
%\begin{comment}
%\begin{proof}
%
%\textcolor{red}{
%During this proof let's call $\mathcal{P}$ to the program depicted in \ref{fig:ser-non-optimal:a}. Let's suppose on the contrary that such algorithm $A$ exists. As $A$ is complete, whenever a $\iread$ event $r$ reading from some $\iwrite$ $w$ does not lead to an inconsistency, it will explore that possible history. In particular, a consistent extension of the history shown in \ref{fig:ser-non-optimal:b} will be computed  with either $\wrt{y}{1}$ or $\wrt{x}{2}$ in it. Without loss of generality, let's assume $w_x \coloneqq \wrt{x}{2} \not \in h$. \textcolor{red}{Shall I develop this a bit more? how?}. As $A$ is weakly optimal, for every $a = \texttt{N}(h)$, $a \not\in h $ (otherwise $A$ will compute $h$ and $h \bullet a = h$); and as stated in lines \ref{algorithm:algo-class:exploreRead}, \ref{algorithm:algo-class:exploreStd}, the history $h \bullet a$ will always be explored. Moreover, as $A$ is $\mathcal{M}$-sound, $\texttt{N}(h')$ cannot return $w_x$ as $\lnot \ \textsc{IsConsistent}_{\mathcal{M}}(h' \bullet w_x)$, for any history $h'$ extending $h$. Therefore, there is an extension $h'$ of $h$ where all events but those in $T_2$ $\po$ after $w_x$ will be executed. In conclusion, $\texttt{N}(h') = \bot$ but $h'$ is not total, so it must be a blocking execution. That contradicts $A$ is an optimal algorithm.
%}

%\underline{$S_{\mathcal{M}} \cap \mathcal{L}^1_{\mathcal{M}} = \emptyset$}. 

%Let's suppose on the contrary that such algorithm $A$ exists. As $A$ is in $\mathcal{L}^1_{\mathcal{M}}$ and $\mathcal{P}$ is symmetric, with out loss of generality we can assume $A$ execute first $T_1$ and then $T_2$. Then, it will execute the read event $r_1 \coloneqq a \gets \rd{x}$, which can only read from $\init$. After $T_1$, it executes the first event of $T_2$: $r_2 \coloneqq b \gets \rd{x}$. If $r_2$ reads from $T_1$, then we obtain a consistent history that can be extended to a total consistent one, $h$. However, from $h$ we cannot swap any two transactions as $T_2$ depends on $T_1$, which also depends on $\init$. On the other hand, if $r_2$ reads from $\init$, we will obtain a history $h'$ that leads to a deadlock and cannot be swapped before $T_2$'s completion; otherwise $A$ would have two pending transaction. Therefore, $A$ would only explore exactly one execution, so it is incomplete. This contradicts $A$ is in $\mathcal{L}^1_{\mathcal{M}}$.

%from this history, there %only has two transactions, $A$ can either execute the first or the second transaction at a time. As $A$ is complete and the history depicted in \ref{fig:ser-non-optimal:b} is consistent, there is an execution $h$ extending that history
%As after executing any event, $A$ has no information on the future events' availability, it will explore any possible consistent history. 

%\textcolor{red}{The first case is due to the non-$\wro \cup \so$-maximality of SI, SER (second example we discussed). The second one is the example when there is only one branch computed (first example we discussed).}
%\end{proof}
%\end{comment}
%\end{theorem}
%
%In particular, the program in figure \ref{fig:ser-non-optimal} shows that both $\SI$ and $\SER$ are actually not causally-extensible. Nevertheless, we present a swapping-based $\mathcal{M}$-sound, complete, weakly optimal algorithm employing polynomial memory based on \ref{algorithm:optimal-instantiated}:

Given the negative result in Theorem~\ref{th:impos}, for an isolation level $I\in\{SI,SER\}$, we define an implementation of $\textsc{explore}$ that ensures optimality instead of strong optimality, along with soundness, completeness, and polynomial space bound. Therefore, let $\textsc{explore-ce}(I_0)$ be an instance of $\textsc{explore-ce}$ parametrized by $I_0\in \{\RC,\RA,\CC\}$. We define an implementation of $\textsc{explore}$ for $I$, denoted by $\textsc{explore-ce}^*(I_0,I)$, which is exactly $\textsc{explore-ce}(I_0)$ except that 
% extension of any instance of $\textsc{explore-ce}$ parametrized by a prefix-closed and causally-extensible isolation level $I$ which is weaker than SI, which is only optimal and not strongly optimal.
% that for isolation levels $I$ like SI and SER has the same guarantees except that it is only optimal and not strongly optimal.
%any $\textsc{explore-ce}$ parametrized isolation level $I$, which 
instead of $\genericEvaluate(\hist) ::= true$, it uses 
\begin{cframed}[pinegreen]
	\begin{equation*}
		\begin{array}{ccc}
			\genericEvaluate(\hist) & \coloneqq & \hist \mbox{ satisfies }I
		\end{array}
	\end{equation*}
\end{cframed}
$\textsc{explore-ce}^*(I_0,I)$ enumerates exactly the same histories as $\textsc{explore-ce}(I_0)$ except that it outputs only histories consistent with $I$. The following is a direct consequence of Theorem~\ref{th:corr} because the set of histories admitted by a program under $I\in\{SI,SER\}$ is a subset of the set of histories admitted under $I_0\in \{\RC,\RA,\CC\}$.

\begin{corollary}
For any $I_0\in \{\RC,\RA,\CC\}$ and $I\in\{SI,SER\}$, $\textsc{explore-ce}^*(I_0,I)$ is $I$-sound, $I$-complete, optimal, and polynomial space.
\end{corollary}

Note that the corollary above extends to any isolation level $I_0$ which is prefix closed and causally extensible and any isolation level $I$ which is stronger than $I_0$.

%\textcolor{red}{Discuss the exponential total branches ditched}
%The reason why theorem \ref{theorem:si-ser-bad-models} holds for $\SI$ and $\SER$ but not for the rest of isolation levels described in \ref{fig:consistency_defs} is due to the lack of causal-extensibility. Nevertheless, weakening

% Under any of them the event $\wrt{x}{2}$ would always be eligible to be added to the aforementioned history $h$, and therefore any final dead-lock would be reached.

