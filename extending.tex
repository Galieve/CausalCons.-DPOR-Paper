%!TEX root = main.tex
\subsection{Extending Histories According to An Oracle Order}\label{ssec:extensions}

The function $\genericNext$ generating events that represent database accesses is parametrized by an \emph{arbitrary but fixed} order between the transactions in the program called \callout{oracle order}. 
%The version here presented employs as parameter the program to analyze along with a total order called \callout{oracle order} between its transactions. 
This order, denoted as $<_{\ora}$ and trivially extensible to events in a history, has to respect the order between transactions in the same session of the program. 
% order of the program (i.e. if $T \ [\so] \ T'$ then $T \leq_{\ora} T'$); forbidding executions any real processor would produce. This order will be constant during the whole algorithm's execution. 

$\genericNext$ returns a new event of the transaction that is not already completed and that is \emph{minimal} according to $<_{\ora}$. In more detail, if $j,e,\gamma$ is the output of $\genericNext(\prog, \hist_<, \locals)$, then either:
\begin{itemize}
	\item the last transaction log $t$ of session $j$ (w.r.t. $\so$) in $\hist$ is pending, and $t$ is the smallest among pending transaction logs in $\hist$ w.r.t. $<_{\ora}$ 
	%(we assume a straightforward extension of the oracle order between transactions in the program to transaction logs in a history of the program),
	\item $\hist$ contains no pending transaction logs and the next transaction of sessions $j$ is the smallest among not yet started transactions in the program.
\end{itemize}

%In addition, we assume the algorithm maintains a total order between the events in every history, called \callout{algorithm order} and denoted as $\leq_h$, as well as a function $\nextEvent$ that given a non-total history $h$ returns the next event to be added. In a nutshell, it returns the minimal event according to $\ora$ that is not in $h$, prioritizing those events in pending transactions. Formally:
%
%\begin{cframed}[pinegreen]
%	\begin{equation*}
%		\begin{array}{ccc}
%			\nextEvent(h) & \coloneqq & 
%			\left\{
%			\begin{array}{cc}
%				\min_{\ora}\{e \in \mathcal{E} \ | \ e \not\in h\} \cup \{\bot\} & \text{if } \not\exists T \text{ s.t. } \textsc{pending}_h(T) \\
%				\min_{\ora}\{e \in\mathcal{E} \setminus h \ | \ e \in \textsc{pending}_h(T) \} & \text{otherwise}
%			\end{array}
%			\right.
%		\end{array}
%	\end{equation*}
%\end{cframed}

%if there is an incomplete transaction, $\nextEvent(h)$ is the minimal event $e$ according to $\ora$ that is not in $h$ but $\ibegin(\tr(e)) \in h$.

%During this section we will present several approaches for finding a deterministic transactional model checker and we will show why STMC is the best among them. Every approach would be, in some particular sense, incremental; starting from an empty history and ``enlarging'' it, adding in each step new events and/or relations between them. For any fixed program, we will assume that no transaction enable/disable any other and that they are totally ordered by some relation $\ora$ called \textit{oracle order} that respects $\so$ (i.e. if $T \ [\so] \ T'$ then $T \ [\ora] \ T'$). Therefore, combining $\ora$ and $\po$ we can also say that the oracle order also enforces a total order between the events.

This implementation of $\genericNext$ is deterministic and it prioritizes the completion of pending transactions. The latter is useful to maintain the invariant that any history explored by the algorithm has at most one pending transaction. Preserving this invariant requires that the histories given as input to $\genericNext$ also have at most one pending transaction. This is discussed further when explaining the process of re-ordering events in Section~\ref{subsection:SwappingHistories}.
%Thanks to this function, we will be able to extend any history $h = \langle E, \so, \wro \rangle$ in a deterministic way. Moreover, by its definition, we observe that $\nextEvent$ always propose to complete pending transactions before starting new ones. Therefore, it is a reasonable candidate as $\genericNext$ function in a algorithm \ref{algorithm:algo-class} instance.

\begin{figure}[H]
	\centering
	\begin{subfigure}[b]{.32\textwidth}
		\begin{adjustbox}{max width=\textwidth}
			\begin{tabular}{c||c}
				\begin{lstlisting}[xleftmargin=5mm,basicstyle=\ttfamily\scriptsize,escapeinside={(*}{*)}, tabsize=1]
begin;
a = read((*x*));
if(a == 3){
	write((*$y$*),1);
}
commit
begin;
b = read((*x*));
c = read((*y*));
commit
				\end{lstlisting} &
				\begin{lstlisting}[xleftmargin=5mm,basicstyle=\ttfamily\scriptsize,escapeinside={(*}{*)}, tabsize=1]
begin;
d = read((*x*));
write((*$x$*),3);
commit
				\end{lstlisting} 
			\end{tabular} 
		\end{adjustbox}
		
		
		\caption{Program.}
		\label{fig:oracle-order:prog}
	\end{subfigure}
\centering
\begin{subfigure}[b]{.31\textwidth}
	\resizebox{\textwidth}{!}{
		\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
			semithick, transform shape]
			\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3.5, 0) {\begin{tabular}{l} 
					\init
			\end{tabular}};
			
			\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_1$}] (t2) at (-3.5, -2) {
				\begin{tabular}{l}
					$\rd{x}$\\
					{\pgfsetfillopacity{0.3}$\wrt{y}{1}$}						
			\end{tabular}};
			
			\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_3$}] (t3) at (0, 0) {
				\begin{tabular}{l}
					$\rd{x}$ \\
					$\wrt{x}{3}$
			\end{tabular}};
			
			\node[draw, rounded corners=2mm,outer sep=0, opacity=0.3, label={[font=\small]50:$t_2$}] (t4) at (0, -2) {
				\begin{tabular}{l} 
					 $\rd{x}$ \\
					 $\rd{y}$
			\end{tabular}};
			
			\path (t1) edge[left] node[yshift=0,xshift=0] {$\ora$} (t2);
			\path (t4) edge[left] node[yshift=0,xshift=0] {$\ora$} (t3);
			\path (t1) edge[above] node[yshift=0,xshift=0] {$\wro$} (t3);
						
			\path (t2.north east) -- (t2.east) coordinate[pos=0.67] (t2or);
			\path (t2.south east) -- (t2.east) coordinate[pos=0.67] (t2so);
			\path (t4.south west) -- (t4.west) coordinate[pos=0.67] (t4so);
			\path (t4.north west) -- (t4.west) coordinate[pos=0.67] (t4or);
			
			
			\path (t2or) edge[above] node[yshift=0,xshift=0] {$\ora$} (t4or);
			\path [opacity=0.3](t2so) edge[below] node[yshift=0,xshift=0] {$\so$} (t4so);
			
			
			\path (t3.south west) edge[left] node[yshift=0,xshift=0] {$\wro$} (t2.north east);
			
			%\path (t3or) edge[left] node[yshift=0,xshift=0] {$\ora$} (t4or);
			%\path (t3so) edge[right] node[yshift=0,xshift=0] {$\wro$} (t4so);
		\end{tikzpicture}  
		
	}
	\caption{An incomplete history.}
	\label{fig:oracle_order:a}
\end{subfigure}
	\hspace{.5cm}
	\centering
	\begin{subfigure}[b]{.31\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3.5, 0) {\begin{tabular}{l} 
						\init
				\end{tabular}};
				
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_1$}] (t2) at (-3.5, -2) {
					\begin{tabular}{l}
						$\rd{x}$\\
						$\wrt{y}{1}$					
				\end{tabular}};
				
				\node[draw, rounded corners=2mm,outer sep=0, label={[font=\small]50:$t_3$}] (t3) at (0, 0) {
					\begin{tabular}{l}
						$\rd{x}$ \\
						$\wrt{x}{3}$
				\end{tabular}};
				
				\node[draw, rounded corners=2mm,outer sep=0, opacity=0.3, label={[font=\small]50:$t_2$}] (t4) at (0, -2) {
					\begin{tabular}{l} 
						$\rd{x}$ \\
						$\rd{y}$
				\end{tabular}};
				
				\path (t1) edge[left] node[yshift=0,xshift=0] {$\ora$} (t2);
				\path (t4) edge[left] node[yshift=0,xshift=0] {$\ora$} (t3);
				\path (t1) edge[above] node[yshift=0,xshift=0] {$\wro$} (t3);
				
				\path (t2.north east) -- (t2.east) coordinate[pos=0.67] (t2or);
				\path (t2.south east) -- (t2.east) coordinate[pos=0.67] (t2so);
				\path (t4.south west) -- (t4.west) coordinate[pos=0.67] (t4so);
				\path (t4.north west) -- (t4.west) coordinate[pos=0.67] (t4or);
				
				
				\path (t2or) edge[above] node[yshift=0,xshift=0] {$\ora$} (t4or);
				\path [opacity=0.3](t2so) edge[below] node[yshift=0,xshift=0] {$\so$} (t4so);
				
				
				\path (t3.south west) edge[left] node[yshift=0,xshift=0] {$\wro$} (t2.north east);
				
				%\path (t3or) edge[left] node[yshift=0,xshift=0] {$\ora$} (t4or);
				%\path (t3so) edge[right] node[yshift=0,xshift=0] {$\wro$} (t4so);
			\end{tikzpicture}  
			
		}
		\caption{An extension.} % of a history using $\nextEvent$ function.}
		\label{fig:oracle_order:b}
	\end{subfigure}
	\caption{A program (a), a history $h$ (b), and an extension of $h$ with an event returned by $\genericNext$ (c). 
%	and two histories, where $h$ is the former and the latter is $h \oplus \nextEvent(h)$. 
	The $\so$-edges from $\init$ to the other transactions are omitted for legibility. 
	We use edges labeled by $\ora$ to represent the $<_{\ora}$ order.
	Events in gray are not yet added to the history.}
	\label{fig:oracle_order}
	
\end{figure}

For example, consider the program in Figure~\ref{fig:oracle-order:prog} and the history $h$ as depicted in Figure~\ref{fig:oracle_order:a}. Since the local state of the pending transaction on the left stores $3$ to the local variable $a$ (as a result of the previous $\erd{x}$ event) and the Boolean condition in \texttt{if} holds, $\genericNext$ will return the event $\wrt{y}{1}$ when called with history $\hist$.
% history $h$ in Figure~\ref{fig:oracle_order:a}, as in the local state of the first thread, $d = 2$, the boolean condition in transaction $t_1$ is satisfied and the second database call ($\wrt{y}{1}$) can be executed. Thus, $\nextEvent(h)$ would return the event $\wrt{y}{1}$ as its transaction is pending.

\begin{figure}[H]

\begin{subfigure}[b]{.24\textwidth}
%	\resizebox{\textwidth}{!}{
		\begin{adjustbox}{max width=\textwidth}
	\begin{tabular}{c||c}
		\begin{lstlisting}[xleftmargin=5mm,basicstyle=\ttfamily\scriptsize,escapeinside={(*}{*)}, tabsize=1]
begin;
write((*$x$*),1);
write((*$y$*),1);
commit
		\end{lstlisting} & %a = read((*x*));
		\begin{lstlisting}[xleftmargin=5mm,basicstyle=\ttfamily\scriptsize,escapeinside={(*}{*)}, tabsize=1]
begin;
a = read((*y*));
commit
begin;
b = read((*x*));
commit
		\end{lstlisting} 
	\end{tabular} 
\end{adjustbox}
%		}
\caption{Program.}
\label{fig:add_read:prog}
\end{subfigure}
\hspace{-2mm}
	\begin{subfigure}[b]{.253\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3, 0) {\begin{tabular}{l} $\init$\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3, -1.75) {\begin{tabular}{l} $\wrt{x}{1}$ \\ $\wrt{y}{1}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {\begin{tabular}{l} $\rd{y}$\end{tabular}};
				\node[draw, rounded corners=2mm, outer sep=0, opacity=0.3] (t4) at (0, -1.75) {
					\begin{tabular}{l} 
					$\rd{x}$
				\end{tabular}};
				
				\path (t1.south east) -- (t1.east) coordinate[pos=0.67] (t1y);
				\path (t1.north east) -- (t1.east) coordinate[pos=0.67] (t1x);
				\path (t3.south west) -- (t3.west) coordinate[pos=0.67] (t3y);
				\path (t3.north west) -- (t3.west) coordinate[pos=0.67] (t3x);
				%\path (t1x) edge[above] node[yshift=0,xshift=0] {$\wro_x$} (t3x);
				\path (t1.east) edge[above] node[yshift=0,xshift=0] {$\so$} (t3.west);
				\path (t1.south) edge[above] node[left] {$\so$} (t2.north);
				\path (t2.north east) edge[above] node [yshift=2,xshift=0] {$\wro_y$} (t3.south west);
				\path[opacity=0.3] (t3.south) edge[below] node [right]{$\so$} (t4.north); %[yshift=0,xshift=0]
			\end{tikzpicture}  
			
		}
		\caption{Current history.}
		\label{fig:add_read:a}
	\end{subfigure}
	%\hspace{.5cm}
	\centering
	\begin{subfigure}[b]{.253\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3, 0) {\begin{tabular}{l} $\init$\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3, -1.75) {\begin{tabular}{l} $\wrt{x}{1}$ \\ $\wrt{y}{1}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {\begin{tabular}{l} $\rd{y}$\end{tabular}};
				\node[draw, rounded corners=2mm, outer sep=0] (t4) at (0, -1.75) {
					\begin{tabular}{l} 
						$\rd{x}$
				\end{tabular}};
				
				\path (t1.south east) -- (t1.east) coordinate[pos=0.67] (t1y);
				\path (t1.north east) -- (t1.east) coordinate[pos=0.67] (t1x);
				\path (t3.south west) -- (t3.west) coordinate[pos=0.67] (t3y);
				\path (t3.north west) -- (t3.west) coordinate[pos=0.67] (t3x);
				%\path (t1x) edge[above] node[yshift=0,xshift=0] {$\wro_x$} (t3x);
				\path (t1.east) edge[above] node[yshift=0,xshift=0] {$\so$} (t3.west);
				\path (t1.south) edge[above] node[left] {$\so$} (t2.north);
				\path (t2.north east) edge[above] node [yshift=2,xshift=0] {$\wro_y$} (t3.south west);
				\path (t3.south) edge[below] node [right]{$\so$} (t4.north);
				\path (t2.east) edge[below] node [above]{$\wro_x$} (t4.west); %[yshift=0,xshift=0] %[yshift=0,xshift=0]
			\end{tikzpicture}  
			
		}
		\caption{One extension.}
		\label{fig:add_read:b}
	\end{subfigure}%\hspace{.5cm}
	\centering
	\begin{subfigure}[b]{.25\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3, 0) {\begin{tabular}{l} $\init$\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3, -1.75) {\begin{tabular}{l} $\wrt{x}{1}$ \\ $\wrt{y}{1}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {\begin{tabular}{l} $\rd{y}$\end{tabular}};
				\node[draw, rounded corners=2mm, outer sep=0] (t4) at (0, -1.75) {
					\begin{tabular}{l} 
						$\rd{x}$
				\end{tabular}};
				
				\path (t1.south east) -- (t1.east) coordinate[pos=0.67] (t1y);
				\path (t1.north east) -- (t1.east) coordinate[pos=0.67] (t1x);
				\path (t3.south west) -- (t3.west) coordinate[pos=0.67] (t3y);
				\path (t3.north west) -- (t3.west) coordinate[pos=0.67] (t3x);
				%\path (t1x) edge[above] node[yshift=0,xshift=0] {$\wro_x$} (t3x);
				\path (t1.east) edge[above] node[yshift=0,xshift=0] {$\so$} (t3.west);
				\path (t1.south) edge[above] node[left] {$\so$} (t2.north);
				\path (t2.north east) edge[above] node [yshift=2,xshift=0] {$\wro_y$} (t3.south west);
				\path (t3.south) edge[below] node [right]{$\so$} (t4.north);
				\path (t1.south east) edge[below] node [yshift=6,xshift=-12]{$\wro_x$} (t4.north west); %[yshift=0,xshift=0] %[yshift=0,xshift=0]
			\end{tikzpicture}  
			
		}
		\caption{Another extension.}
		\label{fig:add_read:c}
	\end{subfigure}\hspace{.5cm}
	\caption{Extensions of a history by adding a $\iread$ event. Events in gray are not yet added to the history.}
	\label{fig:add_read}
	%\vspace{-3mm}
\end{figure}

%TODO REDO THE ABOVE FIGURE IN THE SPIRIT OF FIGURE \ref{fig:dead_branch}. MODIFY THE EXAMPLE SO ONE OF THE TWO CHOICES DOES NOT SATISFY SOME ISOLATION LEVEL, TO EXEMPLIFY THE USE OF $\genericValidWrites$.

If the event returned by $\genericNext$ is not a read event, then it is simply added to the current history, as the maximal element of the order $<$ (cf. the definition of $\oplus_j$ on ordered histories). If it is a read event, then adding this event may result in multiple histories depending on the associated $\wro$ dependency. 
%
%The incremental process of obtaining histories with more information it is called \textit{extension}. In essence, given a history $h$ and an event $e \not\in h$, all possible graphs using these two elements must be constructed. 
%If $e$'s type is $\ibegin$ or $\iend$, there is only one possible way to extend it by the operator $\bullet$'s definition. When $e$ is a $\iread$, however, we have to explore multiple histories, one per $\wro$-dependency that can be generated with a $\iwrite$ event $w\in h$ and $e$. That is, all histories $h \bullet_w e$. 
For example, in Figure \ref{fig:add_read}, extending the history in Figure \ref{fig:add_read:a} with the $\erd{x}$ event could result in two different histories, pictured in Figure \ref{fig:add_read:b} and \ref{fig:add_read:c}, depending on the write with whom this read event is associated by $\wro$. However, under $\CC$, the latter history is inconsistent.
%we can obtain two different histories depending on the $\wro$ dependency created (figures \ref{fig:add_read:b} and \ref{fig:add_read:c}). In both three cases, we declare the algorithm order for this new history $h'$ by simply juxtaposing $e$ to all the previous ones: $\leq_{h'} = \leq_h \cup \{\langle e', e \rangle \ | \  e' \in h\}$.
The function $\genericValidWrites$ limits the choices to those that preserve consistency with the intended isolation level $I$, i.e.,
%However, we will only select those $\iwrite$ event such that the extended history $h \bullet_w e$ is consistent, as described by function $\validWrites$; which will eventually play the $\genericValidWrites$'s role in our algorithm.  

\begin{cframed}[pinegreen]
	\begin{equation*}
		\begin{array}{ccc}
			\genericValidWrites(h, e) & \coloneqq & \{w \ | \ h \oplus_j e \oplus \wro(w,e) \mbox{ satisfies }I\}
		\end{array}
	\end{equation*}
\end{cframed}


%Finally, we declare the function $\evaluate$ that detects when a history is total.
%
%\begin{cframed}[pinegreen]
%	\begin{equation*}
%		\begin{array}{ccc}
%			\evaluate(h) & \coloneqq & \nextEvent(h) = \bot
%		\end{array}
%	\end{equation*}
%\end{cframed}

%Nevertheless, we will guarantee in both cases that every possible incomplete history will be $\so$-bounded, i.e. if $e \ [\so \cup \po]^+ e'$ and $e' \in h$ then $e \in h$; in order to easily avoid eventual inconsistencies. Therefore, the global order $\ora$ presented in Figure~\ref{fig:oracle_order:a} restrict in a simple but effective way the duplicity between histories: the order events are being added don't cause \textit{per se} redundancies.%In the second case, to avoid randomness, we will have a function $\nextEvent$ that given a history $h$ returns the first event $e$ according to $\ora$ that is not in $h$; to obtain the new history $h' = h \bullet e$. For example, given the history in Figure~\ref{fig:oracle_order:b}, the function $\nextEvent$ would return the event $\ibegin$ associated to the second transaction. Nevertheless, we will guarantee in both cases that every possible incomplete history will be $\so$-bounded, i.e. if $e \ [\so \cup \po]^+ e'$ and $e' \in h$ then $e \in h$; in order to easily avoid eventual inconsistencies. Therefore, the global order $\ora$ presented in Figure~\ref{fig:oracle_order:a} restrict in a simple but effective way the duplicity between histories: the order events are being added don't cause \textit{per se} redundancies.

%Thanks to $\so$ and $\ora$ order, we will be able to track every possible history, and therefore, have control over the amount of graphs generated. 

%Incomplete histories can be extended in two ways: either with the extern help of some guide that select beforehand which events and in which order will be executed or without it. For managing the second case in a deterministic way, we will have a function $\nextEvent$ that maps every $h$ to some event that is not in $h$ for obtaining a new history $h' = h \bullet e$. If $h$ is incomplete and $l = \last{h}$ then $e$ is the minimum event in $\po_T$ bigger than $l$; but if not, $e$ is the $\ibegin$ event belonging to the minimal transaction $T$ according to $\ora$ that is not in $h$. For example, the function $\nextEvent$ would the history in Figure~\ref{fig:oracle_order:b} to the event $d \gets \rd{y}$. Clearly, any coherent history can be extended using $\nextEvent$ function resulting in a coherent history (as $\ora$ extends $\so$, it only suffices defining the $\wro$ edge that an eventual free $\iread$ would require).
%Nevertheless, we will guarantee in both cases that every possible incomplete history will be $\so$-bounded, i.e. if $e \ [\so \cup \po]^+ e'$ and $e' \in h$ then $e \in h$; in order to easily avoid eventual inconsistencies. Therefore, the global order $\ora$ presented in Figure~\ref{fig:oracle_order:a} restrict in a simple but effective way the duplicity between histories: the order events are being added don't cause \textit{per se} redundancies.%In the second case, to avoid randomness, we will have a function $\nextEvent$ that given a history $h$ returns the first event $e$ according to $\ora$ that is not in $h$; to obtain the new history $h' = h \bullet e$. For example, given the history in Figure~\ref{fig:oracle_order:b}, the function $\nextEvent$ would return the event $\ibegin$ associated to the second transaction. Nevertheless, we will guarantee in both cases that every possible incomplete history will be $\so$-bounded, i.e. if $e \ [\so \cup \po]^+ e'$ and $e' \in h$ then $e \in h$; in order to easily avoid eventual inconsistencies. Therefore, the global order $\ora$ presented in Figure~\ref{fig:oracle_order:a} restrict in a simple but effective way the duplicity between histories: the order events are being added don't cause \textit{per se} redundancies.