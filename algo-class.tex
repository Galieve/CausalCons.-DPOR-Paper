%!TEX root = main.tex
\section{Swapping-Based Model Checking Algorithms}\label{sec:algs}

%\subsection{Definition}

%The above-mentioned classes are, notwithstanding, quite dense and contain lots of algorithms we are not interested in (as non-DPOR algorithms for example). In particular, our work focuses on the collection of algorithms defined by the schema \ref{algorithm:algo-class} for some functions $\genericNext, \genericEvaluate, \genericValidWrites, \genericCompute, \genericProtocol, \genericSwap$ to be defined. %Thanks to this approach we will show the existence of some sound and complete algorithms and easily prove some of their properties.

We define a class of stateless model checking algorithms for enumerating executions of a given transactional program, that we call \emph{swapping-based algorithms}. Section~\ref{sec:CC-algorithm} will describe a concrete instance that applies to isolation levels that are prefix-closed and causally extensible.

These algorithms are defined by the recursive function \textsc{explore} listed in Algorithm~\ref{algorithm:algo-class}. The function \textsc{explore} receives as input a program $\prog$, an \emph{ordered history} $\hist_<$, which is a pair $(\hist,<)$ of a history and a total order $<$ on all the events in $\hist$, and a mapping $\locals$ that associates each event $e$ in $\hist$ with the valuation of local variables in the transaction of $e$ ($\trans{h}{e}$) just before executing $e$. For an ordered history $(\hist,<)$ with $\hist=\tup{T, \so, \wro}$, we assume that $<$ is consistent with $\po$, $\so$, and $\wro$, i.e., $e_1 < e_2$ if $(\trans{h}{e_1},\trans{h}{e_2})\in (\so\cup\wro)^+$ or $(e_1,e_2)\in\po$. Initially, the ordered history and the mapping $\locals$ are empty.

\begin{algorithm}[t]
	\caption{\textsc{explore} algorithm}
	\begin{algorithmic}[1]
	\Function{\textsc{explore}}{$\prog$, $\hist_<$, $\locals$}
		\State $j, e, \gamma \gets  \genericNext(\prog, \hist_<, \locals)$
		
		\State $\locals' \gets \locals[e\mapsto \gamma]$
		\If{$e = \bot$ and $\genericEvaluate(h)$}
%			\If{$\genericEvaluate(\prog, h, \locals)$}
			\State \textbf{output} $h$, $\locals'$
%			\EndIf
		%\State $\textbf{\genericEvaluate}(h)$
%		\State \Return
		\ElsIf{$\mathit{type}(e) = \iread$}
		
		\ForAll{$w \in \genericValidWrites(h,e)$} %\writeVar{w}{x}
		\State $h'_< \gets h_< \oplus_j e \oplus \wro(w,e)$
		
		\State $\textsc{explore}(\prog, h'_< , \locals')$
		\label{algorithm:algo-class:exploreRead}
		\State $\textsc{exploreSwaps}(\prog, h'_< , \locals')$
		\EndFor
		\Else %If{$\genericEvaluate(h\bullet e)$}
			\State $h'_< \gets h_< \oplus_j e$
			\State $\textsc{explore}(\prog, h'_<,\locals')$
			\State $\textsc{exploreSwaps}(\prog, h'_< , \locals')$
		\label{algorithm:algo-class:exploreStd}
%		\Else
%			\State \Return
		\EndIf
	\EndFunction
	\Function{\textsc{exploreSwaps}}{$\prog$, $\hist_<$, $\locals$}
%		\State $e \gets \laste(\hist_<)$
		\State $l \gets \genericCompute(h_<)$		
		\ForAll{$(\alpha, \beta) \in l$}
		\If{$\genericProtocol(h_<, \alpha, \beta)$}
		\State $\textsc{explore}(\prog,\genericSwap(h_<, \alpha, \beta, \locals))$	
		
		\EndIf
		\EndFor
	\EndFunction
		
	\end{algorithmic}
	\label{algorithm:algo-class}
	%\caption{Generic method for exploring every possible history $h$ of a program $\mathcal{P}$ running under a database with $\mathcal{M}$ as isolation level.}
\end{algorithm}

The function \textsc{explore} starts by calling $\genericNext$ to obtain an event representing the next database access in some pending transaction of the input program, or a $\eend$ event for completing a transaction, or a $\ebegin$ event for a new transaction. This event is associated to some session $j$. For example, a typical implementation of $\genericNext$ would choose one of the pending transactions (in some session $j$), execute all local instructions until the next database instruction in that transaction (applying the transition rules \textsc{if-true}, \textsc{if-false}, and \textsc{local} from Figure~\ref{fig:op:sem:baseline}) and return the event $e$ corresponding to that database instruction and the current local state $\gamma$. $\genericNext$ may also return $\bot$ if the program finished.
%or if the history $\hist$ is not consistent with the intended isolation level. 
If $\genericNext$ returns $\bot$, then the function $\genericEvaluate$ can be used to filter executions that satisfy the intended isolation level before outputting the current history and local states. 
%the history satisfies the consistency requirements
%The function $\genericEvaluate$ is used to select the cases in which the program finished and the history satisfies all the consistency requirements before outputting the current history (and local states).
%Algorithm \ref{algorithm:algo-class} explores systematically the space of histories, selecting a new event $e$ to be added to some history $h$ if possible, thanks to the function $\genericNext$ called \textit{next}. If it wasn't possible, it is due to $h$ being either a total execution or an undesirable one; both behaviors discriminated via \textit{evaluating} $h$ with the $\genericEvaluate$ function. 

Otherwise, the event $e$ is added to the ordered history $h_<$. If $e$ is a read event, then $\genericValidWrites$ computes a set of write events $w$ in the current history that are valid for $e$, i.e., adding the event $e$ along with the $\wro$ dependency $(w,e)$ leads to a history that still satisfies the intended isolation level.
% along with a $\wro$ dependency selected via $\genericValidWrites$ if it is a read. linking a \textit{valid} $\iwrite$ event with the new $\iread$ event (valid means satisfying consistency w.r.t. the intended isolation level). 
Concerning notations, we extend $\oplus_j$ to ordered histories in a straightforward manner: $(\hist,<) \oplus_j e$ is the ordered history $(\hist \oplus_j e, < \cdot\ e)$ where $<\cdot\ e$ means that $e$ is added as the maximal element of the total order $<$. Also, $\hist \oplus_j (e,\ebegin)$ is the same as $\hist \oplus_j \tup{\tr,\{\tup{e,\ebegin}\},\emptyset}$ for a fresh transaction id $t$. Moreover, we simplify the notation and write $h\oplus\wro(w,e)$ for $w$ a write event and $e$ a read event instead of $h\oplus\wro(\trans{h}{w},e)$.

%TODO GIVE AN EXAMPLE OF SUCCESSIVE EXTENSIONS OF A HISTORY USING NEXT TO GET NEXT EVENTS. ADD SOME LOCAL INSTRUCTIONS AS WELL TO EXPLAIN LOCAL STATES.
Moreover, once an event is added to the current history, the algorithm may explore other histories obtained by re-ordering events in the current one. Such re-orderings are required for completeness. As explained above, new read events can only read from writes executed in the past which limits the set of explored histories to the scheduling imposed by $\genericNext$. Without re-orderings, write events scheduled later by $\genericNext$ cannot be read by read events executed in the past, even-though this may be permitted by the intended isolation level. 
%TODO GIVE AN EXAMPLE (PROGRAM, CURRENT HISTORY, NEXT RETURNING A WRITE, THERE EXISTS A HISTORY WHERE THE WRITE CAN BE READ BY A READ IN THE CURRENT HISTORY).

The function $\textsc{exploreSwaps}$ calls $\genericCompute$ to compute pairs of sequences of events $\alpha, \beta$ that should be re-ordered; $\alpha$ and $\beta$ are \emph{contiguous and disjoint} subsequences of the total order $<$, and $\alpha$ should end before $\beta$ (since $\beta$ will be re-ordered before $\alpha$). Typically, $\alpha$ should contain a read event $r$ and $\beta$ a write event $w$ such that re-ordering the two enables $r$ to read from $w$.  Avoiding redundancy, i.e., exploring the same history multiple times, may require restricting the application of such re-orderings. This is modeled by the Boolean condition called $\genericProtocol$. If this condition holds, the new explored histories are computed by the function $\genericSwap$. This function returns local states as well, which are necessary for continuing the exploration. 
%A typical implementation of this function would return ordered histories where the events in $\beta$ and their $\so$ or $\wro$ dependencies 
%%($(\so\cup\wro)^*$ predecessors) 
%are ordered before the events in $\alpha$. 
We assume that $\genericSwap((\hist,<), \alpha, \beta, \locals)$ returns pairs $((\hist',<'),\locals')$ such that 
\begin{itemize}
	\item $\hist'$ contains the events in $\alpha$ and $\beta$,
	\item $\hist'$ without the events in $\alpha$ is a prefix of $\hist$, and
	\item for every read event $r$ in $\alpha$, if it reads from different writes in $\hist$ and $\hist'$ (i.e., the writes $w_1$ and $w_2$ associated with $r$ by the $\wro$ relations of $\hist$ and $\hist'$, respectively, are different) then it is the last event in its transaction log (w.r.t. $\po$).
\end{itemize}
The first condition makes the re-ordering ``meaningful'', while the last two conditions ensure that the history $\hist'$ is feasible (i.e., it can be obtained using the operational semantics defined in Section~\ref{ssec:semantics}) and restricts the possible changes of the $\wro$ relation to events in $\alpha$. Concerning the events in $\beta$, they imply that $\hist'$ contains all their $(\po\cup\so\cup\wro)^*$ predecessors. The last condition is required since changing the value returned by a read access may disable later events in the same transaction. % (they need to be re-executed).

%\begin{itemize}
%	\item $\hist'$ contains a subset of the events/transactions in $\hist$ that includes all the events in $(\hist,<)$ up to and including all events in $\alpha$ w.r.t. $<$, all the events in $\beta$, and all the events which are $(\so\cup\wro)^*$ predecessors of events in $\beta$,
%	\item $<'$ coincides with $<$ until the last event before $\alpha$, and it orders all events in $\beta$ before events in $\alpha$,
%	\item the $\so$ relation of $\hist'$ equals the $\so$ relation of $\hist$ projected on transactions in $\hist'$,
%	\item the $\wro$ relation of $\hist'$ equals the $\wro$ relation of $\hist$ projected on events/transactions in $\hist'$ except its last event w.r.t. $<'$,
%	\item $\locals'$ is the projection of $\locals$ on events in $\hist'$.
%\end{itemize}

%TODO GIVE AN EXAMPLE. A HISTORY, $\alpha$ and $\beta$ such that $\beta$ has some $(\so\cup\wro)^*$ predecessors. EXPLAIN WHY ONLY THE WR OF THE LAST EVENT CAN CHANGE (OTHERWISE, WE DON'T KNOW IF EVENTS REMAIN ENABLED, LOCAL STATES MAY CHANGE.

%some collection of events $\alpha, \beta$ that may needed to be reordered. Every events' rescheduling possibly lead to a different execution, so for controlling which reorderings we are shall explore, we enforce a \textit{reordering protocol} (function $\genericProtocol$). In the affirmative case, the new histories would be generated via $\genericSwap$, \textit{swapping} $\beta$ and all their dependencies before $\alpha$. However, the reader shall take into account that this high-level description of algorithm \ref{algorithm:algo-class} may not be satisfied for some $\textsc{explore}$'s instance.
%may not be satisfied for some $\textsc{explore}$'s instances.

%determines so, we will also explore the history generated via $\genericSwap$; where $\alpha$ and $\beta$ have different relative order. It is assumed that \ref{algorithm:algo-class} maintains a total order between events in the history that doesn't contradict $\so$. Finally, let's take into account that this high-level description of the algorithm may not be satisfied for some $\textsc{explore}$'s instances. %\textcolor{red}{Here I wanted to guide the reader of what does this algorithm mean; but remarking that of course, if you add a weird function, then all what I said is a lie (for example if the swap history does not swap at all).}

%TODO WE ASSUME THAT THE NEXT FUNCTION IS INDEPENDENT OF THE FUTURE. IT IS A NON-DETERMINISTIC FUNCTION, BUT ITS SET OF POSSIBLE RESULTS IS THE SAME IF THE PROGRAM HAS MORE/DIFFERENT THINGS AFTER THE NEXT DATABASE ACCESS.

%\begin{definition}
%The \callout{swapping-based algorithm's class} for the memory model $\mathcal{M}$, $\mathcal{S}_{\mathcal{M}}$, is the minimal collection containing all algorithms $A$ that can be described as algorithm \ref{algorithm:algo-class}'s instances: $ \textsc{explore}(\genericNext, \genericEvaluate, \genericValidWrites, \genericCompute, \genericProtocol, \genericSwap)$; where $\genericNext, \genericEvaluate , \genericValidWrites, \genericCompute, \genericProtocol, \genericSwap$ are functions defined as follows: 
%\begin{itemize}
%	\item $\genericNext: \mathcal{H}_\mathcal{P} \to \mathcal{E}_\mathcal{P}$, where for every $h \in \mathcal{H}_{\mathcal{P}}$, $\genericNext(h) \not\in h$ and for every event $e$ s.t. $e \ [\so] \ \genericNext(h)$, $e \in h$, %\textcolor{red}{redundant with weakly optimal; it may be helpful to the reader}
%	\item $\genericEvaluate: \mathcal{H}_\mathcal{P} \to \{0, 1\}$, %which determines if an execution is total or not,
%	\item $\genericValidWrites: \mathcal{H}_\mathcal{P} \times \mathcal{E}_\mathcal{P} \to \mathcal{P}(\mathcal{E}_\mathcal{P})$, %\textcolor{red}{this is for determine when computing a total inconsistent history shall be taken into account}
%	\item $\genericCompute: \mathcal{H}^<_\mathcal{P} \to \mathcal{E}_\mathcal{P}^* \times \mathcal{E}_\mathcal{P}^*$, where for every history $h$, $\genericCompute(h) = (\alpha, \beta)$, $\alpha \cap \beta = \emptyset$ and for every $(e, e') \in \alpha \times \beta$, $e <_h e'$.
%	\item $\genericProtocol: \mathcal{H}^<_\mathcal{P} \times \mathcal{E}_\mathcal{P}^* \times \mathcal{E}_\mathcal{P}^* \to \{0,1\}$, %\textcolor{red}{shall we impose the protocol to only be true in only one history for each class? not needed though...}
%	\item $\genericSwap: \mathcal{H}^<_\mathcal{P} \times \mathcal{E}_\mathcal{P}^* \times \mathcal{E}_\mathcal{P}^* \to \mathcal{H}^<_\mathcal{P}$, where for every $h, \alpha, \beta$, we have $\genericSwap(h \bullet e, \alpha, \beta) = h'$, $\alpha, \beta \in h'$, for every $(e, e') \in \alpha \times \beta \implies e >_{h'} e'$ and there exists some $(e, e') \in (\alpha, \beta)$ s.t. $\tr(e') \ [\wro] \ \tr(e)$.
%\end{itemize}
%\end{definition}

A concrete implementation of \textsc{explore} is called:
\begin{itemize}
	\item \emph{$I$-sound} if it outputs only histories in $\histOf[I]{\prog}$ for every program $\prog$,
	\item \emph{$I$-complete} if it outputs every history in $\histOf[I]{\prog}$ for every program $\prog$,
	\item \emph{optimal} if it does not output the same history twice,
	\item \emph{strongly optimal} if it is optimal and never engages in fruitless explorations, i.e., \textsc{explore} is never called (recursively) on a history $\hist$ that does not satisfy $I$, and every call to \textsc{explore} results in an output or another recursive call to \textsc{explore}.
\end{itemize}


%\subsection{Other}
%
%\begin{definition}
%Given an algorithm $A$ and a model $\mathcal{M}$, we say:
%\begin{itemize}
%	%\item $A$ is \callout{blind} if for every program $\mathcal{P}$ and every history $h$, $A$ cannot determine the evaluation of any instruction $i$ not yet executed (i.e. $i \in \mathcal{P} \setminus h$),
%	%\item $A$ is \callout{weakly $\mathcal{M}$-sound} if for every program $\mathcal{P}$, every total history $h$ computed by $A$ is $\mathcal{M}$-consistent,
%	%\item $A$ is \callout{$\mathcal{M}$-sound} if for every program $\mathcal{P}$, every history $h$, partial or not, computed by $A$ is $\mathcal{M}$-consistent,
%	\item $A$ is \callout{$\mathcal{M}$-sound} if for every program $\mathcal{P}$, every total history $h$ computed by $A$ is $\mathcal{M}$-consistent,
%	\item $A$ is \callout{complete} if for every program $\mathcal{P}$ it computes every possible execution,
%	\item $A$ is \callout{weakly optimal} if for every program $\mathcal{P}$ it computes every execution at most once,
%	\item $A$ is \callout{optimal} if for every program $\mathcal{P}$ it is weakly optimal and it does not compute blocking executions (i.e. partial histories that cannot be completed), 
%\end{itemize}
%\end{definition}
%
%
%\begin{definition}
%The algorithm's class $\mathcal{O}^n_{\mathcal{M}}$ is defined as the minimal collection containing all algorithms $\mathcal{M}$-sound, complete and optimal that employ polynomial memory and allows at most $n$ pending transactions. %We also denote $\mathcal{O}_{\mathcal{M}} = \bigcup\limits_{n \in \mathbb{N}} \mathcal{O}^n_{\mathcal{M}}$.
%\end{definition}
%
%
%\begin{definition}
%The algorithm's class $\mathcal{W}^n_{\mathcal{M}}$ is defined as the minimal collection containing all algorithms $\mathcal{M}$-sound, complete and weakly optimal that employ polynomial memory and allows at most $n$ pending transactions. 
%\end{definition}
%
%\textcolor{red}{TODO: change this to not be a class...}
%
%%\textcolor{red}{We need the three classes for the following: RA/RC/CC/PRE algorithms belong to $O^1$, our PRE+SER/PRE+SI version is $W^1$, for SER we cannot obtaining it in $O^n$ for any $n$ nor in $L^1$ and in RA/RC/CC/PRE $O^1 = L^1$. Moreover, if we allow the subindex there, we can talk about future work allowing multiple pending transactions (it may be reasonable to prove that there is an algorithm for SER in $L^n$) and indicate Viktor's algorithm is not in $L^n$ for any $n$ as it employs exp memory. If we don't want to be that expressive, we can only talk about weakly optimal and then proof that under RA/RC/CC/PRE with our algorithms there is no blocking branches as an extra feature thanks to the models; but I thought it may be clearer to distribute it in this way.}
%
%
%TODO
%The swapping-based algorithms have been already studied in the literature as for example \textcolor{red}{cite Viktor's algorithm}, which belongs to $\mathcal{S}_{SC}$; where SC in this case is the axiomatic representation of sequential consistency memory model. \textcolor{red}{cite SC.}