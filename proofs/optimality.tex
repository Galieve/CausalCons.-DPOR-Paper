\subsection{Optimality}

For proving optimality we are gonna exploit two properties already studied for completeness: $\ora$-respectfulness and the canonical order. Then, as algorithm \textsc{explore-ce} is sound and complete, we will prove that any computable path leading to a consistent history is the one computed in the completeness' proof.

%\textcolor{red}{I have this new proof shorter than the initial idea but I do not know if it doesn't have typos. TODO: reread it!}

\begin{comment}
\begin{lemma}
\label{lemma:swapped-elements-remain-1step}
Let $h$ a reachable history and $e$ a swapped event in $h$. If $h'$ is an immediate successor of $h$, $e \in h'$, $\swapped{h'}{e}$ and $h'.\wro(e) = h.\wro(e)$.
\begin{proof}
Firstly, if $a = \nextEvent(h)$, every history $h' = h \bullet a$ (or $h' = h \bullet_w a$ if $a$ is a $\iread$ event for some $\iwrite$ $w$) contains $e$ and $e$ is swapped; $h'$ is an extension of $h$ and $\leq_{h'} \restriction_h \equiv \leq_h$. Let's suppose then $h' = \swap(h, r, w)$ for some $r, w \in h$ s.t. $\protocol(h, r, w)$ holds. By algorithm \textcolor{red}{cite algo}'s definition, we know that if $e \in h \setminus h'$, $\isMaximallyAdded{h}{e}$ holds, so $\lnot(\swapped{h}{e})$. In particular, $e \in h'$. Moreover, if there would exist a transaction $T$ such that $T <_{\ora} \tr(e)$, $T <_h \tr(e)$ and $\tr(h'.\wro(e)) \ [\so \cup \wro]^* \ T$, by the $\ora$-respectfulness of $h$ (lemma \ref{lemma:reachable-or-respectful}) we would obtain that $e$ is no swapped in $h$; which contradicts the hypothesis. Therefore, as in every reachable history $h.\wro(e) \leq_h e$, we deduce $\swapped{h'}{e}$. 
%applying or-resp to T <_or \tr(e) and disctiminating cases depending if e <h r or not. (in case we need to expand this)
\end{proof}
\end{lemma}

\begin{corollary}
\label{corollary:swapped-elements-remain}
For every reachable history $h$ and every event $e$ s.t. $\swapped{h}{e}$, if a history $h'$ is reached from $h$, $\swapped{h'}{e}$
\begin{proof}
By induction on the steps' number on a computable path from $h$ to $h'$, applying lemma \ref{lemma:swapped-elements-remain-1step} in the inductive step.
\end{proof}
\end{corollary}

\begin{lemma}
For every $\iread$ event $r$, $\iwrite$ $w$, $w \leq_{\ora} r$ there is no pair of reachable histories $h, h'$ s.t. $h.\wro(r) \neq w$, $h'.\wro(r) = w$ and $h'$ is computed from $h$.
\begin{proof}
Let's suppose such a pair of histories exist a

\end{proof}
\end{lemma}

\end{comment}

\begin{theorem}
	Algorithm \textup{\textsc{explore-ce}} is strongly optimal.
	\begin{proof}
		As the model is causal-extensible, any algorithm optimal is also strongly optimal. Let us prove that for every reachable history there is only a computable path that leads to it from $\emptyset$.
		Let's suppose there exists a history $h$ that is reached $p_1$, $p_2$ by two computable paths. By lemma \ref{proposition:orders-coincide}, we know that $\leq_h \equiv \leq^h$. However, $\leq^h$ is an order that does not depend on the computable path that leads to $h$; so neither does $\leq_h$.  Therefore, we can assume without loss of generality that $h$ is a history with minimal value of $\xi(h) =|\{e \in h \ | \swapped{h}{e}\}|$ and in case of tie, that is minimal with respect $|h|$; values independent of the computable path that leads to $h$. 
		
		We can also assume without loss of generality that the predecessor of $h$ in $p_1$ is $h_1 = \prev{h}$, and $h_2$ is the predecessor of $h$ in $p_2$. If we prove $h_1$ and $h_2$ are identical, $p_1$ and $p_2$ have to also be identical and therefore, the algorithm would be optimal. Firstly, if $\last{h}$ is not a swapped $\iread$ event, by the definition of $\nextEvent$ function $h_2 = h \setminus \last{h} = h_1$. On the contrary, let's suppose $r = \last{h}$ is a swapped event that reads from a transaction $t$. Because $\swapped{h}{r}$ holds, from $h_2$ to $h$ it has to have happened a swap between $r$ and $w$. But by corollary \ref{corollary:prev-swap-identity}, $h = \swap(h_1, r, w)$, so $h_1 \restriction_{h \setminus r} = h_2 \restriction_{h \setminus r}$. As $h_1, h_2$ are both $\ora$-respectful, $e \in h_1 \setminus h \iff e \in h_2 \setminus h$. Finally, as $\genericProtocol(h_i, r, w)$ holds for $i \in \{1,2\}$, for every $\iread$ event $e$ in $h_1 \cap h_2$ there exists a transaction $t_e$ s.t. $\wro(e, t_e)$ for both histories.
	\end{proof}
\end{theorem}