\section{Implementation}

We implemented algorithm $\textsc{explore-ce}$ and $\textsc{explore-ce}^*$ on top of Java PathFinder (JPF) \textcolor{red}{cite JPF}, a verification tool for Java concurrent programs. We admit as input a Java program that (1) can be parsed and executed by JPF and (2) employs the API according to the specifications. Our tool is parametric in the isolation levels employed.

The API provided allow $\ibegin, \iwrite, \iread$ and $\icommit$ operations. Thanks to this API, we can maintain the database state separately from JPF's internal state and update the current history in each database call. We do not rely on any concrete database but store the information as a collection of String, one per write API call executed; along with the $\so$, $\wro$-dependencies between the events associated to them. Any time there is a need to connect data from the local state to the database one or viceversa we copy and store the concrete String value from one state to the other. %Altogether, we are able to simulate from simple variables to actual tables provided the client has proper methods to transform from one to the other representative.

Our implementation is compatible with JPF's standards, as both algorithm are instances of DFSearch; a JPF for DFS exploring algorithms. Moreover, we built consistency checkers based on the algorithm's presented in \textcolor{red}{Ranadeep and Enea's paper} for different isolation levels to ensure database's soundness. 

However, for performance issues, we developed an iterative version of the algorithm \ref{algorithm:algo-class} for reducing the actual memory consumption. We employ an annotated stack of database states that is modified in each $\textsc{explore-ce}$ call; and we consider the algorithm works with list instead of simply sets.
At every step where we execute a $\iread$, we annotate which $\iwrite$ event is reading from and  when the state pops from the stack, we change the $\wro$-dependency. Analogously, at every step we produce a swap, we annotate which tuple given by $\compute$ we used in the swap for selecting a different tuple when the state is popped out. % In addition, as JPF is not designed for supporting database operations, we developed an API that simulates every database instruction. operations, but they have been proved expressive enough both during our experiments and in real time applications. We admit any Java program that (1) can be parsed and executed by JPF and (2) has an equivalent translation into a program written with the syntax defined in Figure~\ref{fig:syntax}.

