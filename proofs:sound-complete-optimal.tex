\section{Proof of the algorithms}
\label{sec:proofs-algorithm}

\textcolor{red}{Introduction}


\textcolor{red}{The proofs are written when no local state was added, as otherwise I have to assign to every history a local state (randomness is allowed? in that case not one but a set of local states...)}
%As we are going to prove the completeness of algorithm \ref{algorithm:stmc}, the first property we want to prove is its equivalence with its recursive counterpart, \ref{algorithm:stmc2}. Here, line \ref{algorithm:stmc:inner_loop} refers to 
\input{soundness}


\input{completeness}

\subsection{Optimality}

\textcolor{red}{I have this new proof shorter than the initial idea but I do not know if it doesn't have typos. TODO: reread it!}

\begin{comment}
\begin{lemma}
\label{lemma:swapped-elements-remain-1step}
Let $h$ a reachable history and $e$ a swapped event in $h$. If $h'$ is an immediate successor of $h$, $e \in h'$, $\swapped{h'}{e}$ and $h'.\wro(e) = h.\wro(e)$.
\begin{proof}
Firstly, if $a = \nextEvent(h)$, every history $h' = h \bullet a$ (or $h' = h \bullet_w a$ if $a$ is a $\iread$ event for some $\iwrite$ $w$) contains $e$ and $e$ is swapped; $h'$ is an extension of $h$ and $\leq_{h'} \restriction_h \equiv \leq_h$. Let's suppose then $h' = \swap(h, r, w)$ for some $r, w \in h$ s.t. $\protocol(h, r, w)$ holds. By algorithm \textcolor{red}{cite algo}'s definition, we know that if $e \in h \setminus h'$, $\isMaximallyAdded{h}{e}$ holds, so $\lnot(\swapped{h}{e})$. In particular, $e \in h'$. Moreover, if there would exist a transaction $T$ such that $T <_{\ora} \tr(e)$, $T <_h \tr(e)$ and $\tr(h'.\wro(e)) \ [\so \cup \wro]^* \ T$, by the $\ora$-respectfulness of $h$ (lemma \ref{lemma:reachable-or-respectful}) we would obtain that $e$ is no swapped in $h$; which contradicts the hypothesis. Therefore, as in every reachable history $h.\wro(e) \leq_h e$, we deduce $\swapped{h'}{e}$. 
%applying or-resp to T <_or \tr(e) and disctiminating cases depending if e <h r or not. (in case we need to expand this)
\end{proof}
\end{lemma}

\begin{corollary}
\label{corollary:swapped-elements-remain}
For every reachable history $h$ and every event $e$ s.t. $\swapped{h}{e}$, if a history $h'$ is reached from $h$, $\swapped{h'}{e}$
\begin{proof}
By induction on the steps' number on a computable path from $h$ to $h'$, applying lemma \ref{lemma:swapped-elements-remain-1step} in the inductive step.
\end{proof}
\end{corollary}

\begin{lemma}
For every $\iread$ event $r$, $\iwrite$ $w$, $w \leq_{\ora} r$ there is no pair of reachable histories $h, h'$ s.t. $h.\wro(r) \neq w$, $h'.\wro(r) = w$ and $h'$ is computed from $h$.
\begin{proof}
Let's suppose such a pair of histories exist a

\end{proof}
\end{lemma}

\end{comment}

\begin{lemma}
\label{lemma:soundness-isswappable}
For every two histories $h_1, h_2$ with the same set of events and $\iread$ event $r$, if $\protocol(h_i, r, w)$ holds for $i \in \{1,2\}$ and $\leq_{h_1} \equiv \leq_{h_2}$, for every $\iread$ event $r'$ s.t. $r \leq_{h_i} r'$ and $ \lnot(\tr(r') \ [\so \cup \wro]^+ \tr(w))$ we have $h_1.\wro(r') = h_2.\wro(r')$.
\begin{proof}
As for every $i \in \{1,2\}$ $\protocol(h_1, r, w)$ holds, so does it $\isMaximallyAdded{h_i}{r'}$. Therefore, as $\leq_{h_1} \equiv \leq_{h_2}$, $h_1.\wro(r') = h_2.\wro(r')$.
\end{proof}
\end{lemma}

\begin{theorem}
Algorithm \ref{algorithm:optimal-instantiated} is optimal.
\begin{proof}
As the model is causal-extensible, any algorithm weakly optimal is also optimal. Let us prove that for every reachable history there is only a computable path that leads to it from $\emptyset$. By lemma \ref{proposition:orders-coincide}, we know that for every reachable history $h$, $\leq_h \equiv \leq^h$. However, $\leq^h$ is an order that does not depend on the computable path that leads to $h$; so neither does $\leq_h$. Let's suppose that there exist two reachable histories $h_1, h_2$ s.t. $h_1 = \prev(h)$ and that in one step of computation produce a common history $h$. If we prove they are identical, the algorithm would be optimal. Firstly, if $\last{h}$ is not a swapped $\iread$ event, by the definition of $\nextEvent$ function $h_2 = h \setminus \last{h} = h_1$. On the contrary, let's suppose $r = \last{h}$ is a swapped event that reads from a $\iwrite$ event $w$. Because $\swapped{h}{r}$ holds, from $h_2$ to $h$ it has to have happened a swap between $r$ and $w$. But by corollary \ref{corollary:prev-swap-identity}, $h = \swap(h_1, r, w)$, so $h_1 \restriction_{h \setminus r} = h_2 \restriction_{h \setminus r}$. As $h_1, h_2$ are both $\ora$-respectful, $e \in h_1 \setminus h \iff e \in h_2 \setminus h$. Finally, as $\protocol(h_i, r, w)$ holds for $i \in \{1,2\}$, by lemma \ref{lemma:soundness-isswappable}, if $e \in h_1 \setminus h$, $h_1.\wro(e) = h_2.\wro(e)$. Therefore, $h_1 = h_2$.
\end{proof}
\end{theorem}