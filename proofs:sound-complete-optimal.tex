%!TEX root = main.tex
\section{Proof of Theorem~\ref{th:corr}}
\label{sec:proofs-algorithm}

As explained in Section~\ref{ssec:corr}, $I$-soundness, the polynomial space bound, and the part of strong completeness that refers to not engaging in fruitless explorations follow directly from definitions. In the following, we focus on $I$-completeness and then optimality.

%\textcolor{red}{Introduction}
%
%
%\textcolor{red}{The proofs are written when no local state was added, as otherwise I have to assign to every history a local state (randomness is allowed? in that case not one but a set of local states...)}
%%As we are going to prove the completeness of algorithm \ref{algorithm:stmc}, the first property we want to prove is its equivalence with its recursive counterpart, \ref{algorithm:stmc2}. Here, line \ref{algorithm:stmc:inner_loop} refers to 
%\input{soundness}


\input{completeness}

\subsection{Optimality}

%\textcolor{red}{I have this new proof shorter than the initial idea but I do not know if it doesn't have typos. TODO: reread it!}

\begin{comment}
\begin{lemma}
\label{lemma:swapped-elements-remain-1step}
Let $h$ a reachable history and $e$ a swapped event in $h$. If $h'$ is an immediate successor of $h$, $e \in h'$, $\swapped{h'}{e}$ and $h'.\wro(e) = h.\wro(e)$.
\begin{proof}
Firstly, if $a = \nextEvent(h)$, every history $h' = h \bullet a$ (or $h' = h \bullet_w a$ if $a$ is a $\iread$ event for some $\iwrite$ $w$) contains $e$ and $e$ is swapped; $h'$ is an extension of $h$ and $\leq_{h'} \restriction_h \equiv \leq_h$. Let's suppose then $h' = \swap(h, r, w)$ for some $r, w \in h$ s.t. $\protocol(h, r, w)$ holds. By algorithm \textcolor{red}{cite algo}'s definition, we know that if $e \in h \setminus h'$, $\isMaximallyAdded{h}{e}$ holds, so $\lnot(\swapped{h}{e})$. In particular, $e \in h'$. Moreover, if there would exist a transaction $T$ such that $T <_{\ora} \tr(e)$, $T <_h \tr(e)$ and $\tr(h'.\wro(e)) \ [\so \cup \wro]^* \ T$, by the $\ora$-respectfulness of $h$ (lemma \ref{lemma:reachable-or-respectful}) we would obtain that $e$ is no swapped in $h$; which contradicts the hypothesis. Therefore, as in every reachable history $h.\wro(e) \leq_h e$, we deduce $\swapped{h'}{e}$. 
%applying or-resp to T <_or \tr(e) and disctiminating cases depending if e <h r or not. (in case we need to expand this)
\end{proof}
\end{lemma}

\begin{corollary}
\label{corollary:swapped-elements-remain}
For every reachable history $h$ and every event $e$ s.t. $\swapped{h}{e}$, if a history $h'$ is reached from $h$, $\swapped{h'}{e}$
\begin{proof}
By induction on the steps' number on a computable path from $h$ to $h'$, applying lemma \ref{lemma:swapped-elements-remain-1step} in the inductive step.
\end{proof}
\end{corollary}

\begin{lemma}
For every $\iread$ event $r$, $\iwrite$ $w$, $w \leq_{\ora} r$ there is no pair of reachable histories $h, h'$ s.t. $h.\wro(r) \neq w$, $h'.\wro(r) = w$ and $h'$ is computed from $h$.
\begin{proof}
Let's suppose such a pair of histories exist a

\end{proof}
\end{lemma}

\end{comment}

\begin{corollary}
	\label{corollary:soundness-swapped}
	Let $h_p$ a reachable history and let $h$ a immediate successor of $h_p$ whose last event $r$ is a $\iread$. Then $h_< = \swap((h_p, <_{h_p}), r, t)$ if and only if $\swapped{h}{r}$ does.
\end{corollary}
\begin{proof}
\underline{$\implies$}

Let's suppose that $h_< = \swap((h_p, <_{h_p}), r, t)$ for some $t$ transaction. As the last event in $h$ is $r$ and by definition of $\swap$ function no event reads from $r$ in $h$ besides $r$, to prove $\swapped{h}{r}$ holds we just need to show that $t >_{\ora} r$. By lemma \ref{lemma:reachable-or-respectful}, $\oraRespectfulCanon{h_p}$ holds. As $r <_{h_p} t$, $\genericProtocol((h_p, <_{h_p}), r, t)$ holds and $t$ is $(\so \cup \wro)^+$-maximal, we conclude that $r <_{\ora} t$.

\underline{$\impliedby$}
Let's suppose that $h = h_p \oplus \wro(r, t)$ for some transaction $t$. Let's suppose that $r <_{\ora} t$. As $\oraRespectfulCanon{h_p}$, there exists some event $e''$ s.t. $\trans{h_p}{e''} \lor \trans{h}{r}$, $t \ [\so \cup \wro]^* \trans{h}{e''}$ and $e'' \leq r$ so $\lnot(\swapped{h}{r})$.

\end{proof}

\begin{theorem}
Algorithm \textup{\textsc{explore-ce}} is strongly optimal.
\begin{proof}
As the model is causal-extensible, any algorithm optimal is also strongly optimal. Let us prove that for every reachable history there is only a computable path that leads to it from $\emptyset$.
Let's suppose there exists a history $h$ that is reached $p_1$, $p_2$ by two computable paths. By lemma \ref{proposition:orders-coincide}, we know that $\leq_h \equiv \leq^h$. However, $\leq^h$ is an order that does not depend on the computable path that leads to $h$; so neither does $\leq_h$.  Therefore, we can assume without loss of generality that $h$ is a history with minimal value of $\xi(h) =|\{e \in h \ | \swapped{h}{e}\}|$ and in case of tie, that is minimal with respect $|h|$; values independent of the computable path that leads to $h$. 

We can also assume without loss of generality that the predecessor of $h$ in $p_1$ is $h_1 = \prev{h}$, and $h_2$ is the predecessor of $h$ in $p_2$. If we prove $h_1$ and $h_2$ are identical, $p_1$ and $p_2$ have to also be identical and therefore, the algorithm would be optimal. Firstly, if $\last{h}$ is not a swapped $\iread$ event, by the definition of $\nextEvent$ function $h_2 = h \setminus \last{h} = h_1$. On the contrary, let's suppose $r = \last{h}$ is a swapped event that reads from a transaction $t$. Because $\swapped{h}{r}$ holds, from $h_2$ to $h$ it has to have happened a swap between $r$ and $w$. But by corollary \ref{corollary:prev-swap-identity}, $h = \swap(h_1, r, w)$, so $h_1 \restriction_{h \setminus r} = h_2 \restriction_{h \setminus r}$. As $h_1, h_2$ are both $\ora$-respectful, $e \in h_1 \setminus h \iff e \in h_2 \setminus h$. Finally, as $\genericProtocol(h_i, r, w)$ holds for $i \in \{1,2\}$, for every $\iread$ event $e$ in $h_1 \cap h_2$ there exists a transaction $t_e$ s.t. $\wro(e, t_e)$ for both histories.
\end{proof}
\end{theorem}