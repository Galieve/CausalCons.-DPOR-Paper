\section{Proof of the algorithms}
\label{sec:proofs-algorithm}

\textcolor{red}{Introduction}

%As we are going to prove the completeness of algorithm \ref{algorithm:stmc}, the first property we want to prove is its equivalence with its recursive counterpart, \ref{algorithm:stmc2}. Here, line \ref{algorithm:stmc:inner_loop} refers to 
\subsection{Soundness}

\begin{theorem}
Algorithm \ref{algorithm:optimal-instantiated} is sound.
\begin{proof}
We prove this theorem by induction on the number of steps a reachable history needs in a computable path to be reached. If this number is zero, the history is $\emptyset$, which is consistent; so let us prove the inductive step, assuming that in any computable path of length at most $n$ every history is consistent. Let $h$ computed in a $n+1$ path, and let $h_p$ the immediate predecessor of $h$, which is consistent, and $a = \nextEvent(h_p)$. If $a$ is not a $\iread$ event and $h = h_p \bullet a$, by $\nextEvent$'s definition along with the model's causal-extensibility, $a$ is a $\so \cup \wro$-maximal event so $h$ is consistent. Otherwise, if $a$ is a $\iread$ event and $h = h_p \bullet_w a$ for some $\iwrite$ event $w$, by $\validWrites$'s definition we know that $h$ is consistent. Finally, if $h = \swap(h_p, r, w)$ for some events $r, w$, as $\protocol(h_p, r, w)$ is satisfied, $h$ is consistent.
\end{proof}
\end{theorem}

\input{completeness}

\subsection{Optimality}

\textcolor{red}{I have this new proof shorter than the initial idea but I do not know if it doesn't have typos. TODO: reread it!}

\begin{comment}
\begin{lemma}
\label{lemma:swapped-elements-remain-1step}
Let $h$ a reachable history and $e$ a swapped event in $h$. If $h'$ is an immediate successor of $h$, $e \in h'$, $\swapped{h'}{e}$ and $h'.\wro(e) = h.\wro(e)$.
\begin{proof}
Firstly, if $a = \nextEvent(h)$, every history $h' = h \bullet a$ (or $h' = h \bullet_w a$ if $a$ is a $\iread$ event for some $\iwrite$ $w$) contains $e$ and $e$ is swapped; $h'$ is an extension of $h$ and $\leq_{h'} \restriction_h \equiv \leq_h$. Let's suppose then $h' = \swap(h, r, w)$ for some $r, w \in h$ s.t. $\protocol(h, r, w)$ holds. By algorithm \textcolor{red}{cite algo}'s definition, we know that if $e \in h \setminus h'$, $\isMaximallyAdded{h}{e}$ holds, so $\lnot(\swapped{h}{e})$. In particular, $e \in h'$. Moreover, if there would exist a transaction $T$ such that $T <_{\ora} \tr(e)$, $T <_h \tr(e)$ and $\tr(h'.\wro(e)) \ [\so \cup \wro]^* \ T$, by the $\ora$-respectfulness of $h$ (lemma \ref{lemma:reachable-or-respectful}) we would obtain that $e$ is no swapped in $h$; which contradicts the hypothesis. Therefore, as in every reachable history $h.\wro(e) \leq_h e$, we deduce $\swapped{h'}{e}$. 
%applying or-resp to T <_or \tr(e) and disctiminating cases depending if e <h r or not. (in case we need to expand this)
\end{proof}
\end{lemma}

\begin{corollary}
\label{corollary:swapped-elements-remain}
For every reachable history $h$ and every event $e$ s.t. $\swapped{h}{e}$, if a history $h'$ is reached from $h$, $\swapped{h'}{e}$
\begin{proof}
By induction on the steps' number on a computable path from $h$ to $h'$, applying lemma \ref{lemma:swapped-elements-remain-1step} in the inductive step.
\end{proof}
\end{corollary}

\begin{lemma}
For every $\iread$ event $r$, $\iwrite$ $w$, $w \leq_{\ora} r$ there is no pair of reachable histories $h, h'$ s.t. $h.\wro(r) \neq w$, $h'.\wro(r) = w$ and $h'$ is computed from $h$.
\begin{proof}
Let's suppose such a pair of histories exist a

\end{proof}
\end{lemma}

\end{comment}

\begin{theorem}
Algorithm \ref{algorithm:optimal-instantiated} is optimal.
\begin{proof}
As the model is causal-extensible, any algorithm weakly optimal is also optimal. Let us prove that for every reachable history there is only a computable path that leads to it from $\emptyset$. By lemma \ref{proposition:orders-coincide}, we know that for every reachable history $h$, $\leq_h \equiv \leq^h$. However, $\leq^h$ is an order that does not depend on the computable path that leads to $h$; so neither does $\leq_h$. Let's suppose that there exist two reachable histories $h_1, h_2$ s.t. $h_1 = \prev(h)$ and that in one step of computation produce a common history $h$. If we prove they are identical, the algorithm would be optimal. Firstly, if $\last{h}$ is not a swapped $\iread$ event, by the definition of $\nextEvent$ function $h_2 = h \setminus \last{h} = h_1$. Therefore, let us call $r = \last{h}$ and $w = h.\wro(r)$. Because $\swapped{h}{r}$ holds, from $h_2$ to $h$ it has to have happened a swap between $r$ and $w$. But by corollary \ref{corollary:prev-swap-identity}, $h = \swap(h_1, r, w)$, so $h_1 \restriction_{h \setminus r} = h_2 \restriction_{h \setminus r}$. As $\protocol(h_i, r, w)$ holds and $h_i$ is $\ora$-respectful (for $i \in \{1,2\}$), $h_1 \setminus h = h_2 \setminus h$, and for every $\iread$ event $e$, $h_1.\wro(e) = h_2.\wro(e)$. Therefore, $h_1 = h_2$.
\end{proof}
\end{theorem}