%!TEX root = main.tex
\section{Swapping-based model checking for Prefix-Closed and Causally-Extensible Isolation Levels}
\label{sec:CC-algorithm}

%The main goal in this section is describing a deterministic algorithm for transactional model-checking under a causally-closed model $\mathcal{M}$ that obtains all possible behaviors a program may have. We present during this section a swapping-based sound, complete and optimal algorithm employing polynomial memory. In particular, we will show that our algorithm has at most one pending transaction and why this is key to guarantee the rest of the properties. For the legibility of this document, we will postpone their proofs to section \ref{sec:proofs-algorithm}.

We define a concrete implementation of $\textsc{explore}$, denoted as $\textsc{explore-ce}$, that is $I$-sound, $I$-complete, and strongly optimal for any isolation level $I$ that is prefix-closed and causally-extensible. The isolation level $I$ is a parameter of $\textsc{explore-ce}$. Moreover, the space complexity of $\textsc{explore-ce}$ is polynomial in the size of the program. An important invariant of this implementation is that it explores histories with \emph{at most one} pending transaction and this transaction is maximal w.r.t. session order. This invariant is used to avoid fruitless explorations: since $I$ is assumed to be causally-extensible, there always exists an extension of the current history with one more event that continues to satisfy $I$. 

Section~\ref{ssec:extensions} describes the implementations of $\genericNext$ and $\genericValidWrites$ used to extend a given execution, Section~\ref{subsection:SwappingHistories} describes the functions $\genericCompute$ and $\genericSwap$ used to compute re-ordered executions, and Section~\ref{ssec:optimality} describes the $\genericProtocol$ restriction on re-ordering. We assume that the function $\genericEvaluate$ is defined as simply $\genericEvaluate(\hist) ::= true$ (there is no filter before outputting). Section~\ref{ssec:corr} discusses correctness arguments while complete proofs are delegated to Appendix~\ref{sec:proofs-algorithm}.

\input{extending}

\input{swaps}

%\input{blocking-branches}

%\input{maximally-added}

\subsection{Correctness}\label{ssec:corr}

The following theorem states the correctness of the algorithm presented in this section:
\begin{theorem}\label{th:corr}
For any prefix-closed and causally extensible isolation level $I$, $\textsc{explore-ce}$ is $I$-sound, $I$-complete, strongly optimal, and polynomial space.
\end{theorem}

$I$-soundness is a direct consequence of the $\genericValidWrites$ and $\genericProtocol$ definitions which guarantee that all the histories given to recursive calls are $I$-consistent, and of the $\genericSwap$ definition which ensures to only produce feasible histories (which can be obtained using the operational semantics defined in Section~\ref{ssec:semantics}). The fact that this algorithm never engages in fruitless explorations follows easily from causal-extensibility which ensures that any current history can be extended with any event returned by $\genericNext$. Polynomial space is also quite straightforward since the \textbf{for all} loops in Algorithm~\ref{algorithm:algo-class} have a linear number of iterations: the number of iterations of the loop in $\textsc{explore}$, resp., $\textsc{exploreSwaps}$, is bounded by the number of write, resp., read, events in the current history (which is smaller than the size of the program; recall that we assume bounded programs with no loops as usual in SMC algorithms). On the other hand, the proofs of $I$-completeness and optimality are quite complex. For $I$-completeness, given a history $\hist\in \histOf[I]{\prog}$, we firstly show how to compute the order $<$ associated to $\hist$, and secondly show how to define the inverse function of $\textsc{explore}$ and $\textsc{explore-sc}$ for, exploiting a common invariant on the histories explored by the algorithm, deducing a chain of histories starting from the initial state to $\hist$ and concluding that $\hist$ is indeed outputted. For $I$-optimality, we exploit the fact that the history order can be described without referencing any computable path along with the $\genericProtocol$ restriction on re-orderings, to conclude that there is only one possible branch that lead to it. See Appendix~\ref{sec:proofs-algorithm} for more details.
%
%Strong optimality follows from causal extensibility which 
%
%. The former ensure that every extension with a new event returned by $\genericNext$ is $I$-consistent, and the latter implies that $\genericSwap$ outputs histories which are $I$-consistent because 
%
% and the definition 
%
% and causal extensibility: 
%\begin{itemize}
%	\item every history given as an input to a recursive call has at most one pending transaction and this is maximal in $(\so\cup\wro)+$, which implies that it admits an extension with any event,
%	\item and $\genericSwap$ outputs histories which modulo a last read in the pending transaction are prefixes of the input history, and therefore $I$-consistent assuming that the input one is.
%\end{itemize}
%
%As we show in Section~\ref{sec:proofs-algorithm}, the algorithm described above is $I$-sound assuming that $\genericEvaluate(\hist) ::= true$. Therefore, any history computed by applying the functions described above will satisfy the intended isolation level $I$.
%
%TODO THIS SHOULD PROBABLY BE ABOUT CORRECTNESS, STATING IT AND EXPLAINING A LITTLE BIT THE PROOFS.

%Altogether, our swapping-based algorithm can simply being defined as an instance of \ref{algorithm:algo-class}: $\textsc{explore}_{\mathcal{M}}(\nextEvent,\evaluate , \validWrites, \compute, \protocol, \swap)$. A full detailed pseudocode of this procedure can be seen as algorithm \ref{algorithm:optimal-instantiated}; with initial call $h = \emptyset$.

%\begin{algorithm}[H]
%	\caption{Optimal recursive \textsc{STMC}}
%	\begin{algorithmic}[1]
%		\InputAlgorithmic $h$: history
%		\Statex
%		\State $e \gets  \next(h)$
%		\If{$e = \bot$}
%		\If{$\evaluate(h)$}
%		\State \textbf{output} $h$
%		\EndIf
%		%\State $\textbf{\genericEvaluate}(h)$
%		\State \Return
%		\ElsIf{$\textsc{type}(e) = \iread$}
%		
%		\ForAll{$w \in \validWrites(h,e)$} %\writeVar{w}{x}
%		
%		\State $\textsc{explore}_{\mathcal{M}}(h \bullet_w e)$
%		\EndFor
%		\Else
%		\State $\textsc{explore}_{\mathcal{M}}(h \bullet e)$
%		\EndIf
%		
%		\Statex
%		
%		\ForAll{$(\alpha, \beta) \in \compute(h)$}
%		\If{$\protocol(h \bullet e, \alpha, \beta)$}
%		\State $\textsc{explore}_{\mathcal{M}}(\swap(h \bullet e, \alpha, \beta))$	
%		
%		\EndIf
%		\EndFor
%	\end{algorithmic}
%	\label{algorithm:optimal-instantiated}
%\end{algorithm}
