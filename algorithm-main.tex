%!TEX root = main.tex
\section{Swapping-based model checking for Prefix-Closed and Causally-Extensible Isolation Levels}
\label{sec:CC-algorithm}

%The main goal in this section is describing a deterministic algorithm for transactional model-checking under a causally-closed model $\mathcal{M}$ that obtains all possible behaviors a program may have. We present during this section a swapping-based sound, complete and optimal algorithm employing polynomial memory. In particular, we will show that our algorithm has at most one pending transaction and why this is key to guarantee the rest of the properties. For the legibility of this document, we will postpone their proofs to section \ref{sec:proofs-algorithm}.

We define a concrete implementation of $\textsc{explore}$ that is $I$-sound, $I$-complete, and strongly optimal for any isolation level $I$ that is prefix-closed and causally-extensible. Moreover, the space complexity of this algorithm is polynomial in the size of the program. An important invariant of this implementation is that it explores histories with \emph{at most one} pending transaction and this transaction is maximal w.r.t. session order. This invariant is used to avoid fruitless explorations: since $I$ is assumed to be causally-extensible, there always exists an extension of the current history with one more event that continues to satisfy $I$. 

Section~\ref{ssec:extensions} describes the implementations of $\genericNext$ and $\genericValidWrites$ used to extend a given execution, Section~\ref{subsection:SwappingHistories} describes the functions $\genericCompute$ and $\genericSwap$ used to compute re-ordered executions, and Section~\ref{ssec:optimality} describes the $\genericProtocol$ restriction on re-ordering. We assume that the function $\genericEvaluate$ is defined as simply $\genericEvaluate(\hist) ::= true$ (there is no filter before outputting). Section~\ref{ssec:corr} discusses correctness arguments while complete proofs are delegated to Appendix~\ref{sec:proofs-algorithm}.

\input{extending}

\input{swaps}

%\input{blocking-branches}

%\input{maximally-added}

\subsection{Correctness}\label{ssec:corr}

The following theorem states the correctness of the algorithm presented in this section:
\begin{theorem}
For any prefix-closed and causally extensible isolation level $I$ , the implementation of $\textsc{explore}$ presented in this section is $I$-sound, $I$-complete, strongly optimal, and polynomial space.
\end{theorem}

$I$-soundness follows from the definition of $\genericValidWrites$ and prefix-closure. The former ensure that every extension with a new event returned by $\genericNext$ is $I$-consistent, and the latter implies that $\genericSwap$ outputs histories which are $I$-consistent because 

 and the definition 

 and causal extensibility: 
\begin{itemize}
	\item every history given as an input to a recursive call has at most one pending transaction and this is maximal in $(\so\cup\wro)+$, which implies that it admits an extension with any event,
	\item and $\genericSwap$ outputs histories which modulo a last read in the pending transaction are prefixes of the input history, and therefore $I$-consistent assuming that the input one is.
\end{itemize}

As we show in Section~\ref{sec:proofs-algorithm}, the algorithm described above is $I$-sound assuming that $\genericEvaluate(\hist) ::= true$. Therefore, any history computed by applying the functions described above will satisfy the intended isolation level $I$.

TODO THIS SHOULD PROBABLY BE ABOUT CORRECTNESS, STATING IT AND EXPLAINING A LITTLE BIT THE PROOFS.

%Altogether, our swapping-based algorithm can simply being defined as an instance of \ref{algorithm:algo-class}: $\textsc{explore}_{\mathcal{M}}(\nextEvent,\evaluate , \validWrites, \compute, \protocol, \swap)$. A full detailed pseudocode of this procedure can be seen as algorithm \ref{algorithm:optimal-instantiated}; with initial call $h = \emptyset$.

%\begin{algorithm}[H]
%	\caption{Optimal recursive \textsc{STMC}}
%	\begin{algorithmic}[1]
%		\InputAlgorithmic $h$: history
%		\Statex
%		\State $e \gets  \next(h)$
%		\If{$e = \bot$}
%		\If{$\evaluate(h)$}
%		\State \textbf{output} $h$
%		\EndIf
%		%\State $\textbf{\genericEvaluate}(h)$
%		\State \Return
%		\ElsIf{$\textsc{type}(e) = \iread$}
%		
%		\ForAll{$w \in \validWrites(h,e)$} %\writeVar{w}{x}
%		
%		\State $\textsc{explore}_{\mathcal{M}}(h \bullet_w e)$
%		\EndFor
%		\Else
%		\State $\textsc{explore}_{\mathcal{M}}(h \bullet e)$
%		\EndIf
%		
%		\Statex
%		
%		\ForAll{$(\alpha, \beta) \in \compute(h)$}
%		\If{$\protocol(h \bullet e, \alpha, \beta)$}
%		\State $\textsc{explore}_{\mathcal{M}}(\swap(h \bullet e, \alpha, \beta))$	
%		
%		\EndIf
%		\EndFor
%	\end{algorithmic}
%	\label{algorithm:optimal-instantiated}
%\end{algorithm}
