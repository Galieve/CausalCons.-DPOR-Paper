\subsection{Extending and swapping histories}
\label{subsection:ExtendingHistories} %Provisional

The incremental process of obtaining histories with more information it is called \textit{extension}. In essence, given a history $h$ and an event $e \not\in h$, all possible graphs using these two elements must be constructed. 

If $e$'s type is $\ibegin$ or $\iend$, there is only one possible way to extend it by the operator $\bullet$'s definition. When $e$ is a $\iread$, however, we have to explore multiple histories, one per $\wro$-dependency that can be generated with a $\iwrite$ event $w\in h$ and $e$. That is, all histories $h \bullet_w e$. For example in figure \ref{fig:add_read} we can see how from the history in figure \ref{fig:add_read:a} we can obtain two different histories depending on the $\wro$ dependency created (figures \ref{fig:add_read:b} and \ref{fig:add_read:c}). In both three cases, we declare the algorithm order for this new history $h'$ by simply juxtaposing $e$ to all the previous ones: $\leq_{h'} = \leq_h \cup \{\langle e', e \rangle \ | \  e' \in h\}$.

\begin{figure}[H]
	
	\centering
	\begin{subfigure}[b]{.29\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \\ $\wrt{y}{0}$\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3, -1.75) {\begin{tabular}{l} $\wrt{x}{1}$\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {\begin{tabular}{l} $a \gets \rd{x}$ \\ $b \gets \rd{y}$\end{tabular}};
				\node[draw, rounded corners=2mm, outer sep=0] (t4) at (3, -0) {
					\begin{tabular}{l} 
						$\wrt{y}{3}$ \\
						{\pgfsetfillopacity{0.3}$c \gets \rd{x}$}
				\end{tabular}};
				\node[draw, rounded corners=2mm, opacity=0.3] (t5) at (3, -1.75) {\begin{tabular}{l} $\wrt{x}{4}$ \end{tabular}};
				\path[opacity=0.3] (t4) edge node[opacity=0.3] {$\so$} (t5);
				
				\path (t1.south east) -- (t1.east) coordinate[pos=0.67] (t1y);
				\path (t1.north east) -- (t1.east) coordinate[pos=0.67] (t1x);
				\path (t3.south west) -- (t3.west) coordinate[pos=0.67] (t3y);
				\path (t3.north west) -- (t3.west) coordinate[pos=0.67] (t3x);
				\path (t1x) edge[above] node[yshift=0,xshift=0] {$\wro_x$} (t3x);
				\path (t1y) edge[below] node[yshift=0,xshift=0] {$\wro_y$} (t3y);
			\end{tikzpicture}  
			
		}
		\caption{Current history.}
		\label{fig:add_read:a}
	\end{subfigure}
	\hspace{.5cm}
	\centering
	\begin{subfigure}[b]{.29\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \\ $\wrt{y}{0}$\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3, -1.75) {\begin{tabular}{l} $\wrt{x}{1}$\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {\begin{tabular}{l} $a \gets \rd{x}$ \\ $b \gets \rd{y}$\end{tabular}};
				
				\node[draw, rounded corners=2mm, outer sep=0] (t4) at (3, -0) {
					\begin{tabular}{l} 
						$\wrt{y}{3}$ \\
						$c \gets \rd{x}$
				\end{tabular}};
				\node[draw, rounded corners=2mm, opacity=0.3] (t5) at (3, -1.75) {\begin{tabular}{l} $\wrt{x}{4}$ \end{tabular}};
				\path[opacity=0.3] (t4) edge node[opacity=0.3] {$\so$} (t5);
				
				\path (t1.south east) -- (t1.east) coordinate[pos=0.67] (t1y);
				\path (t1.north east) -- (t1.east) coordinate[pos=0.67] (t1x);
				\path (t3.south west) -- (t3.west) coordinate[pos=0.67] (t3y);
				\path (t3.north west) -- (t3.west) coordinate[pos=0.67] (t3x);
				\path (t1x) edge[above] node[yshift=0,xshift=0] {$\wro_x$} (t3x);
				\path (t1y) edge[below] node[yshift=0,xshift=0] {$\wro_y$} (t3y);
				\path (t1.north east) edge[bend left=35] node[below] {$\wro_x$} (t4.north west);
			\end{tikzpicture}  
			
		}
		\caption{One possible extension.}
		\label{fig:add_read:b}
	\end{subfigure}
	\hspace{.5cm}
	\centering
	\begin{subfigure}[b]{.29\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \\ $\wrt{y}{0}$\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3, -1.75) {\begin{tabular}{l} $\wrt{x}{1}$\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {\begin{tabular}{l} $a \gets \rd{x}$ \\ $b \gets \rd{y}$\end{tabular}};
				
				\node[draw, rounded corners=2mm, outer sep=0] (t4) at (3, -0) {
					\begin{tabular}{l} 
						$\wrt{y}{3}$ \\
						$c \gets \rd{x}$
				\end{tabular}};
				\node[draw, rounded corners=2mm, opacity=0.3] (t5) at (3, -1.75) {\begin{tabular}{l} $\wrt{x}{4}$ \end{tabular}};
				\path[opacity=0.3] (t4) edge node[opacity=0.3] {$\so$} (t5);
				
				\path (t1.south east) -- (t1.east) coordinate[pos=0.67] (t1y);
				\path (t1.north east) -- (t1.east) coordinate[pos=0.67] (t1x);
				\path (t3.south west) -- (t3.west) coordinate[pos=0.67] (t3y);
				\path (t3.north west) -- (t3.west) coordinate[pos=0.67] (t3x);
				\path (t1x) edge[above] node[yshift=0,xshift=0] {$\wro_x$} (t3x);
				\path (t1y) edge[below] node[yshift=0,xshift=0] {$\wro_y$} (t3y);
				\path (t2.east) edge[bend right=15] node[yshift=-2,xshift=0] {$\wro_x$} (t4.south west);
			\end{tikzpicture}  
			
		}
		\caption{Another possible extension.}
		\label{fig:add_read:c}
	\end{subfigure}
	\caption{Extensions of a history by adding a $\iread$ event.}
	\label{fig:add_read}
	%\vspace{-3mm}
\end{figure}

However, we will only select those $\iwrite$ event such that the extended history $h \bullet_w e$ is consistent, as described by function $\validWrites$; which will eventually play the $\genericValidWrites$'s role in our algorithm.  

\begin{cframed}[pinegreen]
	\begin{equation*}
		\begin{array}{ccc}
			\validWrites(h, e) & \coloneqq & \{w \ | \ \isConsistent{h \bullet_w e}\}
		\end{array}
	\end{equation*}
\end{cframed}

Conversely, adding a $\iwrite$ $w$ is more complicated, multiple events may read this new event; specifically. the number of possible histories is exponential, $2^{|\iread(h)|}$. Moreover, after changing a $\wro$-edge from a $\iread$ $r$, we have no knowledge of the rest of the event's presence: some conditional instruction may be executed after $r$ and it may be meaningless talking about them. Thus, checking for every possible set of $\iread$ events if reading from $w$ leads to something consistent is no reasonable. Therefore, we have to define a criterion to determine whose sets of read events shall be analyzed. One hand, the history $h \bullet w$ where no $\iread$ reads from $w$ has to be explored, with an algorithm order defined in an analogously as for any other aforementioned history. On the other hand, we select one $\iread$ $r$ that will be the first event in $h$ reading from $w$ while the ones that follow $r$ will have to be re-executed. As $r$ had already been executed, what at the end we produce is a swap between the relative orders of $r$ and $w$; so $r$ would be thereinafter called \textit{swapped}.

%As in a more formal way definition \ref{def:swapped} states, this read $r$ would be thereinafter called \textit{swapped}

%Moreover, after changing a $\wro$-edge, we have no knowledge of the rest of the event's presence: some conditional instruction may be executed after that $\iread$ and it may be meaningless talking about the rest of the events. Moreover, by the prefix-closedness of our model, an inconsistent history only leads to inconsistent ones; so there is no reasonable reason for exploring those. Thus, instead of generating every single one of them and check afterwards if they are consistent, we prefer to generate a small subset and only extends those ones that are consistent; by the prefix-closedness of our model, an inconsistent history only leads to inconsistent ones. %Therefore, we can detect inconsistencies early on.

%Our protocol is defined as follows: we will select one $\iread$ event that will be the first event in $h$ reading from $w$ while the ones that proceed $r$ will be marked as postponed; they will have to be re-executed. As in a more formal way definition \ref{def:swapped} states, This read $r$ would be thereinafter called \textit{swapped}:

%, and we will enforce the following properties: no event before $r$ will read from $w$, $r$ reads from $w$, every read after $r$ may or may not read from $w$. 

\begin{definition}
	A $\iread$ event $r$ is \callout{swapped} if the following conditions hold:
	\begin{itemize}
		\item For $w= h.\wro(r)$, $w <_h r$ and $w >_{\ora} r$.
		\item $\tr(r)$ is the first transaction that depends on $\tr(w)$: $\nexists T <_{\ora} \tr(r)$ s $T <_h \tr(r)$ and $\tr(w) \ [\so \cup \wro]^+ \ T$. %\textcolor{red}{Note: I changed $T \neq \tr(r)$ to $T <_{\ora} \tr(r)$ for the proof as by $\ora$-respectfulness (defined in proof's section), we obtain both are equivalent.}
		\item $r$ is the first $\iread$ event that reads from $\tr(w)$: $\nexists r'\in \tr(r), r' \leq_{\ora} r$ such that $\tr(h.\wro(r')) = \tr(w)$
	\end{itemize}
	\label{def:swapped}
\end{definition}

This definition is summarized in the following function:

\begin{cframed}[pinegreen]
	\begin{equation*}
		\begin{array}{ccc}
			\swapped{h}{r} & \coloneqq & 
			\begin{array}{c}
				\type{r} = \iread \land w <_h r \land w >_{\ora} r \\
				\land \\
				\forall e \in h, (\tr(e) <_{\ora} \tr(r)) \implies (r <_h e  \lor (\lnot(\tr(w) \ [\so \cup \wro]^+ \ \tr(e))) \\
				\land \\
				\forall e \in \iread(h), (e \ [\po] \ r) \implies \tr(h.\wro(r)) \neq \tr(w)
			\end{array} 
			
		\end{array}
	\end{equation*}
\end{cframed}

\begin{figure}[H]
	
	\centering
	\begin{subfigure}[b]{.3\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \\ $a \gets \rd{x}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3, -1.75) {\begin{tabular}{l} $b \gets \rd{x}$\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {\begin{tabular}{l} $\wrt{x}{2}$ \\ $\wrt{y}{2}$\end{tabular}};
				\node[draw, rounded corners=2mm, outer sep=0] (t4) at (3, -0) {
					\begin{tabular}{l} 
						$c \gets \rd{x}$ \\
						{\pgfsetfillopacity{0.3}$\wrt{x}{3}$}
				\end{tabular}};
				\node[draw, rounded corners=2mm, opacity=0.3] (t5) at (3, -1.75) {\begin{tabular}{l} $\wrt{y}{4}$ \end{tabular}};
				\path[opacity=0.3] (t4) edge node[opacity=0.3] {$\so$} (t5);
				
				
				\path (t3.south east) -- (t3.east) coordinate[pos=0.67] (t3x);
				\path (t4.south west) -- (t4.west) coordinate[pos=0.67] (t4x);
				\path (t3x) edge[above] node[yshift=0,xshift=0] {$\wro_x$} (t4x);
				
				\path (t1.north west) -- (t1.north) coordinate[pos=0.5] (t1a);
				\path (t1.west) edge [out=140, in=120, looseness=2.25] (t1a);
				%[out=100,in=120,looseness=5] bend left=50, 
				
				\node[above left =0.125 and 0.05 of t1.north](t1alab) {$\wro_x$};
				\path (t1) edge [left] node {$\wro_x$} (t2);
			\end{tikzpicture}  
			
		}
		\caption{Current history.}
		\label{fig:add_write:a}
	\end{subfigure}
	\hspace{.5cm}
	\centering
	\begin{subfigure}[b]{.3\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \\ $a \gets \rd{x}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3, -1.75) {\begin{tabular}{l} $b \gets \rd{x}$\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {\begin{tabular}{l} $\wrt{x}{2}$ \\ $\wrt{y}{2}$\end{tabular}};
				\node[draw, rounded corners=2mm, outer sep=0] (t4) at (3, -0) {
					\begin{tabular}{l} 
						$c \gets \rd{x}$ \\
						$\wrt{x}{3}$
				\end{tabular}};
				\node[draw, rounded corners=2mm, opacity=0.3] (t5) at (3, -1.75) {\begin{tabular}{l} $\wrt{y}{4}$ \end{tabular}};
				\path[opacity=0.3] (t4) edge node[opacity=0.3] {$\so$} (t5);
				
				
				\path (t3.south east) -- (t3.east) coordinate[pos=0.67] (t3x);
				\path (t4.south west) -- (t4.west) coordinate[pos=0.67] (t4x);
				\path (t3x) edge[above] node[yshift=0,xshift=0] {$\wro_x$} (t4x);
				
				\path (t4.south west) edge [bend left=15] node[above] {$\wro_x$} (t2.east);
				
				\path (t1.north west) -- (t1.north) coordinate[pos=0.5] (t1a);
				\path (t1.west) edge [out=140, in=120, looseness=2.25] (t1a);
				%[out=100,in=120,looseness=5] bend left=50, 
				
				\node[above left =0.125 and 0.05 of t1.north](t1alab) {$\wro_x$};
				
			\end{tikzpicture}  
			
		}
		\caption{One possible swap.}
		\label{fig:add_write:b}
	\end{subfigure}
	\hspace{.5cm}
	\centering
	\begin{subfigure}[b]{.29\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \\ $a \gets \rd{x}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, opacity=0.3] (t2) at (-3, -1.75) {\begin{tabular}{l} $b \gets \rd{x}$\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {\begin{tabular}{l} $\wrt{x}{2}$ \\ $\wrt{y}{2}$\end{tabular}};
				\node[draw, rounded corners=2mm, outer sep=0] (t4) at (3, -0) {
					\begin{tabular}{l} 
						$c \gets \rd{x}$ \\
						$\wrt{x}{3}$
				\end{tabular}};
				\node[draw, rounded corners=2mm, opacity=0.3] (t5) at (3, -1.75) {\begin{tabular}{l} $\wrt{y}{4}$ \end{tabular}};
				\path[opacity=0.3] (t4) edge node[opacity=0.3] {$\so$} (t5);
				
				
				\path (t3.south east) -- (t3.east) coordinate[pos=0.67] (t3x);
				\path (t4.south west) -- (t4.west) coordinate[pos=0.67] (t4x);
				\path (t3x) edge[above] node[yshift=0,xshift=0] {$\wro_x$} (t4x);
				
				\path (t4.north west) edge [bend right=15] node[above] {$\wro_x$} (t1.north east);
				
			\end{tikzpicture}  
			
		}
		\caption{Another possible swap.}
		\label{fig:add_write:c}
	\end{subfigure}
	\caption{Extensions of a history by adding a $\iwrite$ event.}
	\label{fig:add_write}
	%\vspace{-3mm}
\end{figure}

%\textcolor{red}{Talk about this example, explain why t2 disappears in 4.3}

Let us show with an example the power of swapping. Here, in Figure~\ref{fig:add_write:a} we can see an incomplete history whose $\nextEvent$ event, $w \coloneqq \wrt{x}{3}$, is a $\iwrite$ event. There are four possible histories, depending if the first and second $\iread$ events, $r_a \coloneqq a \gets \rd{x} $ and $r_b \coloneqq b \gets \rd{x}$, read or not from $w$ (as $c \gets \rd{x}$ will never be able to read from $w$). In Figure~\ref{fig:add_write:b} we can see the history $h_b$ where only $r_b$ reads from $w$. As $r_a <_h r_b$, we simply state that $w \ [\wro] \ r_b$ in $h_b$. The other two cases that modify the write-read relation are due to the edge $w \ [\wro] \ r_a$; their common root. Therefore, we can construct the history $h_c$ depicted in Figure~\ref{fig:add_write:c}, mark $r_b$ as no executed to later on re-execute it and decide, in a later moment, if $w \ [\wro] \ r_b$ or not. In even in this small case we can realize that if $h_c$ would be inconsistent, we would already reduce the number of explored histories by one; its extensions would also be inconsistent. %we can delete $r_b$ for re-executing it later as depicted in Figure~\ref{fig:add_write:c} and by the rules described above, we know that two histories, one where $r_a$ reads from $w$ and another where it does not will be generated. 

In a more general context, when swapping two events $r$ and $w$, we will delete all those events $e$ that are between $r$ and $w$ in the history-order such that $\tr(w)$ does not depends on. Otherwise, deleting some event $e$ such that $\tr(e) \ [\so \cup \wro]^* \ \tr(w)$ holds will produce a history where either some $\iread$ is reading from a deleted $\iwrite$ or some event would be executed before its $\so$-predecessor; both impossible situations in real life.

%The name ``swapping'' $w$ and $r$ refers to the change of relative order between those two events; $r <_{\ora} w$ but in the new history their order is reversed: $w <_h r$. Moreover, every event $e$ after $r$ that does not unlock $w$ (i.e. the condition $\tr(e) \ [\so \cup \wro]^+ \ \tr(w) $ does not hold) will be not taking into account to check this consistency. The reason for this is simple: if we want to compute every possible history, we may need to restate where some read-events read from, and we achieve this by re-executing them. To avoid redundancies, only those that $\tr(w)$ not depend on should being able to be re-executed.

\begin{comment}
\begin{algorithm}[H]
\caption{\textsc{STMC}$_0$}
\begin{algorithmic}[1]
\InputAlgorithmic $h$: history.
\If{ $\lnot \ \textsc{IsConsistent}_{\mathcal{M}}(h)$} \Return
\ElsIf{$\textsc{IsComplete}(h)$}
\State $\textsc{processHistory}(h)$
\Else
\State $a \gets  \nextEvent(h)$; $\; x \gets a.var()$
\Switch{$a.type()$}
\Case{$\ibegin$}
\Comment{$\ibegin$ and $\iend$ cases coincide.}
\EndCase
\Case{$\iend$}
\State $\textsc{STMC}_0(h \bullet a)$
\Break
\EndCase
\Case{$\iread$}
\ForAll{$w \in h \text{ s.t. } \writeVar{w}{x}$}
\State $h' \gets h \bullet a$; $\; h'.\wro[a] \gets w$
\State $\textsc{STMC}_0(h')$
\EndFor
\Break
\EndCase
\Case{$\iwrite$}
\State $\textsc{STMC}_0(h \bullet a)$
\ForAll{$r \in h \text{ s.t. } \readVar{r}{x}$}
\State $D \gets \{e \ | \ r <_h e \land \lnot (\tr(e) \ [\so \cup \wro]^* \ \tr(a))\}$
\State $h' \gets (h \setminus D) \bullet a$; $\; h'.\wro[r] \gets a$
\State $\textsc{STMC}_0(h')$
\EndFor
\Break
\EndCase
\EndSwitch
\EndIf

\end{algorithmic}
\label{algorithm:stmc0}
\end{algorithm}
\end{comment}


