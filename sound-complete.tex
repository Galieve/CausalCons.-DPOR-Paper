\section{Stateless DPOR algorithms for maximal-extensible models}

The main goal in this work is describing a deterministic algorithm for transactional model-checking under a \textcolor{red}{Â¿maximal-extensible model?} $\mathcal{M}$; obtaining all possible behaviors a program may have. We present during this section a sound, complete and optimal algorithm employing polynomial memory, i.e. a member of $\mathcal{S}_{\mathcal{M}} \cap \mathcal{O}^n_{\mathcal{M}}$ for some $n \in \mathbb{N}$. In particular, we will show that our algorithm has at most one pending transaction and why this is key to guarantee the rest of the properties. \textcolor{red}{For simplicity, we will omit proof of its properties as a later refinement found in section \textcolor{red}{??} will be the one proved.}

Our version will require as parameter the program to analyze along with a total order called \callout{oracle order} between its transactions. This order, denoted as $<_{\ora}$ and trivially extensible to the events, has to respect the session order of the program (i.e. if $T \ [\so] \ T'$ then $T \ [\ora] \ T'$); forbidding executions any processor would produce. Moreover, $\ora$ will be global and constant during the whole algorithm's execution. 

In addition, we assume the existence of a total order between the events in every history, called \callout{history order} and denoted as $<_h$, as well as a function $\nextEvent$ that given a non-total history $h$ returns the next event to be added. In a nutshell, it returns the minimal event according to $\ora$ that is not in $h$, prioritizing those events in pending transactions. Formally:

\begin{cframed}[pinegreen]
\begin{equation*}
\begin{array}{ccc}
\nextEvent(h) & = & 
	\left\{
	\begin{array}{cc}
		\min_{\ora}\{e \in \mathcal{E} \ | \ e \not\in h\} & \text{if } \not\exists T \text{ s.t. } \textsc{pending}_h(T) \\
		\min_{\ora}\{e \in\mathcal{E} \setminus h \ | \ e \in \textsc{pending}_h(T) \} & \text{otherwise}
	\end{array}
	\right.
\end{array}
\end{equation*}
\end{cframed}

 %if there is an incomplete transaction, $\nextEvent(h)$ is the minimal event $e$ according to $\ora$ that is not in $h$ but $\ibegin(\tr(e)) \in h$.

%During this section we will present several approaches for finding a deterministic transactional model checker and we will show why STMC is the best among them. Every approach would be, in some particular sense, incremental; starting from an empty history and ``enlarging'' it, adding in each step new events and/or relations between them. For any fixed program, we will assume that no transaction enable/disable any other and that they are totally ordered by some relation $\ora$ called \textit{oracle order} that respects $\so$ (i.e. if $T \ [\so] \ T'$ then $T \ [\ora] \ T'$). Therefore, combining $\ora$ and $\po$ we can also say that the oracle order also enforces a total order between the events.


Thanks to this function, we will be able to extend any history $h = \langle E, \so, \wro \rangle$ in a deterministic way. Moreover, by its definition we observe that $\nextEvent$ always propose to complete pending transactions before starting new ones. Therefore, it is a reasonable candidate as $\genericNext$ function in a algorithm \ref{algorithm:algo-class} instance.
\textcolor{red}{\sout{If the event $e =\nextEvent(h)$ is $\ibegin, \iwrite$ or $\iend$, we will denote by $h \bullet e$ the history $h' = \langle E', \so', \wro\rangle$ where $E' = \events{h} \cup \{e\}$ and $\so' = \so \cup \{\langle e', e \rangle \ | \ e' \in h \land \thread{e} = \thread{e'}\}$. On the other hand, if $e$ is a $\iread$ event, we will define the history $h_w' = h \bullet_w e$ for some $\iwrite$ event $w \in h$ as $\langle E', \so', \wro \cup \{\langle w, r \rangle\} \rangle$; where $E'$ and $\so'$ defined as before.}: It has to be moved to the definitions' section}. 

\begin{figure}[H]
	
	\centering
	\begin{subfigure}[b]{.32\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3.5, 0) {\begin{tabular}{l} 
						$\wrt{x}{0}$ \\
						$\wrt{y}{0}$
				\end{tabular}};
				
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3.5, -2) {
					\begin{tabular}{l}
						$a \gets \rd{x}$ \\
						$b \gets \rd{y}$						
				\end{tabular}};
				
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {
					\begin{tabular}{l}
						$c \gets \rd{x}$ \\
						$\wrt{y}{2}$
				\end{tabular}};
				
				\node[draw, rounded corners=2mm,outer sep=0] (t4) at (0, -2) {
					\begin{tabular}{l} 
						$\wrt{y}{3}$ \\
						$d \gets \rd{y}$
				\end{tabular}};
				
				\path (t1) edge[left] node[yshift=0,xshift=0] {$\ora$} (t2);
				\path (t2) edge[above] node[yshift=0,xshift=0] {$\ora$} (t3);
				
				\path (t3.south east) -- (t3.south) coordinate[pos=0.67] (t3so);
				\path (t3.south west) -- (t3.south) coordinate[pos=0.67] (t3or);
				\path (t4.north east) -- (t4.north) coordinate[pos=0.67] (t4so);
				\path (t4.north west) -- (t4.north) coordinate[pos=0.67] (t4or);
				\path (t3or) edge[left] node[yshift=0,xshift=0] {$\ora$} (t4or);
				\path (t3so) edge[right] node[yshift=0,xshift=0] {$\so$} (t4so);
			\end{tikzpicture}  
			
		}
		\caption{$\ora$ produce a total order between all transactions in the program.}
		\label{fig:oracle_order:a}
	\end{subfigure}
	\hspace{.7cm}
	\centering
	\begin{subfigure}[b]{.32\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3.5, 0) {\begin{tabular}{l} 
						$\wrt{x}{0}$ \\
						$\wrt{y}{0}$
				\end{tabular}};
				
				\node[draw, rounded corners=2mm,outer sep=0, opacity=0.3] (t2) at (-3.5, -2) {
					\begin{tabular}{l}
						$a \gets \rd{x}$ \\
						$b \gets \rd{y}$						
				\end{tabular}};
				
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {
					\begin{tabular}{l}
						$c \gets \rd{x}$ \\
						$\wrt{y}{2}$
				\end{tabular}};
				
				\node[draw, rounded corners=2mm,outer sep=0] (t4) at (0, -2) {
					\begin{tabular}{l} 
						$\wrt{y}{3}$ \\
						{\pgfsetfillopacity{0.3}$d \gets \rd{y}$}
				\end{tabular}};
				
				\path (t1) edge[left] node[yshift=0,xshift=0] {$\ora$} (t2);
				\path (t2) edge[above] node[yshift=0,xshift=0] {$\ora$} (t3);
				\path (t1) edge[above] node[yshift=0,xshift=0] {$\wro$} (t3);
				
				\path (t3.south east) -- (t3.south) coordinate[pos=0.67] (t3so);
				\path (t3.south west) -- (t3.south) coordinate[pos=0.67] (t3or);
				\path (t4.north east) -- (t4.north) coordinate[pos=0.67] (t4so);
				\path (t4.north west) -- (t4.north) coordinate[pos=0.67] (t4or);
				\path (t3or) edge[left] node[yshift=0,xshift=0] {$\ora$} (t4or);
				\path (t3so) edge[right] node[yshift=0,xshift=0] {$\so$} (t4so);
			\end{tikzpicture}  
			
		}
		\caption{An incomplete history and its $\ora$ order.}
		\label{fig:oracle_order:b}
	\end{subfigure}
	\caption{Some possible oracle order between transactions.}
	\label{fig:oracle_order}
	
\end{figure}

For example, given the history $h$ in Figure~\ref{fig:oracle_order:b}, the function $\nextEvent$ would return the event $d \gets \rd{y}$ instead of $a \gets \rd{x}$; as the forth transaction is pending in $h$.
%Nevertheless, we will guarantee in both cases that every possible incomplete history will be $\so$-bounded, i.e. if $e \ [\so \cup \po]^+ e'$ and $e' \in h$ then $e \in h$; in order to easily avoid eventual inconsistencies. Therefore, the global order $\ora$ presented in Figure~\ref{fig:oracle_order:a} restrict in a simple but effective way the duplicity between histories: the order events are being added don't cause \textit{per se} redundancies.%In the second case, to avoid randomness, we will have a function $\nextEvent$ that given a history $h$ returns the first event $e$ according to $\ora$ that is not in $h$; to obtain the new history $h' = h \bullet e$. For example, given the history in Figure~\ref{fig:oracle_order:b}, the function $\nextEvent$ would return the event $\ibegin$ associated to the second transaction. Nevertheless, we will guarantee in both cases that every possible incomplete history will be $\so$-bounded, i.e. if $e \ [\so \cup \po]^+ e'$ and $e' \in h$ then $e \in h$; in order to easily avoid eventual inconsistencies. Therefore, the global order $\ora$ presented in Figure~\ref{fig:oracle_order:a} restrict in a simple but effective way the duplicity between histories: the order events are being added don't cause \textit{per se} redundancies.

%Thanks to $\so$ and $\ora$ order, we will be able to track every possible history, and therefore, have control over the amount of graphs generated. 

%Incomplete histories can be extended in two ways: either with the extern help of some guide that select beforehand which events and in which order will be executed or without it. For managing the second case in a deterministic way, we will have a function $\nextEvent$ that maps every $h$ to some event that is not in $h$ for obtaining a new history $h' = h \bullet e$. If $h$ is incomplete and $l = \last{h}$ then $e$ is the minimum event in $\po_T$ bigger than $l$; but if not, $e$ is the $\ibegin$ event belonging to the minimal transaction $T$ according to $\ora$ that is not in $h$. For example, the function $\nextEvent$ would the history in Figure~\ref{fig:oracle_order:b} to the event $d \gets \rd{y}$. Clearly, any coherent history can be extended using $\nextEvent$ function resulting in a coherent history (as $\ora$ extends $\so$, it only suffices defining the $\wro$ edge that an eventual free $\iread$ would require).
%Nevertheless, we will guarantee in both cases that every possible incomplete history will be $\so$-bounded, i.e. if $e \ [\so \cup \po]^+ e'$ and $e' \in h$ then $e \in h$; in order to easily avoid eventual inconsistencies. Therefore, the global order $\ora$ presented in Figure~\ref{fig:oracle_order:a} restrict in a simple but effective way the duplicity between histories: the order events are being added don't cause \textit{per se} redundancies.%In the second case, to avoid randomness, we will have a function $\nextEvent$ that given a history $h$ returns the first event $e$ according to $\ora$ that is not in $h$; to obtain the new history $h' = h \bullet e$. For example, given the history in Figure~\ref{fig:oracle_order:b}, the function $\nextEvent$ would return the event $\ibegin$ associated to the second transaction. Nevertheless, we will guarantee in both cases that every possible incomplete history will be $\so$-bounded, i.e. if $e \ [\so \cup \po]^+ e'$ and $e' \in h$ then $e \in h$; in order to easily avoid eventual inconsistencies. Therefore, the global order $\ora$ presented in Figure~\ref{fig:oracle_order:a} restrict in a simple but effective way the duplicity between histories: the order events are being added don't cause \textit{per se} redundancies.

\subsection{Extending histories}
\label{subsection:ExtendingHistories} %Provisional

The incremental process of obtaining histories with more information it is called \textit{extension}. In essence, given a history $h$ and an event $e \not\in h$, all possible graphs using these two pieces must be constructed.

If $e$'s type is $\ibegin$ or $\iend$, there is only one possible way to extend it by the operator $\bullet$'s definition. When $e$ is a $\iread$, however, we have to explore multiple histories, one per $\wro$-dependency that can be generated with a $\iwrite$ event $w\in h$ and $e$. That is, all histories $h_w' = h \bullet_w e$, $w \in \iwrite(h)$. For example in figure \ref{fig:add_read} we can see how from the history in figure \ref{fig:add_read:a} we can obtain two different histories depending on the $\wro$ dependency created (figures \ref{fig:add_read:b} and \ref{fig:add_read:c}).

%derived from it must be constructed. If its type is $\ibegin$ or $\iend$, there is only one possible way to extend it, as no new edges besides $\so$ will appear in $h' = h \bullet e$. Adding a $\iread$ event is also quite straightforward: by definition of $\wro$ relation, $r$ must read from some $\iwrite$ event. Therefore, we shall explore every possible history $h'_w = h \bullet r$ where $w$ is a $\iwrite$ event in $h$ such that $h_w'.\wro(r) = w$.
%The existence of non total histories urge us to find a way to extend them 

%\textcolor{red}{Re-redact this!!!!!!!!! (commented)}

%\textcolor{red}{change start of this paragraph}
%As it has been already mentioned, all our approaches follow the same principle: when one event is added to some history, all possible graphs derived from this act must be constructed. However, as constructing histories is an expensive procedure, we want to reduce the number of those that are created; in particular, avoiding generate inconsistent or redundant histories. When the event added has type $\ibegin$ or $\iend$, there is only one possible way to extend the history. If its type is $\iread$, as every read event have to be $\wro$-associated with exactly one write event, we have to construct several histories, one per possible edge $\wro$.

\begin{figure}[H]
	
	\centering
	\begin{subfigure}[b]{.29\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \\ $\wrt{y}{0}$\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3, -1.75) {\begin{tabular}{l} $\wrt{x}{1}$\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {\begin{tabular}{l} $a \gets \rd{x}$ \\ $b \gets \rd{y}$\end{tabular}};
				\node[draw, rounded corners=2mm, outer sep=0] (t4) at (3, -0) {
					\begin{tabular}{l} 
						$\wrt{y}{3}$ \\
						{\pgfsetfillopacity{0.3}$c \gets \rd{x}$}
				\end{tabular}};
				\node[draw, rounded corners=2mm, opacity=0.3] (t5) at (3, -1.75) {\begin{tabular}{l} $\wrt{x}{4}$ \end{tabular}};
				\path[opacity=0.3] (t4) edge node[opacity=0.3] {$\so$} (t5);
				
				\path (t1.south east) -- (t1.east) coordinate[pos=0.67] (t1y);
				\path (t1.north east) -- (t1.east) coordinate[pos=0.67] (t1x);
				\path (t3.south west) -- (t3.west) coordinate[pos=0.67] (t3y);
				\path (t3.north west) -- (t3.west) coordinate[pos=0.67] (t3x);
				\path (t1x) edge[above] node[yshift=0,xshift=0] {$\wro_x$} (t3x);
				\path (t1y) edge[below] node[yshift=0,xshift=0] {$\wro_y$} (t3y);
			\end{tikzpicture}  
			
		}
		\caption{Current history.}
		\label{fig:add_read:a}
	\end{subfigure}
	\hspace{.5cm}
	\centering
	\begin{subfigure}[b]{.29\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \\ $\wrt{y}{0}$\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3, -1.75) {\begin{tabular}{l} $\wrt{x}{1}$\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {\begin{tabular}{l} $a \gets \rd{x}$ \\ $b \gets \rd{y}$\end{tabular}};
				
				\node[draw, rounded corners=2mm, outer sep=0] (t4) at (3, -0) {
					\begin{tabular}{l} 
						$\wrt{y}{3}$ \\
						$c \gets \rd{x}$
				\end{tabular}};
				\node[draw, rounded corners=2mm, opacity=0.3] (t5) at (3, -1.75) {\begin{tabular}{l} $\wrt{x}{4}$ \end{tabular}};
				\path[opacity=0.3] (t4) edge node[opacity=0.3] {$\so$} (t5);
				
				\path (t1.south east) -- (t1.east) coordinate[pos=0.67] (t1y);
				\path (t1.north east) -- (t1.east) coordinate[pos=0.67] (t1x);
				\path (t3.south west) -- (t3.west) coordinate[pos=0.67] (t3y);
				\path (t3.north west) -- (t3.west) coordinate[pos=0.67] (t3x);
				\path (t1x) edge[above] node[yshift=0,xshift=0] {$\wro_x$} (t3x);
				\path (t1y) edge[below] node[yshift=0,xshift=0] {$\wro_y$} (t3y);
				\path (t1.north east) edge[bend left=35] node[below] {$\wro_x$} (t4.north west);
			\end{tikzpicture}  
			
		}
		\caption{One possible extension.}
		\label{fig:add_read:b}
	\end{subfigure}
	\hspace{.5cm}
	\centering
	\begin{subfigure}[b]{.29\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \\ $\wrt{y}{0}$\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3, -1.75) {\begin{tabular}{l} $\wrt{x}{1}$\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {\begin{tabular}{l} $a \gets \rd{x}$ \\ $b \gets \rd{y}$\end{tabular}};
				
				\node[draw, rounded corners=2mm, outer sep=0] (t4) at (3, -0) {
					\begin{tabular}{l} 
						$\wrt{y}{3}$ \\
						$c \gets \rd{x}$
				\end{tabular}};
				\node[draw, rounded corners=2mm, opacity=0.3] (t5) at (3, -1.75) {\begin{tabular}{l} $\wrt{x}{4}$ \end{tabular}};
				\path[opacity=0.3] (t4) edge node[opacity=0.3] {$\so$} (t5);
				
				\path (t1.south east) -- (t1.east) coordinate[pos=0.67] (t1y);
				\path (t1.north east) -- (t1.east) coordinate[pos=0.67] (t1x);
				\path (t3.south west) -- (t3.west) coordinate[pos=0.67] (t3y);
				\path (t3.north west) -- (t3.west) coordinate[pos=0.67] (t3x);
				\path (t1x) edge[above] node[yshift=0,xshift=0] {$\wro_x$} (t3x);
				\path (t1y) edge[below] node[yshift=0,xshift=0] {$\wro_y$} (t3y);
				\path (t2.east) edge[bend right=15] node[yshift=-2,xshift=0] {$\wro_x$} (t4.south west);
			\end{tikzpicture}  
			
		}
		\caption{Another possible extension.}
		\label{fig:add_read:c}
	\end{subfigure}
	\caption{Extensions of a history by adding a $\iread$ event.}
	\label{fig:add_read}
	%\vspace{-3mm}
\end{figure}

Conversely, adding a $\iwrite$ $w$ is more complicated; multiple events may read this new event. The number of possible histories is exponential, $2^{|\iread(h)|}$. Here, instead of generating every single one of them and check afterwards if they are consistent, we prefer to generate a small subset and only extends those ones that are consistent; by the prefix-closedness of our model, an inconsistent history only leads to inconsistent ones. %Therefore, we can detect inconsistencies early on.

Our protocol is defined as follows: we will select one $\iread$ event that will be the first event in $h$ reading from $w$ while the ones that proceed $r$ will be marked as postponed; they will have to be re-executed. As in a more formal way definition \ref{def:swapped} states, This read $r$ would be thereinafter called \textit{swapped}:

%, and we will enforce the following properties: no event before $r$ will read from $w$, $r$ reads from $w$, every read after $r$ may or may not read from $w$. 

\begin{definition}
	A $\iread$ event $r$ is \callout{swapped} if the following conditions hold:
	\begin{itemize}
		\item For $w= h.\wro(r)$, $w <_h r$ and $w >_{\ora} r$.
		\item There is no transaction besides $\tr(r)$ that depends on $\tr(w)$: $\nexists T <_{\ora} \tr(r)$ such that $T <_h \tr(r)$ and $\tr(w) \ [\so \cup \wro]^+ \ T$. \textcolor{red}{Note: I changed $T \neq \tr(r)$ to $T <_{\ora} \tr(r)$ for the proof as by $\ora$-respectfulness (defined in proof's section), we obtain both are equivalent.}
		\item $r$ is the first $\iread$ that reads from $\tr(w)$: $\nexists r'\in \tr(r), r' <_h r$ such that $\tr(h.\wro(r')) = \tr(w)$
	\end{itemize}
	\label{def:swapped}
\end{definition}

\begin{figure}[H]
	
	\centering
	\begin{subfigure}[b]{.3\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \\ $a \gets \rd{x}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3, -1.75) {\begin{tabular}{l} $b \gets \rd{x}$\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {\begin{tabular}{l} $\wrt{x}{2}$ \\ $\wrt{y}{2}$\end{tabular}};
				\node[draw, rounded corners=2mm, outer sep=0] (t4) at (3, -0) {
					\begin{tabular}{l} 
						$c \gets \rd{x}$ \\
						{\pgfsetfillopacity{0.3}$\wrt{x}{3}$}
				\end{tabular}};
				\node[draw, rounded corners=2mm, opacity=0.3] (t5) at (3, -1.75) {\begin{tabular}{l} $\wrt{y}{4}$ \end{tabular}};
				\path[opacity=0.3] (t4) edge node[opacity=0.3] {$\so$} (t5);
				
				
				\path (t3.south east) -- (t3.east) coordinate[pos=0.67] (t3x);
				\path (t4.south west) -- (t4.west) coordinate[pos=0.67] (t4x);
				\path (t3x) edge[above] node[yshift=0,xshift=0] {$\wro_x$} (t4x);
				
				\path (t1.north west) -- (t1.north) coordinate[pos=0.5] (t1a);
				\path (t1.west) edge [out=140, in=120, looseness=2.25] (t1a);
				%[out=100,in=120,looseness=5] bend left=50, 
				
				\node[above left =0.125 and 0.05 of t1.north](t1alab) {$\wro_x$};
				\path (t1) edge [left] node {$\wro_x$} (t2);
			\end{tikzpicture}  
			
		}
		\caption{Current history.}
		\label{fig:add_write:a}
	\end{subfigure}
	\hspace{.5cm}
	\centering
	\begin{subfigure}[b]{.3\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \\ $a \gets \rd{x}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3, -1.75) {\begin{tabular}{l} $b \gets \rd{x}$\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {\begin{tabular}{l} $\wrt{x}{2}$ \\ $\wrt{y}{2}$\end{tabular}};
				\node[draw, rounded corners=2mm, outer sep=0] (t4) at (3, -0) {
					\begin{tabular}{l} 
						$c \gets \rd{x}$ \\
						$\wrt{x}{3}$
				\end{tabular}};
				\node[draw, rounded corners=2mm, opacity=0.3] (t5) at (3, -1.75) {\begin{tabular}{l} $\wrt{y}{4}$ \end{tabular}};
				\path[opacity=0.3] (t4) edge node[opacity=0.3] {$\so$} (t5);
				
				
				\path (t3.south east) -- (t3.east) coordinate[pos=0.67] (t3x);
				\path (t4.south west) -- (t4.west) coordinate[pos=0.67] (t4x);
				\path (t3x) edge[above] node[yshift=0,xshift=0] {$\wro_x$} (t4x);
				
				\path (t4.south west) edge [bend left=15] node[above] {$\wro_x$} (t2.east);
				
				\path (t1.north west) -- (t1.north) coordinate[pos=0.5] (t1a);
				\path (t1.west) edge [out=140, in=120, looseness=2.25] (t1a);
				%[out=100,in=120,looseness=5] bend left=50, 
				
				\node[above left =0.125 and 0.05 of t1.north](t1alab) {$\wro_x$};
				
			\end{tikzpicture}  
			
		}
		\caption{One possible swap.}
		\label{fig:add_write:b}
	\end{subfigure}
	\hspace{.5cm}
	\centering
	\begin{subfigure}[b]{.29\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \\ $a \gets \rd{x}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, opacity=0.3] (t2) at (-3, -1.75) {\begin{tabular}{l} $b \gets \rd{x}$\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {\begin{tabular}{l} $\wrt{x}{2}$ \\ $\wrt{y}{2}$\end{tabular}};
				\node[draw, rounded corners=2mm, outer sep=0] (t4) at (3, -0) {
					\begin{tabular}{l} 
						$c \gets \rd{x}$ \\
						$\wrt{x}{3}$
				\end{tabular}};
				\node[draw, rounded corners=2mm, opacity=0.3] (t5) at (3, -1.75) {\begin{tabular}{l} $\wrt{y}{4}$ \end{tabular}};
				\path[opacity=0.3] (t4) edge node[opacity=0.3] {$\so$} (t5);
				
				
				\path (t3.south east) -- (t3.east) coordinate[pos=0.67] (t3x);
				\path (t4.south west) -- (t4.west) coordinate[pos=0.67] (t4x);
				\path (t3x) edge[above] node[yshift=0,xshift=0] {$\wro_x$} (t4x);
				
				\path (t4.north west) edge [bend right=15] node[above] {$\wro_x$} (t1.north east);
				
			\end{tikzpicture}  
			
		}
		\caption{Another possible swap.}
		\label{fig:add_write:c}
	\end{subfigure}
	\caption{Extensions of a history by adding a $\iwrite$ event.}
	\label{fig:add_write}
	%\vspace{-3mm}
\end{figure}

%\textcolor{red}{Talk about this example, explain why t2 disappears in 4.3}

Let us show with an example the power of swapping. Here, in Figure~\ref{fig:add_write:a} we can see an incomplete history whose $\nextEvent$ event, $w \coloneqq \wrt{x}{3}$, is a $\iwrite$ event. There are four possible histories, depending if the first and second $\iread$ events, $r_a \coloneqq a \gets \rd{x} $ and $r_b \coloneqq b \gets \rd{x}$, read or not from $w$ ($c \gets \rd{x}$ will never be able to read from $w$). In Figure~\ref{fig:add_write:b} we can see the history $h_b$ where only $r_b$ reads from $w$. As $r_a <_h r_b$, we simply state that $w \ [\wro] \ r_b$ in $h_b$. The other two cases that modify the write-read relation are due to the edge $w \ [\wro] \ r_a$; their common root. Therefore, we can construct the history $h_c$ depicted in Figure~\ref{fig:add_write:c}, mark $r_b$ as no executed to later on re-execute it and decide, by the $\iread$-rule if $w \ [\wro] \ r_b$ or not. In even in this small case we can realize that if $h_c$ would be inconsistent, we would already reduce the number of explored histories by one; its extensions would also be inconsistent. %we can delete $r_b$ for re-executing it later as depicted in Figure~\ref{fig:add_write:c} and by the rules described above, we know that two histories, one where $r_a$ reads from $w$ and another where it does not will be generated. 

In a more general context, when swapping two events $r$ and $w$, we will delete all those events $e$ that are between $r$ and $w$ in the history-order such that $\tr(w)$ does not depends on. Otherwise, deleting some event $e$ such that $\tr(e) \ [\so \cup \wro]^* \ \tr(w)$ holds will produce a history where either some $\iread$ is reading from a deleted $\iwrite$ or some event would be executed before its $\so$-predecessor; both impossible situations in real life.

%The name ``swapping'' $w$ and $r$ refers to the change of relative order between those two events; $r <_{\ora} w$ but in the new history their order is reversed: $w <_h r$. Moreover, every event $e$ after $r$ that does not unlock $w$ (i.e. the condition $\tr(e) \ [\so \cup \wro]^+ \ \tr(w) $ does not hold) will be not taking into account to check this consistency. The reason for this is simple: if we want to compute every possible history, we may need to restate where some read-events read from, and we achieve this by re-executing them. To avoid redundancies, only those that $\tr(w)$ not depend on should being able to be re-executed.

\begin{comment}
\begin{algorithm}[H]
\caption{\textsc{STMC}$_0$}
\begin{algorithmic}[1]
\InputAlgorithmic $h$: history.
\If{ $\lnot \ \textsc{IsConsistent}_{\mathcal{M}}(h)$} \Return
\ElsIf{$\textsc{IsComplete}(h)$}
\State $\textsc{processHistory}(h)$
\Else
\State $a \gets  \nextEvent(h)$; $\; x \gets a.var()$
\Switch{$a.type()$}
\Case{$\ibegin$}
\Comment{$\ibegin$ and $\iend$ cases coincide.}
\EndCase
\Case{$\iend$}
\State $\textsc{STMC}_0(h \bullet a)$
\Break
\EndCase
\Case{$\iread$}
\ForAll{$w \in h \text{ s.t. } \writeVar{w}{x}$}
\State $h' \gets h \bullet a$; $\; h'.\wro[a] \gets w$
\State $\textsc{STMC}_0(h')$
\EndFor
\Break
\EndCase
\Case{$\iwrite$}
\State $\textsc{STMC}_0(h \bullet a)$
\ForAll{$r \in h \text{ s.t. } \readVar{r}{x}$}
\State $D \gets \{e \ | \ r <_h e \land \lnot (\tr(e) \ [\so \cup \wro]^* \ \tr(a))\}$
\State $h' \gets (h \setminus D) \bullet a$; $\; h'.\wro[r] \gets a$
\State $\textsc{STMC}_0(h')$
\EndFor
\Break
\EndCase
\EndSwitch
\EndIf

\end{algorithmic}
\label{algorithm:stmc0}
\end{algorithm}
\end{comment}

\subsection{Avoiding inconsistent branches}

Besides sound and complete, we would also seek for an algorithm that avoids blocking branches, i.e. that avoids computing a history $h$ whose extensions are all inconsistent. If this is not achieved, our search would employ more resources such as time or memory than it actually needs for doing its purpose.

\begin{figure}[H]
	
	\centering
	\begin{subfigure}[b]{.23\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				
				%\\ \multicolumn{1}{c}{ \ldots}
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3.25, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \\ $\wrt{y}{0}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3.25, -2) {\begin{tabular}{l} 
						$a \gets \rd{x}$ \\ $b \gets \rd{y}$
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0, opacity=0.3] (t3) at (0, 0) {\begin{tabular}{l} 
						$\wrt{x}{2}$ \\ $\wrt{y}{2}$
				\end{tabular}};			
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1x);
				\path (t1.south east) -- (t1.south) coordinate[pos=0.67] (t1y);
				\path (t2.north west) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t2.north east) -- (t2.north) coordinate[pos=0.67] (t2y);
				
				\path (t1x) edge [left] node {$\wro_y$} (t2x);
				\path (t1y) edge [right] node {$\wro_x$} (t2y);
			\end{tikzpicture}  
			
		}
		\caption{Current.}
		\label{fig:dead_branch:a}
	\end{subfigure}
	\hspace{.175cm}
	\centering
	\begin{subfigure}[b]{.23\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3.25, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \\ $\wrt{y}{0}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3.25, -2) {\begin{tabular}{l} 
						$a \gets \rd{x}$ \pgfsetfillopacity{0.3}\\ $b \gets \rd{y}$
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {\begin{tabular}{l} 
						$\wrt{x}{2}$\pgfsetfillopacity{0.3}\\
						$\wrt{y}{2}$
				\end{tabular}};			
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1x);
				\path (t2.north west) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t3.north west) -- (t3.west) coordinate[pos=0.67] (t3x);
				
				\path (t3x) edge [above] node[yshift=8,xshift=0] {$\wro_x$} (t2.north east);
				%\path (t1x) edge [right] node {$\wro_y$} (t2x);
			\end{tikzpicture}  
			
		}
		\caption{After swapping.}
		\label{fig:dead_branch:b}
	\end{subfigure}
	\hspace{.175cm}
	\centering
	\begin{subfigure}[b]{.23\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3.25, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \\ $\wrt{y}{0}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3.25, -2) {\begin{tabular}{l} 
						$a \gets \rd{x}$ \\ $b \gets \rd{y}$
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {\begin{tabular}{l} 
						$\wrt{x}{2}$\pgfsetfillopacity{0.3}\\
						$\wrt{y}{2}$
				\end{tabular}};			
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1x);
				\path (t2.north west) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t3.north west) -- (t3.west) coordinate[pos=0.67] (t3x);
				
				\path (t3x) edge [above] node[yshift=8,xshift=0] {$\wro_x$} (t2.north east);
				\path (t1x) edge [right] node {$\wro_y$} (t2x);
			\end{tikzpicture}
			
		}
		\caption{Extended.}
		\label{fig:dead_branch:c}
	\end{subfigure}
	\hspace{.175cm}
	\centering
	\begin{subfigure}[b]{.23\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3.25, 0) {\begin{tabular}{l} $\wrt{x}{0}$ \\ $\wrt{y}{0}$ \end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3.25, -2) {\begin{tabular}{l} 
						$a \gets \rd{x}$ \\ $b \gets \rd{y}$
				\end{tabular}};
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {\begin{tabular}{l} 
						$\wrt{x}{2}$\\
						$\wrt{y}{2}$
				\end{tabular}};			
				
				\path (t1.south west) -- (t1.south) coordinate[pos=0.67] (t1x);
				\path (t2.north west) -- (t2.north) coordinate[pos=0.67] (t2x);
				\path (t3.north west) -- (t3.west) coordinate[pos=0.67] (t3x);
				
				\path (t3x) edge [above] node[yshift=8,xshift=0] {$\wro_x$} (t2.north east);
				\path (t1x) edge [right] node {$\wro_y$} (t2x);
			\end{tikzpicture}
			
		}
		\caption{Inconsistent.}
		\label{fig:dead_branch:d}
	\end{subfigure}
	\caption{Example of a dead-lock after swapping two events.}
	\label{fig:dead_branch}
	%\vspace{-3mm}
\end{figure}

%Proceeding this way we can ensure that every complete history is not inconsistent, but we cannot yet ensure every incomplete consistent history lead to a complete and consistent one. Guaranteeing it would mean that every step done in the algorithm is meaningful; that any explored branch would lead to a dead end. 
One example of this undesired behavior can be easily seen under RA memory model with a program like the one depicted in Figure~\ref{fig:dead_branch}. Here we consider three transactions ordered from left to right, top to bottom, and we start with the history depicted in Figure~\ref{fig:dead_branch:a}. After executing the $\nextEvent$ event, the $\iwrite$ $w_x  \coloneqq \wrt{x}{2}$, one possible action would be swapping $w_x$ with the event $a \gets \rd{x}$; obtaining the history $h_2$ portrayed in Figure~\ref{fig:dead_branch:b}. By definition of the $\nextEvent$ function, that history shall be extended with $r_b \coloneqq b \gets \rd{y}$, but as there is only one $\iwrite$ instruction that writes $y$, $r_b$ must read from the very first transaction; as seen in Figure~\ref{fig:dead_branch:c}. However, when completing the third transaction we must inexorably admit that our history in Figure~\ref{fig:dead_branch:d} is inconsistent. Therefore, all the computation required to complete the unfinished transactions after the swap was in vain; we couldn't detect after computing $h_2$ the dead end.

This example fails as history from figure \ref{fig:dead_branch:c} has a pending transaction that is not $\so \cup \wro$-maximal. As $\nextEvent$ function always prioritize pending transactions, for never get out from theorem \ref{theorem:causalExtensibleModels} hypothesis we have to not produce pending transactions that are non $\so \cup \wro$-maximal. A simple solution is always executing histories in isolation, i.e. having exactly one pending transaction. Then, this transaction will $\so \cup \wro$-maximal, otherwise there would be a previous point where two pending transactions coexisted. Hence, we are not going to swap just after executing a $\iwrite$ event but when its transaction is completed.

\begin{comment}
 so by induction, we can always obtain total histories at any point in the algorithm.

	contenidos...

\begin{theorem}
\label{theorem:isolationAlwaysExtensible}
For every maximal closed model $\mathcal{M}$ that satisfies \textcolor{red}{ref properties of models} and every non-total consistent history $h$ executed in isolation there is a consistent extension $h' = h \bullet e$, where $e = \nextEvent(h)$.
\begin{proof}

\end{proof}
\end{theorem}

By theorem \ref{theorem:isolationAlwaysExtensible}, our objective can be achieved if every transaction can be executed in isolation. In our previous example, when swapping $w_x$ with $r_x$, at least two transactions remained unfinished: $\tr(w_x)$ and $\tr(r_x)$. For avoiding this situation, we are not going to swap just after executing a $\iwrite$ event but when its transaction is completed. %This forces us a subtle change in our decisions: instead of swapping some $\iwrite$ $w$ with a $\iread$ $r$, we will delay the swap until we find the end of $\tr(w)$.
\end{comment}

\begin{algorithm}[H]
	\caption{Recursive \textsc{STMC}}
	\begin{algorithmic}[1]
		\InputAlgorithmic $h$: history.
		\If{ $\lnot \ \textsc{IsConsistent}_{\mathcal{M}}(h)$} \Return
		\label{algorithm:sound-complete:isConsistent}
		\ElsIf{$\textsc{IsComplete}(h)$}
		\State $\textsc{processHistory}(h)$
		\Else
		\State $a \gets \nextEvent(h)$
		\label{algorithm:sound-complete:next}
		\Switch{$a.type()$}
		\Case{$\ibegin$}
		\Comment{$\ibegin$ and $\iwrite$ cases coincide.}
		\EndCase
		\Case{$\iwrite$}
		\label{algorithm:caseBeginWriteRec}
		\State $\textsc{STMC}_{rec}(h \bullet a)$
		\Break
		\EndCase
		
		
		\Case{$\iread$}
		\label{algorithm:caseReadRec}
		\State $x \in \mathcal{V}$ s.t. $\readVar{a}{x}$
		\ForAll{$w \in h \text{ s.t. } \writeVar{w}{x}$}
		\label{algorithm:sound-complete:forRead}
		\State $h' \gets h \bullet_w a$
		\State $\textsc{STMC}_{rec}(h')$
		\EndFor
		\Break
		\EndCase
		
		\Case{$\iend$}
		\State $\textsc{STMC}_{rec}(h \bullet a)$
		\label{algorithm:sound-complete:endNoSwap}
		\ForAll{$w \in \tr(a), x \in \mathcal{V}$ s.t. $\writeVar{w}{x}$}
		\ForAll{$r \in h \text{ s.t. } \readVar{r}{x}$}
		\label{algorithm:sound-complete:forEnd}
		\State $D \gets \{e \ | \ r <_h e \land \lnot (\tr(e) \ [\so \cup \wro]^* \ \tr(a))\}$
		\State $h' \gets (h \setminus D) \bullet a$; $\; h'.\wro[r] \gets w$
		\State $\textsc{STMC}_{rec}(h')$	
		\EndFor
		\EndFor
		\Break
		\EndCase
		\EndSwitch
		\EndIf
	\end{algorithmic}
	\label{algorithm:sound-complete}
\end{algorithm}

Algorithm \ref{algorithm:sound-complete} is in charge of extending non-total consistent histories, detecting inconsistencies as soon as they are created (line \ref{algorithm:sound-complete:isConsistent}). For doing so, given a history $h$, it computes the $\nextEvent$ event $a$ with which $h$ is going to be extended (line \ref{algorithm:sound-complete:next}). If $a$ has type $\ibegin$ or $\iwrite$ there is only way to extend $h$, via $h \bullet a$ (line \ref{algorithm:caseBeginWriteRec}). In case $a$ is a $\iread$ event (line \ref{algorithm:caseReadRec}), we explore all possible histories $h'$ where $h'.\wro(a) = w$ (line \ref{algorithm:sound-complete:forRead}). Otherwise, $a$ has type $\iend$ and we explore the case where no swap is produced (line \ref{algorithm:sound-complete:endNoSwap}) and when it is produced (line \ref{algorithm:sound-complete:forEnd}). There we compute the set $D$ of events that have to be deleted from the history as explained in \ref{subsection:ExtendingHistories}, removing it from $h$ and setting a new $\wro$ edge between $r$ and $w$. 

Only in the last case there is one transaction ending up pending, but thanks to theorem \ref{theorem:causalExtensibleModels}, if $h$ is executed in isolation, $h'$ will also be. Both arguments justify soundness and non-blocking properties of our algorithm. Completeness, on the other hand, it is not a immediate property.