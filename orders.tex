\subsection{Oracle and algorithm order}

The version here presented employs as parameter the program to analyze along with a total order called \callout{oracle order} between its transactions. This order, denoted as $\leq_{\ora}$ and trivially extensible to the events, has to respect the session order of the program (i.e. if $T \ [\so] \ T'$ then $T \leq_{\ora} T'$); forbidding executions any real processor would produce. This order will be constant during the whole algorithm's execution. 

In addition, we assume the algorithm maintains a total order between the events in every history, called \callout{algorithm order} and denoted as $\leq_h$, as well as a function $\nextEvent$ that given a non-total history $h$ returns the next event to be added. In a nutshell, it returns the minimal event according to $\ora$ that is not in $h$, prioritizing those events in pending transactions. Formally:

\begin{cframed}[pinegreen]
	\begin{equation*}
		\begin{array}{ccc}
			\nextEvent(h) & \coloneqq & 
			\left\{
			\begin{array}{cc}
				\min_{\ora}\{e \in \mathcal{E} \ | \ e \not\in h\} \cup \{\bot\} & \text{if } \not\exists T \text{ s.t. } \textsc{pending}_h(T) \\
				\min_{\ora}\{e \in\mathcal{E} \setminus h \ | \ e \in \textsc{pending}_h(T) \} & \text{otherwise}
			\end{array}
			\right.
		\end{array}
	\end{equation*}
\end{cframed}

%if there is an incomplete transaction, $\nextEvent(h)$ is the minimal event $e$ according to $\ora$ that is not in $h$ but $\ibegin(\tr(e)) \in h$.

%During this section we will present several approaches for finding a deterministic transactional model checker and we will show why STMC is the best among them. Every approach would be, in some particular sense, incremental; starting from an empty history and ``enlarging'' it, adding in each step new events and/or relations between them. For any fixed program, we will assume that no transaction enable/disable any other and that they are totally ordered by some relation $\ora$ called \textit{oracle order} that respects $\so$ (i.e. if $T \ [\so] \ T'$ then $T \ [\ora] \ T'$). Therefore, combining $\ora$ and $\po$ we can also say that the oracle order also enforces a total order between the events.


Thanks to this function, we will be able to extend any history $h = \langle E, \so, \wro \rangle$ in a deterministic way. Moreover, by its definition, we observe that $\nextEvent$ always propose to complete pending transactions before starting new ones. Therefore, it is a reasonable candidate as $\genericNext$ function in a algorithm \ref{algorithm:algo-class} instance.

\begin{figure}[H]
	
	\centering
	\begin{subfigure}[b]{.32\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3.5, 0) {\begin{tabular}{l} 
						$\wrt{x}{0}$ \\
						$\wrt{y}{0}$
				\end{tabular}};
				
				\node[draw, rounded corners=2mm,outer sep=0] (t2) at (-3.5, -2) {
					\begin{tabular}{l}
						$a \gets \rd{x}$ \\
						$b \gets \rd{y}$						
				\end{tabular}};
				
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {
					\begin{tabular}{l}
						$c \gets \rd{x}$ \\
						$\wrt{y}{2}$
				\end{tabular}};
				
				\node[draw, rounded corners=2mm,outer sep=0] (t4) at (0, -2) {
					\begin{tabular}{l} 
						$\wrt{y}{3}$ \\
						$d \gets \rd{y}$
				\end{tabular}};
				
				\path (t1) edge[left] node[yshift=0,xshift=0] {$\ora$} (t2);
				\path (t2) edge[above] node[yshift=0,xshift=0] {$\ora$} (t3);
				
				\path (t3.south east) -- (t3.south) coordinate[pos=0.67] (t3so);
				\path (t3.south west) -- (t3.south) coordinate[pos=0.67] (t3or);
				\path (t4.north east) -- (t4.north) coordinate[pos=0.67] (t4so);
				\path (t4.north west) -- (t4.north) coordinate[pos=0.67] (t4or);
				\path (t3or) edge[left] node[yshift=0,xshift=0] {$\ora$} (t4or);
				\path (t3so) edge[right] node[yshift=0,xshift=0] {$\so$} (t4so);
			\end{tikzpicture}  
			
		}
		\caption{$\ora$ produce a total order between all transactions in the program.}
		\label{fig:oracle_order:a}
	\end{subfigure}
	\hspace{.7cm}
	\centering
	\begin{subfigure}[b]{.32\textwidth}
		\resizebox{\textwidth}{!}{
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
				semithick, transform shape]
				\node[draw, rounded corners=2mm,outer sep=0] (t1) at (-3.5, 0) {\begin{tabular}{l} 
						$\wrt{x}{0}$ \\
						$\wrt{y}{0}$
				\end{tabular}};
				
				\node[draw, rounded corners=2mm,outer sep=0, opacity=0.3] (t2) at (-3.5, -2) {
					\begin{tabular}{l}
						$a \gets \rd{x}$ \\
						$b \gets \rd{y}$						
				\end{tabular}};
				
				\node[draw, rounded corners=2mm,outer sep=0] (t3) at (0, 0) {
					\begin{tabular}{l}
						$c \gets \rd{x}$ \\
						$\wrt{y}{2}$
				\end{tabular}};
				
				\node[draw, rounded corners=2mm,outer sep=0] (t4) at (0, -2) {
					\begin{tabular}{l} 
						$\wrt{y}{3}$ \\
						{\pgfsetfillopacity{0.3}$d \gets \rd{y}$}
				\end{tabular}};
				
				\path (t1) edge[left] node[yshift=0,xshift=0] {$\ora$} (t2);
				\path (t2) edge[above] node[yshift=0,xshift=0] {$\ora$} (t3);
				\path (t1) edge[above] node[yshift=0,xshift=0] {$\wro$} (t3);
				
				\path (t3.south east) -- (t3.south) coordinate[pos=0.67] (t3so);
				\path (t3.south west) -- (t3.south) coordinate[pos=0.67] (t3or);
				\path (t4.north east) -- (t4.north) coordinate[pos=0.67] (t4so);
				\path (t4.north west) -- (t4.north) coordinate[pos=0.67] (t4or);
				\path (t3or) edge[left] node[yshift=0,xshift=0] {$\ora$} (t4or);
				\path (t3so) edge[right] node[yshift=0,xshift=0] {$\so$} (t4so);
			\end{tikzpicture}  
			
		}
		\caption{An incomplete history and its $\ora$ order.}
		\label{fig:oracle_order:b}
	\end{subfigure}
	\caption{Some possible oracle order between transactions.}
	\label{fig:oracle_order}
	
\end{figure}

For example, given the history $h$ in Figure~\ref{fig:oracle_order:b}, the function $\nextEvent$ would return the event $d \gets \rd{y}$ instead of $a \gets \rd{x}$; as the forth transaction is pending in $h$. Finally, we declare the function $\evaluate$ that detects when a history is total.

\begin{cframed}[pinegreen]
	\begin{equation*}
		\begin{array}{ccc}
			\evaluate(h) & \coloneqq & \nextEvent(h) = \bot
		\end{array}
	\end{equation*}
\end{cframed}

%Nevertheless, we will guarantee in both cases that every possible incomplete history will be $\so$-bounded, i.e. if $e \ [\so \cup \po]^+ e'$ and $e' \in h$ then $e \in h$; in order to easily avoid eventual inconsistencies. Therefore, the global order $\ora$ presented in Figure~\ref{fig:oracle_order:a} restrict in a simple but effective way the duplicity between histories: the order events are being added don't cause \textit{per se} redundancies.%In the second case, to avoid randomness, we will have a function $\nextEvent$ that given a history $h$ returns the first event $e$ according to $\ora$ that is not in $h$; to obtain the new history $h' = h \bullet e$. For example, given the history in Figure~\ref{fig:oracle_order:b}, the function $\nextEvent$ would return the event $\ibegin$ associated to the second transaction. Nevertheless, we will guarantee in both cases that every possible incomplete history will be $\so$-bounded, i.e. if $e \ [\so \cup \po]^+ e'$ and $e' \in h$ then $e \in h$; in order to easily avoid eventual inconsistencies. Therefore, the global order $\ora$ presented in Figure~\ref{fig:oracle_order:a} restrict in a simple but effective way the duplicity between histories: the order events are being added don't cause \textit{per se} redundancies.

%Thanks to $\so$ and $\ora$ order, we will be able to track every possible history, and therefore, have control over the amount of graphs generated. 

%Incomplete histories can be extended in two ways: either with the extern help of some guide that select beforehand which events and in which order will be executed or without it. For managing the second case in a deterministic way, we will have a function $\nextEvent$ that maps every $h$ to some event that is not in $h$ for obtaining a new history $h' = h \bullet e$. If $h$ is incomplete and $l = \last{h}$ then $e$ is the minimum event in $\po_T$ bigger than $l$; but if not, $e$ is the $\ibegin$ event belonging to the minimal transaction $T$ according to $\ora$ that is not in $h$. For example, the function $\nextEvent$ would the history in Figure~\ref{fig:oracle_order:b} to the event $d \gets \rd{y}$. Clearly, any coherent history can be extended using $\nextEvent$ function resulting in a coherent history (as $\ora$ extends $\so$, it only suffices defining the $\wro$ edge that an eventual free $\iread$ would require).
%Nevertheless, we will guarantee in both cases that every possible incomplete history will be $\so$-bounded, i.e. if $e \ [\so \cup \po]^+ e'$ and $e' \in h$ then $e \in h$; in order to easily avoid eventual inconsistencies. Therefore, the global order $\ora$ presented in Figure~\ref{fig:oracle_order:a} restrict in a simple but effective way the duplicity between histories: the order events are being added don't cause \textit{per se} redundancies.%In the second case, to avoid randomness, we will have a function $\nextEvent$ that given a history $h$ returns the first event $e$ according to $\ora$ that is not in $h$; to obtain the new history $h' = h \bullet e$. For example, given the history in Figure~\ref{fig:oracle_order:b}, the function $\nextEvent$ would return the event $\ibegin$ associated to the second transaction. Nevertheless, we will guarantee in both cases that every possible incomplete history will be $\so$-bounded, i.e. if $e \ [\so \cup \po]^+ e'$ and $e' \in h$ then $e \in h$; in order to easily avoid eventual inconsistencies. Therefore, the global order $\ora$ presented in Figure~\ref{fig:oracle_order:a} restrict in a simple but effective way the duplicity between histories: the order events are being added don't cause \textit{per se} redundancies.